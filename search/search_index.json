{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Folder structure \u251c\u2500\u2500\u2500helper \u251c\u2500\u2500\u2500admin \u2514\u2500\u2500\u2500partners \u2514\u2500\u2500\u2500staff ApplicationHelper module The ApplicationHelper module is a utility module that provides a set of helper methods that can be used in views and controllers throughout a Ruby on Rails application. Here is a description of the title method you provided: Description: This method sets the title of the page by setting the value of the :title content variable. Input parameters: text: A string containing the title text to set. Output values: None. Error conditions: None. Examples of usage: Here's an example of how you might use the title method in a view: <% title 'My Page' %> This would set the :title content variable to 'My Page', which could then be used to set the title of the page in the layout file. For example: <title><%= content_for :title %></title> This would insert the value of the :title content variable into the title element of the page. subdomain function Description: This function generates a URL for a given subdomain by concatenating the subdomain with the host of the application. Input parameters: subdomain (string): The subdomain to be used in the generated URL. This parameter is optional, and if it is not provided, the function will use an empty string as the subdomain. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: with_subdomain(\"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") with_subdomain(nil) # returns \"localhost\" with_subdomain(\"\") # returns \"localhost\" url_for function : Description: This function generates a URL based on the provided options. If the :subdomain option is present, it will be used to generate the URL using the with_subdomain function. Input parameters: options (hash): A hash of options to be used to generate the URL. This parameter is optional, and if it is not provided, the function will use the default options. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: url_for(subdomain: \"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") url_for(host: \"example.com\") # returns \"example.com\" url_for # returns the default URL for the application","title":"Folder structure"},{"location":"#folder-structure","text":"\u251c\u2500\u2500\u2500helper \u251c\u2500\u2500\u2500admin \u2514\u2500\u2500\u2500partners \u2514\u2500\u2500\u2500staff","title":"Folder structure"},{"location":"#applicationhelper-module","text":"The ApplicationHelper module is a utility module that provides a set of helper methods that can be used in views and controllers throughout a Ruby on Rails application. Here is a description of the title method you provided: Description: This method sets the title of the page by setting the value of the :title content variable. Input parameters: text: A string containing the title text to set. Output values: None. Error conditions: None. Examples of usage: Here's an example of how you might use the title method in a view: <% title 'My Page' %> This would set the :title content variable to 'My Page', which could then be used to set the title of the page in the layout file. For example: <title><%= content_for :title %></title> This would insert the value of the :title content variable into the title element of the page.","title":"ApplicationHelper module"},{"location":"#subdomain-function","text":"Description: This function generates a URL for a given subdomain by concatenating the subdomain with the host of the application. Input parameters: subdomain (string): The subdomain to be used in the generated URL. This parameter is optional, and if it is not provided, the function will use an empty string as the subdomain. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: with_subdomain(\"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") with_subdomain(nil) # returns \"localhost\" with_subdomain(\"\") # returns \"localhost\" url_for function : Description: This function generates a URL based on the provided options. If the :subdomain option is present, it will be used to generate the URL using the with_subdomain function. Input parameters: options (hash): A hash of options to be used to generate the URL. This parameter is optional, and if it is not provided, the function will use the default options. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: url_for(subdomain: \"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") url_for(host: \"example.com\") # returns \"example.com\" url_for # returns the default URL for the application","title":"subdomain function"},{"location":"controller/","text":"Folder structure \u251c\u2500\u2500\u2500controllers \u251c\u2500\u2500\u2500admin \u2502 \u251c\u2500\u2500\u2500articles | | \u2502 \u251c\u2500\u2500\u2500categories \u2502 \u251c\u2500\u2500\u2500partner_categories \u2502 \u251c\u2500\u2500\u2500staff \u2502 \u2514\u2500\u2500\u2500vista_admins \u251c\u2500\u2500\u2500api \u2502 \u251c\u2500\u2500\u2500admin \u2502 \u2502 \u251c\u2500\u2500\u2500branches \u2502 \u2502 \u2514\u2500\u2500\u2500staff_members \u2502 \u251c\u2500\u2500\u2500partners \u2502 \u2502 \u2514\u2500\u2500\u2500v1 \u2502 \u2502 \u251c\u2500\u2500\u2500management \u2502 \u2502 \u2514\u2500\u2500\u2500staff \u2502 \u2514\u2500\u2500\u2500v1 \u2502 \u251c\u2500\u2500\u2500branches \u2502 \u251c\u2500\u2500\u2500categories \u2502 \u251c\u2500\u2500\u2500questions \u2502 \u251c\u2500\u2500\u2500sync \u2502 \u2514\u2500\u2500\u2500users \u251c\u2500\u2500\u2500concerns \u2514\u2500\u2500\u2500partners \u251c\u2500\u2500\u2500staff \u2514\u2500\u2500\u2500staff_members ApplicationController The ApplicationController is a base class for all the controllers in a Ruby on Rails application. It provides a number of common features that are useful in most controllers, such as support for flash messages and handling of exceptions. Here is a description of each part of the ApplicationController: include Pundit: This line includes the Pundit module, which provides a set of helper methods for authorization in the controller. protect_from_forgery with: :exception: This line enables protection against cross-site request forgery (CSRF) attacks. If a request is determined to be a forgery, an exception will be raised. add_flash_types :success, :error, :warning: This line adds custom flash types (e.g., :success, :error, :warning) that can be used to display flash messages to the user. layout :layout_by_resource: This line specifies a method (layout_by_resource) that will be used to determine the layout to use for the current request. devise_group :non_user, contains: %i[vista_admin staff_member]: This line specifies a group of Devise models (e.g., :vista_admin, :staff_member) that are treated as \"non-users\" for the purposes of Devise authentication. def info_for_paper_trail: This method returns a hash containing information about the current request (e.g., the IP address and user agent) that can be used by the PaperTrail gem to track changes in the application. def layout_by_resource: This method returns the name of the layout to use for the current request. If the current controller is a Devise controller, it returns 'devise', otherwise it returns 'application'. def convert_params_to_snakecase: This method converts the keys of the params hash to snakecase (e.g., 'userName' becomes 'user_name'). As the ApplicationController is a base class, it does not handle any routes or interact with any models directly. Instead, it provides common functionality that can be used by other controllers in the application. Error conditions that may be handled by the ApplicationController include CSRF attacks and other exceptions that may be raised during the handling of a request. Examples of usage for the ApplicationController might include setting flash messages or handling exceptions in controllers that inherit from it. For example: class PostsController < ApplicationController def create @post = Post.new(post_params) if @post.save flash[:success] = 'Post created successfully' redirect_to posts_path else flash[:error] = 'There was an error creating the post' render :new end end end In this example, the PostsController inherits from ApplicationController and makes use of the custom flash types (:success and :error) defined in the base class. It also utilizes the protect_from_forgery feature to protect against CSRF attacks. ReactEntryController ReactEntryController is a Rails controller class that inherits from ApplicationController. It defines a single action called index, which does not have an associated route by default. The index action sets an instance variable @react_entry_props equal to a hash with the key :data and the value \"This data is injected from the rails controller\". This variable is available to the view that is rendered for the index action. No models are interacted with in this controller. This controller does not define any error conditions or exception handling. To use this controller, you would need to define a route that maps to the index action, such as get '/react_entry' => 'react_entry#index'. Then, you can visit the URL corresponding to that route in a web browser to see the view rendered by the index action.","title":"structure"},{"location":"controller/#folder-structure","text":"\u251c\u2500\u2500\u2500controllers \u251c\u2500\u2500\u2500admin \u2502 \u251c\u2500\u2500\u2500articles | | \u2502 \u251c\u2500\u2500\u2500categories \u2502 \u251c\u2500\u2500\u2500partner_categories \u2502 \u251c\u2500\u2500\u2500staff \u2502 \u2514\u2500\u2500\u2500vista_admins \u251c\u2500\u2500\u2500api \u2502 \u251c\u2500\u2500\u2500admin \u2502 \u2502 \u251c\u2500\u2500\u2500branches \u2502 \u2502 \u2514\u2500\u2500\u2500staff_members \u2502 \u251c\u2500\u2500\u2500partners \u2502 \u2502 \u2514\u2500\u2500\u2500v1 \u2502 \u2502 \u251c\u2500\u2500\u2500management \u2502 \u2502 \u2514\u2500\u2500\u2500staff \u2502 \u2514\u2500\u2500\u2500v1 \u2502 \u251c\u2500\u2500\u2500branches \u2502 \u251c\u2500\u2500\u2500categories \u2502 \u251c\u2500\u2500\u2500questions \u2502 \u251c\u2500\u2500\u2500sync \u2502 \u2514\u2500\u2500\u2500users \u251c\u2500\u2500\u2500concerns \u2514\u2500\u2500\u2500partners \u251c\u2500\u2500\u2500staff \u2514\u2500\u2500\u2500staff_members","title":"Folder structure"},{"location":"controller/#applicationcontroller","text":"The ApplicationController is a base class for all the controllers in a Ruby on Rails application. It provides a number of common features that are useful in most controllers, such as support for flash messages and handling of exceptions. Here is a description of each part of the ApplicationController: include Pundit: This line includes the Pundit module, which provides a set of helper methods for authorization in the controller. protect_from_forgery with: :exception: This line enables protection against cross-site request forgery (CSRF) attacks. If a request is determined to be a forgery, an exception will be raised. add_flash_types :success, :error, :warning: This line adds custom flash types (e.g., :success, :error, :warning) that can be used to display flash messages to the user. layout :layout_by_resource: This line specifies a method (layout_by_resource) that will be used to determine the layout to use for the current request. devise_group :non_user, contains: %i[vista_admin staff_member]: This line specifies a group of Devise models (e.g., :vista_admin, :staff_member) that are treated as \"non-users\" for the purposes of Devise authentication. def info_for_paper_trail: This method returns a hash containing information about the current request (e.g., the IP address and user agent) that can be used by the PaperTrail gem to track changes in the application. def layout_by_resource: This method returns the name of the layout to use for the current request. If the current controller is a Devise controller, it returns 'devise', otherwise it returns 'application'. def convert_params_to_snakecase: This method converts the keys of the params hash to snakecase (e.g., 'userName' becomes 'user_name'). As the ApplicationController is a base class, it does not handle any routes or interact with any models directly. Instead, it provides common functionality that can be used by other controllers in the application. Error conditions that may be handled by the ApplicationController include CSRF attacks and other exceptions that may be raised during the handling of a request. Examples of usage for the ApplicationController might include setting flash messages or handling exceptions in controllers that inherit from it. For example: class PostsController < ApplicationController def create @post = Post.new(post_params) if @post.save flash[:success] = 'Post created successfully' redirect_to posts_path else flash[:error] = 'There was an error creating the post' render :new end end end In this example, the PostsController inherits from ApplicationController and makes use of the custom flash types (:success and :error) defined in the base class. It also utilizes the protect_from_forgery feature to protect against CSRF attacks.","title":"ApplicationController"},{"location":"controller/#reactentrycontroller","text":"ReactEntryController is a Rails controller class that inherits from ApplicationController. It defines a single action called index, which does not have an associated route by default. The index action sets an instance variable @react_entry_props equal to a hash with the key :data and the value \"This data is injected from the rails controller\". This variable is available to the view that is rendered for the index action. No models are interacted with in this controller. This controller does not define any error conditions or exception handling. To use this controller, you would need to define a route that maps to the index action, such as get '/react_entry' => 'react_entry#index'. Then, you can visit the URL corresponding to that route in a web browser to see the view rendered by the index action.","title":"ReactEntryController"},{"location":"controller/admin/","text":"Articles::PhotosController The Admin::Articles::PhotosController is a controller in the Admin namespace that is subclassed from Admin::BaseController. The find_article method is called as a before_action before any action in the controller. This method sets the @article instance variable to the Article with the id parameter passed in the request. The create action creates a new Photo associated with the @article and sets it to the @photo instance variable. If the @photo is successfully saved, it renders the @photo in JSON format with a status of :created. If the @photo fails to save, it renders the @photo in JSON format with a status of :unprocessable_entity. The find_article method is a private method that finds the Article with the id parameter passed in the request and sets it to the @article instance variable. The photo_params method is a private method that returns a strong parameter for the :photo attribute, allowing the :image attribute to be set. Categories::ReorderController The Admin::Categories::ReorderController is a controller for the administration section of the application that is responsible for reordering categories. Functions and routes handled: This controller only has one function, the update action, which is responsible for updating the position of categories based on the order parameter passed in the request. This action can be accessed via the /admin/categories/reorder route. Models interacted with: This controller interacts with the Category model in order to update the position of categories. Error conditions: If the order parameter is not provided in the request, the controller will return a 400 Bad Request error. Examples of usage: This controller might be used to allow administrators to rearrange the order of categories displayed on the frontend of the application. For example, a request to /admin/categories/reorder with the following order parameter: { \"order\": [ { \"id\": 1, \"position\": 2 }, { \"id\": 2, \"position\": 1 }, { \"id\": 3, \"position\": 3 } ] } Would result in the first category being moved to the second position, the second category being moved to the first position, and the third category remaining in the third position. PartnerCategories::ReorderController The Admin::PartnerCategories::ReorderController is a subclass of the Admin::BaseController and is responsible for reordering PartnerCategory models. The controller defines a single action, update, which is called when a PATCH request is made to the corresponding route. The update action reorders the PartnerCategory models based on the order parameter passed in the request. It does this by iterating through each element of the order hash, finding the corresponding PartnerCategory model using the id value, and updating its position attribute with the position value from the hash. Finally, the action sends an :ok response to the client. This controller interacts with the PartnerCategory model. An error condition would occur if the id value in the order parameter does not correspond to a valid PartnerCategory model. In this case, a ActiveRecord::RecordNotFound error would be raised. An example of usage of this controller would be a request to the /admin/partner_categories/reorder route with a PATCH method, passing an order parameter with the desired reordering of PartnerCategory models. Staff::AdminsController The Admin::Staff::AdminsController is a subclass of Admin::BaseController which is in the Admin module. This controller has several actions: index, new, create, edit, update, and destroy. The index action displays a paginated list of admins belonging to a specific organisation. This is done by calling @organisation.admins.page(params[:page]). The new action creates a new Admin object which is associated with the specified organisation. The create action creates a new Admin object using the admin_params method to strong params the request. If the object is saved successfully, the user is redirected to the list of admins for the organisation with a success message. If not, the user is shown the new form again. The edit action displays a form for editing the specified Admin object. The update action updates the specified Admin object using the admin_params method to strong params the request. If the update is successful, the user is redirected to the list of admins for the organisation with a success message. If not, the user is shown the edit form again. The destroy action destroys the specified Admin object and redirects the user to the list of admins for the organisation with a success message. The find_organisation method sets the @organisation instance variable by finding an Organisation object using the params[:organisation_id]. The find_admin method sets the @admin instance variable by finding an Admin object belonging to the @organisation using the params[:id]. The admin_params method is used to strong params the request and only allows the specified parameters to be passed through. The permitted_params method specifies the list of allowed parameters. VistaAdmins::ConfirmationsController The Admin::VistaAdmins::ConfirmationsController is a subclass of Devise::ConfirmationsController and is responsible for handling confirmation related actions for vista admins. The update action handles updating the password for an unconfirmed vista admin with a confirmation token. If the vista admin's password is successfully set, the vista admin is confirmed and redirected to the sign in page. If the password is invalid or the vista admin has already set a password, the vista admin is shown the confirmation page again with error messages. The show action displays the confirmation page for an unconfirmed vista admin with a confirmation token. If the vista admin has already set a password, the vista admin is confirmed and redirected to the sign in page. If the vista admin has not set a password, the vista admin is shown the confirmation page with a form to set a password. The with_unconfirmed_confirmable method finds the vista admin with the given confirmation token or initializes a new vista admin with an error if the confirmation token is invalid. The do_show method sets instance variables and renders the confirmation page. The do_confirm method confirms the vista admin and redirects the vista admin to the sign in page. ArticlesController The Admin::ArticlesController is a subclass of the Admin::BaseController and is used to manage articles in the application. The controller has several actions: index, new, show, edit, update, and destroy. The index action is used to display a paginated list of articles, the new action is used to create a new article, the show action displays a single article, the edit action allows for editing an article, the update action updates an article, and the destroy action deletes an article. The controller interacts with the Article model and uses the has_scope method to add a search scope. The update action will render the edit template if the update to the article was unsuccessful. The destroy action will redirect to the index action with a success message if the article was successfully deleted. The controller uses strong parameters to permit the title, content, publish_at, header_image_attributes, and content_category_ids attributes for the article. An example of usage could be an admin wanting to delete an article: they would navigate to the show page for the article and click the delete button which would send a DELETE request to the destroy action and delete the article from the database. BaseController The Admin::BaseController is a base controller for all controllers in the Admin namespace. It is a subclass of the ApplicationController and includes various before and after actions as well as a rescue from block. Functions and routes handled: This controller does not handle any functions or routes directly. It only provides shared functionality and configurations for controllers within the Admin namespace. Models interacted with: This controller interacts with the VistaAdmin model through the current_vista_admin method, which returns the currently logged in VistaAdmin. It also interacts with the Raven and PaperTrail gems to set context and track changes, respectively. Error conditions: This controller includes a rescue from block to handle the Pundit::NotAuthorizedError error. When this error is raised, the not_authorized private method is called, which sets a flash message and redirects to the admin root path. Examples of usage: This controller is intended to be used as a base for controllers within the Admin namespace. It provides shared functionality and configurations for these controllers, such as authentication, error handling, and change tracking. An example of a controller that extends from this controller is the Admin::ArticlesController. BranchesController Admin::BranchesController is a controller for handling the creation, updating, and deleting of branches. It is a subclass of the Admin::BaseController, which provides some additional functionality such as authentication and error handling. This controller is only accessible to authenticated vista_admins. Functions and routes handled: This controller handles the following routes: GET /admin/organisations/:organisation_id/business_units/:business_unit_id/branches: This route is used to display a paginated list of branches belonging to a specific business unit. GET /admin/organisations/:organisation_id/business_units/:business_unit_id/branches/new: This route is used to display a form for creating a new branch. POST /admin/organisations/:organisation_id/business_units/:business_unit_id/branches: This route is used to create a new branch using the form data submitted by the user. GET /admin/organisations/:organisation_id/business_units/:business_unit_id/branches/:id/edit: This route is used to display a form for editing an existing branch. PATCH /admin/organisations/:organisation_id/business_units/:business_unit_id/branches/:id: This route is used to update an existing branch using the form data submitted by the user. BusinessUnitsController The Admin::BusinessUnitsController is a subclass of Admin::BaseController and is responsible for handling business unit related actions for the admin panel. Functions: index, show, new, edit, create, update, destroy Routes handled: GET /admin/organisations/:organisation_id/business_units(.:format) - index GET /admin/organisations/:organisation_id/business_units/new(.:format) - new POST /admin/organisations/:organisation_id/business_units(.:format) - create GET /admin/organisations/:organisation_id/business_units/:id/edit(.:format) - edit PATCH/PUT /admin/organisations/:organisation_id/business_units/:id(.:format) - update DELETE /admin/organisations/:organisation_id/business_units/:id(.:format) - destroy Models interacted with: Organisation, BusinessUnit Error conditions: If the business unit fails to save or update, the controller will render the new or edit views with error messages. If the business unit fails to destroy, the controller will redirect to the index page with a flash message. Examples of usage: An admin navigates to the business units index page and clicks on the \"New Business Unit\" button to create a new business unit for a specific organisation. They fill out the form and submit it, and the controller creates a new business unit object and saves it to the database. An admin navigates to the edit page for a specific business unit and clicks on the \"Update Business Unit\" button. The controller updates the business unit with the new data and redirects to the index page with a success message. CategoriesController Admin::CategoriesController is a controller in the admin namespace that allows users to manage categories in the application. Functions: index, show, new, edit, create, update, destroy. These functions correspond to the RESTful routes for managing categories. Routes handled: '/admin/categories' (index, show, new, edit, create, update, destroy). Models interacted with: Category. Error conditions: If the category fails to save or update, the user is shown an error and returned to the form. If the category is not found when trying to show, edit, update, or destroy, the user is redirected to the index page with a flash message. Examples of usage: An admin wants to view a list of all categories: they would visit '/admin/categories' and the index function would be triggered. An admin wants to create a new category: they would visit '/admin/categories/new' and the new function would be triggered. If they submit the form, the create function would be triggered to save the new category to the database. An admin wants to update an existing category: they would visit '/admin/categories/:id/edit' and the edit function would be triggered. If they submit the form, the update function would be triggered to save the changes to the database. CitiesController The Admin::CitiesController is a controller for the city resource in the admin panel. It handles the following routes: index, show, new, edit, create, update, and destroy. It interacts with the City model and the Photo model through the city_params method. Error conditions that could be encountered include invalid input for city attributes or attempting to delete a city that is in use. Examples of usage include creating a new city, viewing a list of cities, updating the attributes of a city, or deleting a city. DataImportsController The Admin::DataImportsController is a controller for creating, viewing, and managing data imports in the administration panel. Functions and routes handled: index: displays a paginated list of data imports new: displays a form for creating a new data import create: creates a new data import and queues it for processing show: displays the details and status of a specific data import Models interacted with: DataImport: this controller interacts with the DataImport model to create, view, and manage data imports. Error conditions: If there is an error saving the data import, the create action will re-render the form with an error message. Examples of usage: As an administrator, I can go to the /admin/data_imports route and view a list of all data imports that have been created. As an administrator, I can go to the /admin/data_imports/new route and create a new data import by uploading a file and selecting categories and questions to import. As an administrator, I can go to the /admin/data_imports/:id route and view the details and status of a specific data import. OrganisationsController The Admin::OrganisationsController is a controller for managing organizations within an application. It has actions for listing organizations (index), showing a single organization (show), creating a new organization (new and create), updating an existing organization (edit and update), and destroying an organization (destroy). It interacts with the Organisation model to retrieve and persist data related to organizations. If an organization cannot be found in the database for show, edit, update, or destroy actions, a 404 error will be raised. Example usage: A user with admin privileges visits /admin/organisations to view a list of all organizations in the application. They click on the \"New Organization\" button and are taken to the new organization form at /admin/organisations/new. They fill out the form and submit it, creating a new organization and being redirected to the index page with a success message. PartnerCategoriesController Admin::PartnerCategoriesController is a controller in the admin namespace. It is a subclass of Admin::BaseController, so it inherits behavior from that class such as authenticating the vista admin, setting the Raven context and whodunnit, and handling Pundit::NotAuthorizedError exceptions. The controller has actions for listing, showing, creating, updating, and deleting partner categories. It interacts with the PartnerCategory model and the Photo model through associations. In the case of an error, such as validation errors when creating or updating a partner category, the user is shown an error message and the relevant form is re-rendered. An example of usage would be an admin visiting /admin/partner_categories in their web browser, which would display a list of all partner categories. They could then click on a category to edit it, or click \"New Category\" to create a new one. PreferenceGroupsController The Admin::PreferenceGroupsController is a controller in the Admin namespace. The controller has actions for managing preference groups, including: index: displays a paginated list of all preference groups. show: redirects to the edit page for the preference group. new: displays a form for creating a new preference group. create: creates a new preference group using the parameters from the form submission. edit: displays a form for editing an existing preference group. update: updates an existing preference group using the parameters from the form submission. destroy: deletes an existing preference group. The controller interacts with the PreferenceGroup model to retrieve, create, update, and delete preference groups. In the case of an error during creation or update, the controller will render the new or edit templates, respectively, with error messages. Example usage: visiting /admin/preference_groups in the browser will display the index page for preference groups. Submitting a form on the new page will create a new preference group, and clicking the \"Edit\" button for a preference group on the index page will display the edit form for that preference group. QuestionsController The Admin::QuestionsController is a controller that allows an administrator to perform CRUD (create, read, update, delete) operations on Question objects. The controller is accessible at the /admin/questions route and handles the following actions: index: renders a paginated list of Question objects that can be filtered by category and kind. The list can be rendered as HTML, JSON, or JavaScript. show: redirects to the edit action for the specified Question object. new: renders a form for creating a new Question object. create: creates a new Question object with the parameters from the form submission. edit: renders a form for editing an existing Question object. update: updates an existing Question object with the parameters from the form submission. destroy: deletes an existing Question object. The Question model is interacted with in all actions. In the event of an error, such as an invalid form submission, the appropriate action will render the form again with an error message. An example of usage would be an administrator visiting the /admin/questions route, filtering the list by category, and deleting a Question object. ReleasesController The Admin::ReleasesController is a controller in the admin namespace that handles actions related to releases. The index action retrieves all releases and paginates them for display in the view. The create action creates a new release object and responds to both HTML and JavaScript requests. The destroy action deletes a specified release object. The download action retrieves a specified release object and sends it to the user as a download with a JSON MIME type and an attachment disposition. The controller interacts with the Release model. An error could occur if a release object is not found when attempting to delete or download it. Example usage: A user visits the /admin/releases path to view a list of releases, clicks a button to create a new release, clicks a delete button to remove a release, and clicks a download button to download a release. RolesController The Admin::RolesController is a controller in the administrative section of a web application that handles the creation, reading, updating, and deletion of roles in the application. The controller has the following functions: index, show, new, edit, create, update, and destroy. The routes handled by the controller include /roles, /roles/new, /roles/:id/edit, /roles/:id, and /roles/:id. The Role model is interacted with in this controller. An error condition occurs when trying to delete a role and no replacement role is specified. In this case, a JSON response with an error message is returned with a status code of 422 (Unprocessable Entity). Examples of usage include visiting the /roles route to view a list of all roles, visiting the /roles/new route to create a new role, visiting the /roles/:id/edit route to edit an existing role, and visiting the /roles/:id route to view a specific role. VideosController The Admin::VideosController is a controller for the administration panel that allows admins to manage videos. The controller has several actions: index: displays a paginated list of videos, which can be filtered by organisation and searched. new: displays a form for creating a new video. create: saves a new video to the database. edit: displays a form for editing an existing video. update: updates an existing video in the database. destroy: deletes an existing video from the database. The controller interacts with the Video model to retrieve and manipulate video data. If there are any errors when creating or updating a video, the user will be shown the appropriate form with error messages. Examples of usage include creating a new video, editing the details of an existing video, or deleting a video that is no longer needed.","title":"Admin"},{"location":"controller/admin/#articlesphotoscontroller","text":"The Admin::Articles::PhotosController is a controller in the Admin namespace that is subclassed from Admin::BaseController. The find_article method is called as a before_action before any action in the controller. This method sets the @article instance variable to the Article with the id parameter passed in the request. The create action creates a new Photo associated with the @article and sets it to the @photo instance variable. If the @photo is successfully saved, it renders the @photo in JSON format with a status of :created. If the @photo fails to save, it renders the @photo in JSON format with a status of :unprocessable_entity. The find_article method is a private method that finds the Article with the id parameter passed in the request and sets it to the @article instance variable. The photo_params method is a private method that returns a strong parameter for the :photo attribute, allowing the :image attribute to be set.","title":"Articles::PhotosController"},{"location":"controller/admin/#categoriesreordercontroller","text":"The Admin::Categories::ReorderController is a controller for the administration section of the application that is responsible for reordering categories. Functions and routes handled: This controller only has one function, the update action, which is responsible for updating the position of categories based on the order parameter passed in the request. This action can be accessed via the /admin/categories/reorder route. Models interacted with: This controller interacts with the Category model in order to update the position of categories. Error conditions: If the order parameter is not provided in the request, the controller will return a 400 Bad Request error. Examples of usage: This controller might be used to allow administrators to rearrange the order of categories displayed on the frontend of the application. For example, a request to /admin/categories/reorder with the following order parameter: { \"order\": [ { \"id\": 1, \"position\": 2 }, { \"id\": 2, \"position\": 1 }, { \"id\": 3, \"position\": 3 } ] } Would result in the first category being moved to the second position, the second category being moved to the first position, and the third category remaining in the third position.","title":"Categories::ReorderController"},{"location":"controller/admin/#partnercategoriesreordercontroller","text":"The Admin::PartnerCategories::ReorderController is a subclass of the Admin::BaseController and is responsible for reordering PartnerCategory models. The controller defines a single action, update, which is called when a PATCH request is made to the corresponding route. The update action reorders the PartnerCategory models based on the order parameter passed in the request. It does this by iterating through each element of the order hash, finding the corresponding PartnerCategory model using the id value, and updating its position attribute with the position value from the hash. Finally, the action sends an :ok response to the client. This controller interacts with the PartnerCategory model. An error condition would occur if the id value in the order parameter does not correspond to a valid PartnerCategory model. In this case, a ActiveRecord::RecordNotFound error would be raised. An example of usage of this controller would be a request to the /admin/partner_categories/reorder route with a PATCH method, passing an order parameter with the desired reordering of PartnerCategory models.","title":"PartnerCategories::ReorderController"},{"location":"controller/admin/#staffadminscontroller","text":"The Admin::Staff::AdminsController is a subclass of Admin::BaseController which is in the Admin module. This controller has several actions: index, new, create, edit, update, and destroy. The index action displays a paginated list of admins belonging to a specific organisation. This is done by calling @organisation.admins.page(params[:page]). The new action creates a new Admin object which is associated with the specified organisation. The create action creates a new Admin object using the admin_params method to strong params the request. If the object is saved successfully, the user is redirected to the list of admins for the organisation with a success message. If not, the user is shown the new form again. The edit action displays a form for editing the specified Admin object. The update action updates the specified Admin object using the admin_params method to strong params the request. If the update is successful, the user is redirected to the list of admins for the organisation with a success message. If not, the user is shown the edit form again. The destroy action destroys the specified Admin object and redirects the user to the list of admins for the organisation with a success message. The find_organisation method sets the @organisation instance variable by finding an Organisation object using the params[:organisation_id]. The find_admin method sets the @admin instance variable by finding an Admin object belonging to the @organisation using the params[:id]. The admin_params method is used to strong params the request and only allows the specified parameters to be passed through. The permitted_params method specifies the list of allowed parameters.","title":"Staff::AdminsController"},{"location":"controller/admin/#vistaadminsconfirmationscontroller","text":"The Admin::VistaAdmins::ConfirmationsController is a subclass of Devise::ConfirmationsController and is responsible for handling confirmation related actions for vista admins. The update action handles updating the password for an unconfirmed vista admin with a confirmation token. If the vista admin's password is successfully set, the vista admin is confirmed and redirected to the sign in page. If the password is invalid or the vista admin has already set a password, the vista admin is shown the confirmation page again with error messages. The show action displays the confirmation page for an unconfirmed vista admin with a confirmation token. If the vista admin has already set a password, the vista admin is confirmed and redirected to the sign in page. If the vista admin has not set a password, the vista admin is shown the confirmation page with a form to set a password. The with_unconfirmed_confirmable method finds the vista admin with the given confirmation token or initializes a new vista admin with an error if the confirmation token is invalid. The do_show method sets instance variables and renders the confirmation page. The do_confirm method confirms the vista admin and redirects the vista admin to the sign in page.","title":"VistaAdmins::ConfirmationsController"},{"location":"controller/admin/#articlescontroller","text":"The Admin::ArticlesController is a subclass of the Admin::BaseController and is used to manage articles in the application. The controller has several actions: index, new, show, edit, update, and destroy. The index action is used to display a paginated list of articles, the new action is used to create a new article, the show action displays a single article, the edit action allows for editing an article, the update action updates an article, and the destroy action deletes an article. The controller interacts with the Article model and uses the has_scope method to add a search scope. The update action will render the edit template if the update to the article was unsuccessful. The destroy action will redirect to the index action with a success message if the article was successfully deleted. The controller uses strong parameters to permit the title, content, publish_at, header_image_attributes, and content_category_ids attributes for the article. An example of usage could be an admin wanting to delete an article: they would navigate to the show page for the article and click the delete button which would send a DELETE request to the destroy action and delete the article from the database.","title":"ArticlesController"},{"location":"controller/admin/#basecontroller","text":"The Admin::BaseController is a base controller for all controllers in the Admin namespace. It is a subclass of the ApplicationController and includes various before and after actions as well as a rescue from block. Functions and routes handled: This controller does not handle any functions or routes directly. It only provides shared functionality and configurations for controllers within the Admin namespace. Models interacted with: This controller interacts with the VistaAdmin model through the current_vista_admin method, which returns the currently logged in VistaAdmin. It also interacts with the Raven and PaperTrail gems to set context and track changes, respectively. Error conditions: This controller includes a rescue from block to handle the Pundit::NotAuthorizedError error. When this error is raised, the not_authorized private method is called, which sets a flash message and redirects to the admin root path. Examples of usage: This controller is intended to be used as a base for controllers within the Admin namespace. It provides shared functionality and configurations for these controllers, such as authentication, error handling, and change tracking. An example of a controller that extends from this controller is the Admin::ArticlesController.","title":"BaseController"},{"location":"controller/admin/#branchescontroller","text":"Admin::BranchesController is a controller for handling the creation, updating, and deleting of branches. It is a subclass of the Admin::BaseController, which provides some additional functionality such as authentication and error handling. This controller is only accessible to authenticated vista_admins. Functions and routes handled: This controller handles the following routes: GET /admin/organisations/:organisation_id/business_units/:business_unit_id/branches: This route is used to display a paginated list of branches belonging to a specific business unit. GET /admin/organisations/:organisation_id/business_units/:business_unit_id/branches/new: This route is used to display a form for creating a new branch. POST /admin/organisations/:organisation_id/business_units/:business_unit_id/branches: This route is used to create a new branch using the form data submitted by the user. GET /admin/organisations/:organisation_id/business_units/:business_unit_id/branches/:id/edit: This route is used to display a form for editing an existing branch. PATCH /admin/organisations/:organisation_id/business_units/:business_unit_id/branches/:id: This route is used to update an existing branch using the form data submitted by the user.","title":"BranchesController"},{"location":"controller/admin/#businessunitscontroller","text":"The Admin::BusinessUnitsController is a subclass of Admin::BaseController and is responsible for handling business unit related actions for the admin panel. Functions: index, show, new, edit, create, update, destroy Routes handled: GET /admin/organisations/:organisation_id/business_units(.:format) - index GET /admin/organisations/:organisation_id/business_units/new(.:format) - new POST /admin/organisations/:organisation_id/business_units(.:format) - create GET /admin/organisations/:organisation_id/business_units/:id/edit(.:format) - edit PATCH/PUT /admin/organisations/:organisation_id/business_units/:id(.:format) - update DELETE /admin/organisations/:organisation_id/business_units/:id(.:format) - destroy Models interacted with: Organisation, BusinessUnit Error conditions: If the business unit fails to save or update, the controller will render the new or edit views with error messages. If the business unit fails to destroy, the controller will redirect to the index page with a flash message. Examples of usage: An admin navigates to the business units index page and clicks on the \"New Business Unit\" button to create a new business unit for a specific organisation. They fill out the form and submit it, and the controller creates a new business unit object and saves it to the database. An admin navigates to the edit page for a specific business unit and clicks on the \"Update Business Unit\" button. The controller updates the business unit with the new data and redirects to the index page with a success message.","title":"BusinessUnitsController"},{"location":"controller/admin/#categoriescontroller","text":"Admin::CategoriesController is a controller in the admin namespace that allows users to manage categories in the application. Functions: index, show, new, edit, create, update, destroy. These functions correspond to the RESTful routes for managing categories. Routes handled: '/admin/categories' (index, show, new, edit, create, update, destroy). Models interacted with: Category. Error conditions: If the category fails to save or update, the user is shown an error and returned to the form. If the category is not found when trying to show, edit, update, or destroy, the user is redirected to the index page with a flash message. Examples of usage: An admin wants to view a list of all categories: they would visit '/admin/categories' and the index function would be triggered. An admin wants to create a new category: they would visit '/admin/categories/new' and the new function would be triggered. If they submit the form, the create function would be triggered to save the new category to the database. An admin wants to update an existing category: they would visit '/admin/categories/:id/edit' and the edit function would be triggered. If they submit the form, the update function would be triggered to save the changes to the database.","title":"CategoriesController"},{"location":"controller/admin/#citiescontroller","text":"The Admin::CitiesController is a controller for the city resource in the admin panel. It handles the following routes: index, show, new, edit, create, update, and destroy. It interacts with the City model and the Photo model through the city_params method. Error conditions that could be encountered include invalid input for city attributes or attempting to delete a city that is in use. Examples of usage include creating a new city, viewing a list of cities, updating the attributes of a city, or deleting a city.","title":"CitiesController"},{"location":"controller/admin/#dataimportscontroller","text":"The Admin::DataImportsController is a controller for creating, viewing, and managing data imports in the administration panel. Functions and routes handled: index: displays a paginated list of data imports new: displays a form for creating a new data import create: creates a new data import and queues it for processing show: displays the details and status of a specific data import Models interacted with: DataImport: this controller interacts with the DataImport model to create, view, and manage data imports. Error conditions: If there is an error saving the data import, the create action will re-render the form with an error message. Examples of usage: As an administrator, I can go to the /admin/data_imports route and view a list of all data imports that have been created. As an administrator, I can go to the /admin/data_imports/new route and create a new data import by uploading a file and selecting categories and questions to import. As an administrator, I can go to the /admin/data_imports/:id route and view the details and status of a specific data import.","title":"DataImportsController"},{"location":"controller/admin/#organisationscontroller","text":"The Admin::OrganisationsController is a controller for managing organizations within an application. It has actions for listing organizations (index), showing a single organization (show), creating a new organization (new and create), updating an existing organization (edit and update), and destroying an organization (destroy). It interacts with the Organisation model to retrieve and persist data related to organizations. If an organization cannot be found in the database for show, edit, update, or destroy actions, a 404 error will be raised. Example usage: A user with admin privileges visits /admin/organisations to view a list of all organizations in the application. They click on the \"New Organization\" button and are taken to the new organization form at /admin/organisations/new. They fill out the form and submit it, creating a new organization and being redirected to the index page with a success message.","title":"OrganisationsController"},{"location":"controller/admin/#partnercategoriescontroller","text":"Admin::PartnerCategoriesController is a controller in the admin namespace. It is a subclass of Admin::BaseController, so it inherits behavior from that class such as authenticating the vista admin, setting the Raven context and whodunnit, and handling Pundit::NotAuthorizedError exceptions. The controller has actions for listing, showing, creating, updating, and deleting partner categories. It interacts with the PartnerCategory model and the Photo model through associations. In the case of an error, such as validation errors when creating or updating a partner category, the user is shown an error message and the relevant form is re-rendered. An example of usage would be an admin visiting /admin/partner_categories in their web browser, which would display a list of all partner categories. They could then click on a category to edit it, or click \"New Category\" to create a new one.","title":"PartnerCategoriesController"},{"location":"controller/admin/#preferencegroupscontroller","text":"The Admin::PreferenceGroupsController is a controller in the Admin namespace. The controller has actions for managing preference groups, including: index: displays a paginated list of all preference groups. show: redirects to the edit page for the preference group. new: displays a form for creating a new preference group. create: creates a new preference group using the parameters from the form submission. edit: displays a form for editing an existing preference group. update: updates an existing preference group using the parameters from the form submission. destroy: deletes an existing preference group. The controller interacts with the PreferenceGroup model to retrieve, create, update, and delete preference groups. In the case of an error during creation or update, the controller will render the new or edit templates, respectively, with error messages. Example usage: visiting /admin/preference_groups in the browser will display the index page for preference groups. Submitting a form on the new page will create a new preference group, and clicking the \"Edit\" button for a preference group on the index page will display the edit form for that preference group.","title":"PreferenceGroupsController"},{"location":"controller/admin/#questionscontroller","text":"The Admin::QuestionsController is a controller that allows an administrator to perform CRUD (create, read, update, delete) operations on Question objects. The controller is accessible at the /admin/questions route and handles the following actions: index: renders a paginated list of Question objects that can be filtered by category and kind. The list can be rendered as HTML, JSON, or JavaScript. show: redirects to the edit action for the specified Question object. new: renders a form for creating a new Question object. create: creates a new Question object with the parameters from the form submission. edit: renders a form for editing an existing Question object. update: updates an existing Question object with the parameters from the form submission. destroy: deletes an existing Question object. The Question model is interacted with in all actions. In the event of an error, such as an invalid form submission, the appropriate action will render the form again with an error message. An example of usage would be an administrator visiting the /admin/questions route, filtering the list by category, and deleting a Question object.","title":"QuestionsController"},{"location":"controller/admin/#releasescontroller","text":"The Admin::ReleasesController is a controller in the admin namespace that handles actions related to releases. The index action retrieves all releases and paginates them for display in the view. The create action creates a new release object and responds to both HTML and JavaScript requests. The destroy action deletes a specified release object. The download action retrieves a specified release object and sends it to the user as a download with a JSON MIME type and an attachment disposition. The controller interacts with the Release model. An error could occur if a release object is not found when attempting to delete or download it. Example usage: A user visits the /admin/releases path to view a list of releases, clicks a button to create a new release, clicks a delete button to remove a release, and clicks a download button to download a release.","title":"ReleasesController"},{"location":"controller/admin/#rolescontroller","text":"The Admin::RolesController is a controller in the administrative section of a web application that handles the creation, reading, updating, and deletion of roles in the application. The controller has the following functions: index, show, new, edit, create, update, and destroy. The routes handled by the controller include /roles, /roles/new, /roles/:id/edit, /roles/:id, and /roles/:id. The Role model is interacted with in this controller. An error condition occurs when trying to delete a role and no replacement role is specified. In this case, a JSON response with an error message is returned with a status code of 422 (Unprocessable Entity). Examples of usage include visiting the /roles route to view a list of all roles, visiting the /roles/new route to create a new role, visiting the /roles/:id/edit route to edit an existing role, and visiting the /roles/:id route to view a specific role.","title":"RolesController"},{"location":"controller/admin/#videoscontroller","text":"The Admin::VideosController is a controller for the administration panel that allows admins to manage videos. The controller has several actions: index: displays a paginated list of videos, which can be filtered by organisation and searched. new: displays a form for creating a new video. create: saves a new video to the database. edit: displays a form for editing an existing video. update: updates an existing video in the database. destroy: deletes an existing video from the database. The controller interacts with the Video model to retrieve and manipulate video data. If there are any errors when creating or updating a video, the user will be shown the appropriate form with error messages. Examples of usage include creating a new video, editing the details of an existing video, or deleting a video that is no longer needed.","title":"VideosController"},{"location":"controller/api/","text":"Branches::ProfilesController The ProfilesController is a controller within the Branches module, which provides an API for creating and managing profiles for branches within a business unit. Functions and routes handled: request: Handles a request to create a new profile for a given branch. Routes: POST /api/admin/units/:unit_id/branches/:branch_id/profiles/request: create a new profile request for a given branch. Models interacted with: ProfileRequest: a model representing a request for a new profile for a branch. BusinessUnit: a model representing a business unit. Branch: a model representing a branch within a business unit. Error conditions: If the user is not authorized to create a new profile request, a 401 Unauthorized error is returned. If the request to create a new profile fails, a 422 Unprocessable Entity error is returned. Examples of usage: A client could send a POST request to /api/admin/units/123/branches/456/profiles/request with an authenticated request to create a new profile request for the branch with ID 456 within the business unit with ID 123. Branches::StaffController The Branches::StaffController is a controller within the admin panel of the application, and is responsible for managing staff members at a specific branch within a business unit. This controller handles the following routes: GET /api/admin/units/:unit_id/branches/:branch_id/staff: This route returns a list of staff members at the specified branch. POST /api/admin/units/:unit_id/branches/:branch_id/staff: This route assigns a staff member to the specified branch. DELETE /api/admin/units/:unit_id/branches/:branch_id/staff: This route removes a staff member from the specified branch. This controller interacts with the following models: StaffMember BusinessUnit Error conditions: If the specified staff member or business unit cannot be found, this controller will return a 404 status code. If the request to create or destroy a staff assignment fails, this controller will return a 422 status code. Examples of usage: A request to GET /api/admin/units/1/branches/2/staff will retrieve a list of staff members at branch 2 within business unit 1. A request to POST /api/admin/units/1/branches/2/staff with a staff member ID in the request body will assign the staff member to branch 2 within business unit 1. A request to DELETE /api/admin/units/1/branches/2/staff with a staff member ID in the request body will remove the staff member from branch 2 within business unit 1. StaffMembersAuthenticationController Description: The AuthenticationController is responsible for handling staff member authentication requests. It is a part of the StaffMembers namespace, and is subclassed from ApiController. Functions and routes handled: The controller has a single action, create, which is used to handle staff member login requests. The create action is routed at /api/admin/staff_members/authentication. Models interacted with: The controller interacts with the StaffMember model. Error conditions: If the StaffMember::Authenticate command is not successful, an error message is returned to the client. If the staff member's account has been suspended, an unauthorized error message is returned. Examples of usage: A client can send a POST request to /api/admin/staff_members/authentication with email and password params to attempt to log in a staff member. If the login is successful, the client will receive a JSON response with an authentication token, the staff member's organisation name, and the staff member's user type. If the login is unsuccessful, an error message will be returned to the client. StaffMembers::ConfirmationsController This is a controller for the API of the admin panel of a system that manages staff members. It is in the StaffMembers namespace and is called ConfirmationsController. It is a subclass of ApiController and therefore inherits behavior from it. It has a before_action hook that skips the authorization step for all actions in this controller. It has a single action, update, which is used to confirm a staff member's account. It first uses the with_unconfirmed_confirmable method to find the staff member to be confirmed, using the confirmation_token field in the staff_member params. If the staff member is found and is unconfirmed, it proceeds with the confirmation process. If the staff member has no password, it attempts to set the password with the provided password and password_confirmation params. If the password is valid and the confirmation matches, it calls the do_confirm method. If the staff member has a password, it renders an error message saying that the account is already confirmed. If there are errors in the confirmation process, it renders those errors in the JSON response. The do_confirm method confirms the staff member and renders a JSON response saying the account was confirmed. The render_errors method renders a JSON response with the provided errors. The staff_member_params method is a private method that returns a strong parameters hash for the staff_member params, allowing only the password , password_confirmation , and token attributes to be passed. StaffMembers::InvitationsController The StaffMembers::InvitationsController is a controller in the Api namespace that is responsible for handling invitation-related actions for staff members. It is a subclass of ApiController, which provides it with a set of shared behaviors and methods. This controller has one action: update. This action is responsible for resending a confirmation email to a staff member. It is triggered when a request is made to the /api/admin/staff_members/:staff_id/invitation route with the PATCH HTTP verb. Before the update action is called, the find_staff_member method is called to set the @staff_member instance variable to the staff member with the ID specified in the request params. This instance variable is used in the action to determine which staff member to send the confirmation email to. The update action first calls the authorize method to ensure that the current user is authorized to invite the specified staff member. If the user is not authorized, a Pundit::NotAuthorizedError will be raised. If the @staff_member has already been confirmed, the action will render a JSON response with an error message and a 400 status code. Otherwise, it will call the resend_confirmation_instructions method on the @staff_member to send the confirmation email and render a JSON response with a success message and a 201 status code. Example usage of this controller would be a request made by an administrator to resend a confirmation email to a staff member who has not yet confirmed their account. The administrator would send a PATCH request to the /api/admin/staff_members/:staff_id/invitation route with the ID of the staff member in the URL, and the controller would handle resending the confirmation email and responding with the appropriate JSON response. StaffMembers::PasswordsController The StaffMembers::PasswordsController is an API controller that is responsible for handling password reset requests for staff members. This controller handles the following routes: POST /api/admin/staff_members/passwords: This route allows a user to request a password reset by providing their email address. If a staff member with the provided email exists, a password reset email will be sent to them. PATCH /api/admin/staff_members/passwords: This route allows a user to update their password by providing their password reset token and their new password. If a staff member with a valid reset password token is found, their password will be reset to the provided value. This controller interacts with the StaffMember model. Some possible error conditions that could be encountered in this controller include: If a user tries to request a password reset with an email that does not belong to any staff member, an error will be returned indicating that no user was found for the request. If a user tries to reset their password with an invalid token, an error will be returned indicating that the password reset token is invalid. If a user tries to reset their password with a token that has expired, an error will be returned indicating that the password reset token has expired. If a user tries to reset their password with a token that has already been used, an error will be returned indicating that the password reset token has already been used. If a user tries to reset their password with mismatching password and password confirmation values, an error will be returned indicating that the password and password confirmation do not match. Some examples of usage for this controller include: A user forgot their password and wants to reset it: The user navigates to the password reset page and enters their email address. The user clicks the \"Send password reset instructions\" button. A request is sent to the POST /api/admin/staff_members/passwords route with the user's email address in the request body. If a staff member with the provided email exists, a password reset email is sent to the user. A user wants to reset their password using the password reset link sent to their email: The user clicks the password reset link in the email they received. The user is taken to the password reset page and enters their new password. The user clicks the \"Change my password\" button. A request is sent to the PATCH /api/admin/staff_members/passwords route with the user's password reset token and their new password in the request body. If a staff member with a valid reset password token is found, their password is reset to the provided value. StaffMembers::SuspensionsController The StaffMembers::SuspensionsController is a controller in the API namespace of the application. It is meant to be used by an admin user to manage staff members within their organisation. The controller has two actions: suspend and unsuspend. These actions allow an admin to suspend or unsuspend a staff member. The controller interacts with the StaffMember model. It uses the StaffMember::Suspend and StaffMember::Unsuspend services to change the suspension status of a staff member. If either of the actions is successful, the controller will render the updated staff member object with a status code of 201. If there is an error, the staff member object will be rendered with a status code of 422. Examples of usage include sending a POST request to /api/admin/staff_members/:staff_id/suspend to suspend a staff member or a POST request to /api/admin/staff_members/:staff_id/unsuspend to unsuspend a staff member. ApiController The ApiController is a controller for the API of the administrative panel of the application. It is a base class for other controllers in the Api::Admin namespace. The controller includes the ActionController::Serialization module, which allows it to serialize objects to be sent as responses to API requests. It also sets the serialization_scope to be the view_context object, which allows serialized objects to have access to helper methods from the view. The controller has several before_action filters: authenticate: calls the authenticate method to authenticate the user based on their authentication token. set_paper_trail_whodunnit: sets the whodunnit value for the paper_trail gem, which tracks changes to models in the application. verify_authorized: verifies that authorization has been performed for all actions except the index action. verify_policy_scoped: verifies that policy scoping has been performed for the index action. The controller has several rescue_from clauses that specify how to handle certain types of exceptions: ActionController::RoutingError, AbstractController::ActionNotFound, ActiveRecord::RecordNotFound: render a 404 response with the message \"resource not found\". ActionController::ParameterMissing, ActiveModel::ForbiddenAttributesError: render a 400 response with the message \"bad request\". Pundit::NotAuthorizedError: render a 403 response with the message \"forbidden\". The controller has several methods: pundit_user: returns the current user, which is used by the pundit gem to determine the user for whom authorization is being checked. user_for_paper_trail: returns the ID of the current user, or \"Missing\" if the current user is not present. This value is used by the paper_trail gem to set the whodunnit value for tracking changes to models. render_404: renders a 404 response with the message \"resource not found\". render_403: renders a 403 response with the message \"forbidden\". render_401: renders a 401 response with the message \"Invalid credentials\". render_400: renders a 400 response with the message \"bad request\". authenticate: authenticates the user based on their authentication token. If the authentication is successful, it sets the @current_user instance variable to the authenticated user. If the authentication fails, it returns nil. authenticate_token: uses the authenticate_with_http_token method to authenticate the user based on their authentication token. If the authentication is successful, it returns the authenticated user. If the authentication fails, it returns nil. BranchesController The BranchesController is a controller for managing branches in the API for an administrator. The routes handled by this controller include index, show, create, update, and destroy for branches. The models interacted with by this controller include the BusinessUnit model and the Branch model. Error conditions that are handled by this controller include routing errors, action not found errors, record not found errors, parameter missing errors, forbidden attributes errors, and not authorized errors. Examples of usage for this controller include retrieving a list of all branches for a specific business unit, retrieving details for a specific branch, creating a new branch, updating an existing branch, and deleting an existing branch. BusinessUnitsController The BusinessUnitsController is a controller within the Api::Admin namespace that is responsible for handling requests related to business units. This controller has the following functions: index, show, create, update, and destroy. These functions correspond to the following routes: GET /api/admin/business_units: Returns a list of all business units for the current user's organization. GET /api/admin/business_units/:id: Returns the specified business unit. POST /api/admin/business_units: Creates a new business unit. PUT /api/admin/business_units/:id: Updates the specified business unit. DELETE /api/admin/business_units/:id: Deletes the specified business unit. This controller interacts with the BusinessUnit model. In the event of an error, this controller will render a JSON response with an HTTP status code of 422 (Unprocessable Entity) or 404 (Not Found). An example of usage for this controller would be a request to create a new business unit, which could be done with a POST request to the /api/admin/business_units route, with a JSON payload containing the attributes for the new business unit. PP The CategoriesController is a controller in the Api::Admin namespace. It handles the following routes: GET /api/admin/categories: retrieves a list of all categories. GET /api/admin/categories/:id: retrieves a specific category by its id. POST /api/admin/categories: creates a new category. PUT /api/admin/categories/:id: updates a specific category by its id. DELETE /api/admin/categories/:id: deletes a specific category by its id. The controller interacts with the Category model. In the case of an error, the controller returns a status code of 422 (Unprocessable Entity) for failed create and update actions, or a status code of 404 (Not Found) for failed show and delete actions. Example usage: To retrieve a list of all categories: GET /api/admin/categories To create a new category: POST /api/admin/categories with the desired category data in the request body. To update an existing category: PUT /api/admin/categories/:id with the updated category data in the request body. To delete an existing category: DELETE /api/admin/categories/:id ApiController::QuestionsController This is the QuestionsController for the API in the Admin namespace. It is a subclass of ApiController. This controller has actions for index, show, create, update, and destroy for Question models. The before_action callback find_question is called before all actions except index and create, and it sets an instance variable @question to the Question with the id specified in the request parameters. The index action sets the instance variable @questions to the collection of all Questions, and renders a JSON response of this collection if the collection is stale. The show action authorizes the @question instance variable and renders a JSON response of it if it is stale. The create action creates a new Question from the question_params in the request and authorizes it. If the Create operation is successful, it renders a JSON response of the new Question with a status of 201. If the operation is not successful, it renders a JSON response of the Question with a status of 422. The update action authorizes the @question instance variable and, if the Update operation is successful, renders a JSON response of it with a status of 200. If the operation is not successful, it renders a JSON response of the Question with a status of 422. The destroy action authorizes the @question instance variable and, if the Destroy operation is successful, renders an empty response with a status of 204. If the operation is not successful, it renders an empty RolesController RolesController is an API controller in the \"Api::Admin\" namespace. It has actions for index, show, create, update, and destroy. It sets the role instance variable before the show, update, and destroy actions using the set_role method. It also finds a new role to replace the one being destroyed using the find_new_role method before the destroy action. It uses the policy_scope method to set the @roles and @new_role instance variables to the appropriate records from the Role model. It authorizes the current user for each action using the authorize method. It calls the Role::Create, Role::Update, and Role::Destroy services for the corresponding actions. It renders a JSON response for each action, with a status code of 201 for create, 200 for update, 204 for destroy, 422 for unsuccessful actions, and 200 for index and show. The create and update actions require strong parameters, which are specified in the role_params method. The destroy action assigns the new role to all staff members who currently have the role being destroyed, using the assign_new_role method. ApiController StaffMembersController is a subclass of ApiController which provides authentication and authorization for the actions within the controller. This controller has actions for index, show, create, update, and destroy for staff members. The index action retrieves a list of all staff members in the system, authorizes the action, and then renders a JSON response of the staff members if the response is not stale. The show action retrieves a specific staff member, authorizes the action, and then renders a JSON response of the staff member if the response is not stale. The create action creates a new staff member with the provided parameters and then renders a JSON response of the staff member with a status of 201 if the creation was successful, or a status of 422 if the creation failed. The update action updates a specific staff member with the provided parameters and then renders a JSON response of the updated staff member with a status of 200 if the update was successful, or a status of 422 if the update failed. The destroy action destroys a specific staff member and then returns a status of 204 if the destroy action was successful, or a status of 422 if the destroy action failed. The controller also has private methods for finding a specific staff member and for allowing certain parameters to be passed based on the current user. The models interacted with in this controller include StaffMember, Role, and BusinessUnit. Error conditions that may be encountered include the staff member not being found, invalid parameters being passed, and the current user not being authorized to perform the action. Partners::V1::Management::AuthenticationController The AuthenticationController is a controller for managing authentication for partners in the V1 API. It handles the following routes: POST /api/partners/v1/management/authentication: creates a new session for a staff member. It interacts with the following models: StaffMember: authenticates the staff member with the given email and password. AuthenticationToken: creates and returns a new authentication token for the authenticated staff member. Error conditions: If the staff member cannot be authenticated, it will render an error with a status of 401. Examples of usage: A partner makes a POST request to /api/partners/v1/management/authentication with the appropriate email and password in the request body. If the staff member is successfully authenticated, it will return a JSON object containing the authentication token and an analytics token. Partners::V1::Management::PasswordResetController The PasswordResetController is a controller in the Api::Partners::V1::Management namespace. It inherits from Api::Partners::V1::BaseController. It skips the authenticate and find_branch filters for the create and update actions, respectively. The create action sends a password reset email to the user with the specified email address if the user is found. The update action resets the password for the user with the specified reset token and updates the user's password if the token is valid. The reset_params method combines the reset_password_token and other user parameters passed in the request. The unlockable? method checks if the user has the unlock_access! and unlock_strategy_enabled? methods and if the email unlock strategy is enabled for the user. The user_params method permits the email, password, password_confirmation, and token parameters. Partners::V1::Staff::AuthenticationController The AuthenticationController is a controller within the Api::Partners::V1::Staff namespace. The controller is responsible for handling the creation of authentication tokens for staff members. The create action is responsible for authenticating a staff member based on their employee ID and pin. If the authentication is successful, a login session is established for the staff member and an authentication token is returned in the response. The create action skips the authenticate before action, which means that it does not require an authentication token to be passed in the request headers. However, it does run the authenticate_manager before action, which means that only staff members with the role of manager are able to use this action. The render_error method is responsible for rendering errors in the response if the authentication fails. It uses the ActiveModel::Serializer::ErrorSerializer to serialize the errors. The user_params method is a private method that permits the email and password parameters to be passed in the request. It is not used in the create action. Partners::V1::BaseController The BaseController is an abstract class that serves as the base for the other controllers in the Api::Partners::V1 namespace. It includes various before and rescue actions to handle common tasks and errors across controllers. Functions and routes handled: The BaseController does not handle any specific functions or routes. Instead, it provides a set of common actions that are run before or after the actions of other controllers in its namespace. Models interacted with: The BaseController does not interact with any specific models. Error conditions and examples of usage: The BaseController has a number of rescue actions that handle common errors such as routing errors, action not found errors, and record not found errors. These rescue actions render a JSON response with the appropriate status code. An example of usage for the BaseController would be as the base class for other controllers in the Api::Partners::V1 namespace. The actions provided by the BaseController would then be run before or after the actions of the derived controllers. Partners::V1::GraphqlController The GraphqlController is a controller within the Api::Partners::V1 namespace. It is responsible for handling GraphQL requests. This controller has a single action, execute, which is responsible for handling GraphQL queries and mutations. The execute action first processes the request parameters, extracting the variables, query, and operationName from the request. It then constructs a context hash containing information about the current request, such as the token_context, current_branch, current_branch_id, current_organisation, current_user, and current_role. The execute action then passes the extracted query, variables, context, and operation_name to the execute method of the VistaPlatformSchema class. This class is a GraphQL schema which defines the GraphQL types and resolvers for the application. The result of the execute method is then rendered as a JSON response to the client. The ensure_hash private method is used to convert the variables parameter to a hash. If the variables parameter is a JSON string, it is parsed into a hash. If the variables parameter is already a hash, it is returned as is. If the variables parameter is nil, an empty hash is returned. The permitted_params private method is used to allow all request parameters. It is currently commented out as it does not work properly with a nested variables Partners::V1::RadarController The RadarController is a controller within the Api::Partners::V1 module in a Ruby on Rails application. This controller has a single action, index, which is used to search for users within a specified radius of a given latitude and longitude using the Radar.io API. The index action uses the RestClient gem to make a GET request to the Radar.io API, passing in the necessary authorization, parameters (near, radius, limit), and a block specifying the request headers. The index action then renders the response from the API as JSON. The index action is accessed via the /api/partners/v1/radar route. This controller does not interact with any models. An error condition that could occur in this controller is if the Radar.io API returns an error status code. An example of usage for this controller would be to make a GET request to the /api/partners/v1/radar route with the necessary query parameters (lat, lon, radius). Partners::V1::RolesController RolesController is a controller in the Api::Partners::V1 module. The RolesController handles the index route, which allows users to view a list of roles. The RolesController interacts with the Role model. There are no error conditions specified in the controller. An example of usage for this controller would be a request to api/partners/v1/roles to view a list of roles. V1::Branches::CategoriesController The CategoriesController is a controller in the Api::V1::Branches namespace, under the V1 version of the API. This controller has a single action, index, which retrieves a paginated list of PartnerCategory objects and includes their associated photo records. The index action renders the list of categories as a JSON response. This controller does not interact with any models directly. It uses the PartnerCategory model to retrieve the categories. There are no error conditions explicitly defined in this controller. An example of usage for this controller could be a client making a GET request to the /api/v1/branches/categories route to retrieve a list of partner categories. V1::Branches::CheckInController The CheckInController is a controller in the Api::V1::Branches namespace that is responsible for managing check-ins for a specific branch. Functions and routes handled: This controller has a single action - create - which is responsible for creating a new check-in for a user. The create action is accessed via the POST /api/v1/branches/:id/check_in route. Models interacted with: This controller interacts with the CheckIn and Branch models. Error conditions: If the create action is unsuccessful in creating a new check-in (for example, if the provided check-in parameters are invalid), it will render a JSON response with an HTTP status of 422 (Unprocessable Entity). Examples of usage: A client app can send a POST request to the /api/v1/branches/:id/check_in route with a JSON body containing the check-in parameters to create a new check-in for the user. The response will contain the newly created check-in object if successful, or an error object if unsuccessful. V1::Branches::InteractionsController The InteractionsController is a controller for handling interactions within a specific branch. Functions and routes handled: This controller handles the following routes: Index: returns a paginated list of interactions for the current user within a specific branch. Models interacted with: Interaction: represents a user's interaction with a specific branch. Branch: represents a physical location where a user can check in. Error conditions: If the current user is not authenticated, the controller will return a 401 Unauthorized error. If the specified branch is not found, the controller will return a 404 Not Found error. Examples of usage: To retrieve a paginated list of interactions for the current user within a specific branch: GET /api/v1/branches/:id/interactions?page=1&limit=10 V1::Branches::ShareController The ShareController is a controller in the Api::V1::Branches namespace. The controller has three actions: create, destroy, and revoke_all. The create action calls the Authorise command of the Share module, passing in the current branch, current user, and the string 'user' as arguments. If the command is successful, it returns a HTTP status code of 204. Otherwise, it returns a status code of 422. The destroy action calls the Revoke command of the Share module, passing in the current branch and current user as arguments. If the command is successful, it returns a HTTP status code of 204. Otherwise, it returns a status code of 422. If an error occurs, it returns a status code of 422. The revoke_all action calls the RevokeAll command of the Share module, passing in the current user as an argument. If the command is successful, it returns a HTTP status code of 204. Otherwise, it returns a status code of 422. The branch method is a private method that returns the current branch by finding it using the id parameter passed in through the params hash. V1::Categories::IgnoreController The IgnoreController is an API controller that allows users to ignore or unignore categories. Functions and routes handled: The controller has two actions, create and destroy, which handle the routes POST /api/v1/categories/:id/ignore and DELETE /api/v1/categories/:id/ignore, respectively. The create action allows a user to ignore a category, and the destroy action allows a user to unignore a category. Models interacted with: The controller interacts with the Category and Ignore models. Error conditions: If a category cannot be found or if there is an issue saving or destroying an ignore record, a HTTP status code of 422 (Unprocessable Entity) will be returned. Examples of usage: To ignore a category with id 1, a user could send a POST request to /api/v1/categories/1/ignore. To unignore a category with id 1, a user could send a DELETE request to /api/v1/categories/1/ignore. V1::Questions::AnswerController The AnswerController is an API controller that belongs to the V1 version of the API under the Questions module. It is responsible for handling actions related to answers to questions. The AnswerController allows users to create and destroy answers to questions. It is also responsible for updating an answer if it already exists. The AnswerController interacts with the Answer model and the Question model. If an answer fails to save, the controller will render a status of 422 (unprocessable entity). If an answer is successfully destroyed, the controller will return a status of 204 (no content). An example of usage for this controller is when a user wants to answer a question or remove their answer to a question. The user could send a POST request to /api/v1/questions/:id/answer with the necessary parameters to create an answer, or send a DELETE request to /api/v1/questions/:id/answer to delete the answer. V1::Sync::CheckController The CheckController provides a check for synchronization between the client and the server. Functions and routes handled: The index action handles the route GET /sync/check and returns the latest updated timestamps for categories, questions, and the current user. Models interacted with: The Category, Question, and User models are queried to retrieve their latest updated timestamps. Error conditions: There are no known error conditions for this controller. Examples of usage: A client application might send a GET request to /sync/check to determine if it needs to synchronize its local data with the server. The response from this controller can be used to determine which records need to be fetched from the server to update the client's local data. V1::Users::AuthenticationController The Api::V1::Users::AuthenticationController is a controller within the V1 version of the API for interacting with user authentication. This controller's primary function is to handle user login requests by authenticating the provided email and password. If the authentication is successful, the controller returns a member ID, analytics token, and authentication token to the client. If the authentication is unsuccessful, an error is returned to the client. This controller does not interact with any models directly, but rather uses the User::Authenticate command to handle the authentication process. Error conditions that this controller handles include: Invalid email or password provided User is archived An example of usage for this controller could be a client app making a POST request to the /api/v1/users/authentication route with the required email and password parameters in the request body. The server would then respond with a JSON object containing the member ID, analytics token, and authentication token if the authentication is successful, or an error if it is unsuccessful. V1::Users::RegistrationController Api::V1::Users::RegistrationController is a controller within the Api::V1::Users module. It handles user registration. The controller includes a create action that creates a new user based on the user_params passed in the request. It does this by calling the User::Register service, passing in user_params. If the service is successful, the controller returns a JSON response with the token and needsOnboarding fields. If the service is unsuccessful, the controller returns a JSON error response. The controller interacts with the User model to create a new user and generate an authentication token for the user. The create action is skipped for the authenticate before action, so it does not require authentication to access. An example of usage would be a client sending a POST request to the /api/v1/users/registration route with email and password fields in the request body to create a new user. V1::BaseController The Api::V1::BaseController is a base controller for the API version 1 of the application. It includes ActionController::Serialization and sets serialization_scope to the view_context. It has a before_action to authenticate the user and set the current_user instance variable. It has rescue_from clauses to handle routing errors, missing actions, record not found errors, parameter missing errors, forbidden attribute errors, and authorization errors. It has a protected method render_404 to render a 'Resource not found' message with a 404 status. It has a protected method render_403 to render a 'Forbidden' message with a 403 status. It has a protected method render_401 to render an 'Invalid credentials' message with a 401 status. It has a protected method render_400 to render a 'Bad request' message with a 400 status. It has a protected method authenticate to authenticate the user by calling authenticate_token. If authenticate_token fails, it calls render_401. It has a protected method authenticate_token to authenticate the user by checking the HTTP token and setting the current_user instance variable. It has a protected method set_raven_context to set the context for the error logging tool Raven. It has a protected method pundit_user which returns the current_user. It has a protected method user_for_paper_trail which returns the id of the current_user or 'Missing' if the current_user is not set. V1::BranchesController The BranchesController is a controller in the Api::V1 namespace. It is a subclass of Api::V1::BaseController. It uses the has_scope method provided by the HasScope module to define several scopes that can be used to filter the branches returned by the controller. These scopes include in_category, in_city, ordered_by_distance, vista_partners, and search. The index action retrieves a list of branches based on the provided scopes and includes the :address, :shares, :categories, :photo, and :business_unit associations in the query. It then paginates the results using the page method provided by the kaminari gem. The show action retrieves a single branch based on the provided id parameter. The branch_scope private method returns either all branches or only the branches authorized for the current user, based on the value of the authorised parameter. V1::CategoriesController The CategoriesController is a controller in the Api::V1 namespace that handles HTTP requests related to categories. The index action handles requests for a list of categories. It uses the has_scope method to apply scoping parameters to the Category model, and then returns a paginated list of categories to the client. The show action handles requests for a specific category. It uses the find_category private method to find the requested category and authorize the request using the authorize method from the Pundit gem. If the request is authorized, the action returns the requested category to the client. The find_category private method finds the requested category using the Category model and the id parameter passed in the request. The in_category scope is applied to the Category model when the category parameter is present in the request. The stale? method is used to determine if the requested data is stale (i.e., if it has been modified since the client last requested it). If the data is stale, the action sends the data to the client. If the data is not stale, a 304 Not Modified response is returned to the client. V1::CitiesController The CitiesController is a class that belongs to the Api::V1 namespace and is a subclass of the Api::V1::BaseController class. Functions and routes handled: The controller has an \"index\" action that is used to handle the \"GET /cities\" route. This action retrieves a paginated list of cities from the database and renders them as a JSON response. Models interacted with: The CitiesController interacts with the City model to retrieve a list of cities from the database. Error conditions: If the cities list is stale, a new list is retrieved from the database and rendered as a JSON response. If the cities list cannot be retrieved from the database, an error message is rendered as a JSON response. Examples of usage: A client can make a GET request to the \"/cities\" route to retrieve a list of cities from the server. The server will then respond with a JSON object containing the list of cities. V1::ContentCategoriesController The ContentCategoriesController is a controller in the V1 API that is responsible for handling actions related to ContentCategory models. Functions and routes handled: This controller only has one function, the index action, which is responsible for returning a list of all ContentCategory models. This action can be accessed via the /api/v1/content_categories route. Models interacted with: The ContentCategoriesController interacts with the ContentCategory model to retrieve a list of all content categories. Error conditions: There are no specific error conditions specified in this controller. Examples of usage: An example of usage for this controller would be to make a GET request to the /api/v1/content_categories route, which would return a list of all ContentCategory models in the API's response. V1::DevicesController The DevicesController is responsible for handling device registration for the current user. Functions and routes handled: The create action handles the creation or updating of a device for the current user. The route for this action is a POST request to '/api/v1/devices'. Models interacted with: The Device model is interacted with to find or initialize a new device for the current user, and to update the device with the provided parameters. Error conditions: If the device fails to be created or updated, a 422 Unprocessable Entity response is returned. Examples of usage: A client app may send a POST request to '/api/v1/devices' with a JSON body containing the token and platform of the device being registered. The controller will create or update the device for the current user and return a 204 No Content response on success. V1::FeedController The Api::V1::FeedController is a subclass of Api::V1::BaseController and is responsible for handling requests related to the feed of content for a user. The index action allows a user to retrieve a feed of articles, interactions, category updates, and videos that have been published and are relevant to the user. It uses the has_scope method to allow for filtering the results based on the updated_since parameter. The controller interacts with the Article, Interaction, CategoryUpdate, and Video models to retrieve the relevant content for the feed. If the updated_since parameter is not a valid datetime, the scope is returned as is. If the feed can be retrieved successfully, a Feed object is created with the retrieved content and rendered as JSON in the response. Example usage: A GET request is made to /api/v1/feed?updated_since=2022-01-01T00:00:00Z to retrieve the feed for a user with content that was updated since January 1st, 2022. V1::MeController The MeController is a controller in the Api::V1 namespace that handles actions related to the currently authenticated user. The show action responds with the current user's data if the data is not stale. The update action updates the current user's data with the provided params and responds with the updated data if the update was successful, or with a status of 422 if the update was unsuccessful. The user_params method returns a subset of the permitted attributes of the user param. The permitted_attributes method returns an array of permitted attributes for the user model. The transform_params_if_multipart! method modifies the params hash by transforming the keys to be underscore-separated if the request's content type is multipart/form-data. It also applies this transformation recursively to any nested hash or array values. This controller has a before action that calls transform_params_if_multipart!, which modifies the params before they are used in the update action. V1::MemberRequestsController The MemberRequestsController is for the API of the V1 version of the application and is a subclass of Api::V1::BaseController. The controller handles the following routes: Index: returns a paginated list of member requests made by the current user for a specific branch (specified by branch_id in the params). Includes member_request_type information. The list is ordered by updated_at in descending order and is scoped to the current user. Show: returns a specific member request made by the current user, specified by the id in the params. Create: creates a new member request made by the current user with the member_request_type_id and branch_id specified in the params, and any messages attached to the request. Mark as read: marks all unread messages sent by staff members in the member request as read. Send message: creates and attaches a new message to the member request, with the current user as the messageable and the body specified in the params. Request details: returns the member request made by the current user that has a specific message id specified in the params. The controller interacts with the MemberRequest, MemberRequestType, and MemberRequestMessage models. In the index, show, and request_details actions, if the requested resource is not found or is stale, a 404 or 422 error is returned respectively. In the create and send message actions, if the resource is not successfully saved, a 422 error is returned. Example usage: making a GET request to /api/v1/member_requests with the branch_id parameter specified in the query string would return a paginated V1::MoodController The MoodController is a controller within the Api::V1 namespace and is a subclass of Api::V1::BaseController. The MoodController has a single action, create, which is used to create a new mood record for the current user. The create action creates a new Mood record using the mood_params method to whitelist and retrieve the necessary parameters. If the Mood record is successfully saved, the action renders the @mood object in JSON format. If the save is unsuccessful, the action renders the @mood object in JSON format with a status of 422 (Unprocessable Entity). The mood_params method is a private method that uses the params.require(:mood).permit(:value) syntax to whitelist and retrieve the :value parameter from the incoming request. V1::NotificationsController The NotificationsController is a controller within the Api::V1 module. It is a subclass of Api::V1::BaseController. The controller has two actions: index and update. The index action retrieves a paginated list of notifications for the current user, and the update action updates a single notification belonging to the current user. The index action uses the Notification model to retrieve notifications for the current user and includes the object association in the query. It then renders the notifications as a JSON response. The update action uses the Notification model to find a notification belonging to the current user using the params[:id] value. It then updates the notification with the notification_params and renders a JSON response with a status of 204 if the update was successful, or a status of 422 if it was not. The notification_params method is a private method that whitelists the response attribute of the notification parameter. The mark_all_read method is an after_action callback that marks all unread notifications in the @notifications instance variable as read. This method is only called for the index action. Example usage of the NotificationsController: A GET request to /api/v1/notifications would retrieve a paginated list of notifications for the current user and render them as a JSON response. A PUT request to /api/v1/notifications/5 with a JSON body of { \"notification\": { \"response\": \"accepted\" } } would update the notification with ID 5 belonging to the current user and set the response attribute to \"accepted\", and render a JSON response with a status of 204. V1::PasswordResetsController The PasswordResetsController is a controller in the Api::V1 namespace. It is a subclass of Api::V1::BaseController and has skip_before_action :authenticate defined, meaning that it does not run the authenticate method before its actions. The create action allows a user to request a password reset by providing their email address. If a user with the provided email is found, they will receive an email with password reset instructions. If no user is found, an error message is returned to the client. The update action allows a user to reset their password by providing their email, a new password, and a reset token that was sent to them in the password reset email. If the provided token is valid and the user's password is successfully reset, the user's account is also unlocked if the unlockable? method returns true. If the reset fails, an error message is returned to the client. The user_params method allows strong parameters for the email, password, password_confirmation, and token parameters. The reset_params method combines the user params with the reset_password_token key set to the value of the token parameter. The unlockable? method returns true if the @user object has the unlock_access! and unlock_strategy_enabled? methods defined and if the unlock_strategy_enabled? method returns true when passed the :email symbol. This allows the controller to determine if the user's account should be unlocked after a password reset. V1::ProfilesController The ProfilesController is a controller in the Api::V1 namespace. The controller has three actions: share, revoke, and revoke_all. The share action creates a new Share object and associates it with a branch and the current_user. It then calls the Profile::Share service to perform the share action. If the service is successful, it returns a status of 200, otherwise it returns a status of 422. The revoke action finds a Share object using the params[:share_id] and then calls the Profile::Revoke service to perform the revoke action. If the service is successful, it returns a status of 200, otherwise it returns a status of 422. The revoke_all action finds a member (presumably a User object) and then calls the Profile::RevokeAll service to perform the revoke all action. If the service is successful, it returns a status of 200, otherwise it returns a status of 422. The controller has private methods for finding or initializing the new_share, share, and branch objects based on the request parameters. The share and revoke actions have an authorize call to authorize the action for the appropriate object. V1::QrController The QrController is a controller in the Api::V1 namespace of the application. This controller has a single action, index, which generates a QR code image and returns it as a base64 encoded string in the response. The QR code contains the text \"Vista ID\" followed by the current user's member ID. The QR code is generated using the RQRCode gem and the ChunkyPNG gem. The index action does not interact with any models. An error condition could occur if there is an issue with the RQRCode or ChunkyPNG gem while generating the QR code image. An example of usage for this controller might be to make a GET request to /api/v1/qr to retrieve the base64 encoded QR code image for the current user's member ID. V1::QuestionsController The QuestionsController is a part of the V1 API and is a subclass of Api::V1::BaseController. The controller has two actions: index and show. The index action is used to retrieve a list of questions, and the show action is used to retrieve a specific question. The index action uses the has_scope method to apply a scope called intro to the list of questions. It also includes the answers and photos of the questions in the list. The list of questions is then rendered as JSON. The show action first finds the specific question using the find_question private method and the params[:id] parameter. It then authorizes the question using the authorize method, and finally renders the question as JSON if it is stale. The private find_question method is used to find a specific question using the params[:id] parameter. V1::ReleasesController The ReleasesController is a controller in the Api::V1 namespace. The check action is responsible for retrieving the latest release timestamp from the database and rendering it as a JSON response. The latest action retrieves the latest release from the database and renders the file contents as a JSON response. If no release is found, it returns an empty JSON object. The ReleasesController does not interact with any models. An error condition that could occur in the check action is if there is a problem connecting to the database or if there is a problem executing the query to retrieve the latest release timestamp. In the latest action, an error condition could occur if there is a problem connecting to the database or if there is a problem executing the query to retrieve the latest release. Example usage of the check action: A client sends a GET request to /api/v1/releases/check and the server responds with a JSON object containing the latest release timestamp. Example usage of the latest action: A client sends a GET request to /api/v1/releases/latest and the server responds with a JSON object containing the contents of the latest release file. V1::StatusController The StatusController is an API controller that handles requests related to the status of the service. Functions and routes handled: This controller has a single function called ping, which is associated with the /status/ping route. This function simply responds with a message indicating that the service is available and a 200 status code. Models interacted with: This controller does not interact with any models. Error conditions: There are no error conditions specified in this controller. Examples of usage: An example usage of this controller would be to send a GET request to the /status/ping route, which would return a message indicating that the service is available. This could be used to verify that the service is running and responsive. V1::SyncController The SyncController is a controller in the Api::V1 namespace and inherits from the Api::V1::BaseController. The controller has two actions: index and create. The index action returns a JSON object with a list of question ids and updated timestamps for all of the current user's answers. The create action processes a request to synchronize the current user's answers with the server. The request can include new answers to add, existing answers to update, and existing answers to delete. The action performs these operations within a transaction to ensure that the synchronization is atomic. After the synchronization is completed, the action returns a JSON object with the updated answers for the specified questions. The controller does not interact with any models directly. Instead, it uses the has-many association between the User model and the UserAnswer model to access the current user's answers. There are no error conditions explicitly handled in this controller. If an error occurs during the synchronization process, such as a validation error when creating a new answer, it will raise an exception and the transaction will be rolled back. Example usage: An HTTP GET request to /api/v1/sync will return a JSON object with a list of the current user's answers. An HTTP POST request to /api/v1/sync with a JSON body containing add, update, and delete arrays will synchronize the current user's answers with the server. The add array should contain objects representing new answers to create, the update array should contain objects representing existing answers to update, and the delete array should contain question ids for existing answers to delete. V1::UserAnswersController The UserAnswersController is part of the Api::V1 namespace and is a subclass of Api::V1::BaseController. This controller has four actions: index, show, create, and update. The before_action callback find_answer is run before all actions except for index and create. The index action retrieves all the answers for the current user and renders them as JSON. The show action renders a single answer as JSON. The create action creates a new answer with the provided parameters, wrapped in a transaction using the UserAnswer::Create service object. If the service is successful, the answer is rendered as JSON with a 201 status code. If it fails, the answer is rendered as JSON with a 422 status code. The update action updates an existing answer with the provided parameters, wrapped in a transaction using the UserAnswer::Update service object. If the service is successful, the answer is rendered as JSON with a 200 status code. If it fails, the answer is rendered as JSON with a 422 status code. The destroy action destroys an existing answer, wrapped in a transaction using the UserAnswer::Destroy service object. If the service is successful, a 204 status code is returned. If it fails, a 422 status code is returned. The answer_params method is a private method that permits the question_id, note, and values parameters for use in the create and update actions. The find_answer method is a private method that retrieves the answer with the question_id parameter specified in the request. It is used in the show, update, and destroy actions.","title":"API"},{"location":"controller/api/#branchesprofilescontroller","text":"The ProfilesController is a controller within the Branches module, which provides an API for creating and managing profiles for branches within a business unit. Functions and routes handled: request: Handles a request to create a new profile for a given branch. Routes: POST /api/admin/units/:unit_id/branches/:branch_id/profiles/request: create a new profile request for a given branch. Models interacted with: ProfileRequest: a model representing a request for a new profile for a branch. BusinessUnit: a model representing a business unit. Branch: a model representing a branch within a business unit. Error conditions: If the user is not authorized to create a new profile request, a 401 Unauthorized error is returned. If the request to create a new profile fails, a 422 Unprocessable Entity error is returned. Examples of usage: A client could send a POST request to /api/admin/units/123/branches/456/profiles/request with an authenticated request to create a new profile request for the branch with ID 456 within the business unit with ID 123.","title":"Branches::ProfilesController"},{"location":"controller/api/#branchesstaffcontroller","text":"The Branches::StaffController is a controller within the admin panel of the application, and is responsible for managing staff members at a specific branch within a business unit. This controller handles the following routes: GET /api/admin/units/:unit_id/branches/:branch_id/staff: This route returns a list of staff members at the specified branch. POST /api/admin/units/:unit_id/branches/:branch_id/staff: This route assigns a staff member to the specified branch. DELETE /api/admin/units/:unit_id/branches/:branch_id/staff: This route removes a staff member from the specified branch. This controller interacts with the following models: StaffMember BusinessUnit Error conditions: If the specified staff member or business unit cannot be found, this controller will return a 404 status code. If the request to create or destroy a staff assignment fails, this controller will return a 422 status code. Examples of usage: A request to GET /api/admin/units/1/branches/2/staff will retrieve a list of staff members at branch 2 within business unit 1. A request to POST /api/admin/units/1/branches/2/staff with a staff member ID in the request body will assign the staff member to branch 2 within business unit 1. A request to DELETE /api/admin/units/1/branches/2/staff with a staff member ID in the request body will remove the staff member from branch 2 within business unit 1.","title":"Branches::StaffController"},{"location":"controller/api/#staffmembersauthenticationcontroller","text":"Description: The AuthenticationController is responsible for handling staff member authentication requests. It is a part of the StaffMembers namespace, and is subclassed from ApiController. Functions and routes handled: The controller has a single action, create, which is used to handle staff member login requests. The create action is routed at /api/admin/staff_members/authentication. Models interacted with: The controller interacts with the StaffMember model. Error conditions: If the StaffMember::Authenticate command is not successful, an error message is returned to the client. If the staff member's account has been suspended, an unauthorized error message is returned. Examples of usage: A client can send a POST request to /api/admin/staff_members/authentication with email and password params to attempt to log in a staff member. If the login is successful, the client will receive a JSON response with an authentication token, the staff member's organisation name, and the staff member's user type. If the login is unsuccessful, an error message will be returned to the client.","title":"StaffMembersAuthenticationController"},{"location":"controller/api/#staffmembersconfirmationscontroller","text":"This is a controller for the API of the admin panel of a system that manages staff members. It is in the StaffMembers namespace and is called ConfirmationsController. It is a subclass of ApiController and therefore inherits behavior from it. It has a before_action hook that skips the authorization step for all actions in this controller. It has a single action, update, which is used to confirm a staff member's account. It first uses the with_unconfirmed_confirmable method to find the staff member to be confirmed, using the confirmation_token field in the staff_member params. If the staff member is found and is unconfirmed, it proceeds with the confirmation process. If the staff member has no password, it attempts to set the password with the provided password and password_confirmation params. If the password is valid and the confirmation matches, it calls the do_confirm method. If the staff member has a password, it renders an error message saying that the account is already confirmed. If there are errors in the confirmation process, it renders those errors in the JSON response. The do_confirm method confirms the staff member and renders a JSON response saying the account was confirmed. The render_errors method renders a JSON response with the provided errors. The staff_member_params method is a private method that returns a strong parameters hash for the staff_member params, allowing only the password , password_confirmation , and token attributes to be passed.","title":"StaffMembers::ConfirmationsController"},{"location":"controller/api/#staffmembersinvitationscontroller","text":"The StaffMembers::InvitationsController is a controller in the Api namespace that is responsible for handling invitation-related actions for staff members. It is a subclass of ApiController, which provides it with a set of shared behaviors and methods. This controller has one action: update. This action is responsible for resending a confirmation email to a staff member. It is triggered when a request is made to the /api/admin/staff_members/:staff_id/invitation route with the PATCH HTTP verb. Before the update action is called, the find_staff_member method is called to set the @staff_member instance variable to the staff member with the ID specified in the request params. This instance variable is used in the action to determine which staff member to send the confirmation email to. The update action first calls the authorize method to ensure that the current user is authorized to invite the specified staff member. If the user is not authorized, a Pundit::NotAuthorizedError will be raised. If the @staff_member has already been confirmed, the action will render a JSON response with an error message and a 400 status code. Otherwise, it will call the resend_confirmation_instructions method on the @staff_member to send the confirmation email and render a JSON response with a success message and a 201 status code. Example usage of this controller would be a request made by an administrator to resend a confirmation email to a staff member who has not yet confirmed their account. The administrator would send a PATCH request to the /api/admin/staff_members/:staff_id/invitation route with the ID of the staff member in the URL, and the controller would handle resending the confirmation email and responding with the appropriate JSON response.","title":"StaffMembers::InvitationsController"},{"location":"controller/api/#staffmemberspasswordscontroller","text":"The StaffMembers::PasswordsController is an API controller that is responsible for handling password reset requests for staff members. This controller handles the following routes: POST /api/admin/staff_members/passwords: This route allows a user to request a password reset by providing their email address. If a staff member with the provided email exists, a password reset email will be sent to them. PATCH /api/admin/staff_members/passwords: This route allows a user to update their password by providing their password reset token and their new password. If a staff member with a valid reset password token is found, their password will be reset to the provided value. This controller interacts with the StaffMember model. Some possible error conditions that could be encountered in this controller include: If a user tries to request a password reset with an email that does not belong to any staff member, an error will be returned indicating that no user was found for the request. If a user tries to reset their password with an invalid token, an error will be returned indicating that the password reset token is invalid. If a user tries to reset their password with a token that has expired, an error will be returned indicating that the password reset token has expired. If a user tries to reset their password with a token that has already been used, an error will be returned indicating that the password reset token has already been used. If a user tries to reset their password with mismatching password and password confirmation values, an error will be returned indicating that the password and password confirmation do not match. Some examples of usage for this controller include: A user forgot their password and wants to reset it: The user navigates to the password reset page and enters their email address. The user clicks the \"Send password reset instructions\" button. A request is sent to the POST /api/admin/staff_members/passwords route with the user's email address in the request body. If a staff member with the provided email exists, a password reset email is sent to the user. A user wants to reset their password using the password reset link sent to their email: The user clicks the password reset link in the email they received. The user is taken to the password reset page and enters their new password. The user clicks the \"Change my password\" button. A request is sent to the PATCH /api/admin/staff_members/passwords route with the user's password reset token and their new password in the request body. If a staff member with a valid reset password token is found, their password is reset to the provided value.","title":"StaffMembers::PasswordsController"},{"location":"controller/api/#staffmemberssuspensionscontroller","text":"The StaffMembers::SuspensionsController is a controller in the API namespace of the application. It is meant to be used by an admin user to manage staff members within their organisation. The controller has two actions: suspend and unsuspend. These actions allow an admin to suspend or unsuspend a staff member. The controller interacts with the StaffMember model. It uses the StaffMember::Suspend and StaffMember::Unsuspend services to change the suspension status of a staff member. If either of the actions is successful, the controller will render the updated staff member object with a status code of 201. If there is an error, the staff member object will be rendered with a status code of 422. Examples of usage include sending a POST request to /api/admin/staff_members/:staff_id/suspend to suspend a staff member or a POST request to /api/admin/staff_members/:staff_id/unsuspend to unsuspend a staff member.","title":"StaffMembers::SuspensionsController"},{"location":"controller/api/#apicontroller","text":"The ApiController is a controller for the API of the administrative panel of the application. It is a base class for other controllers in the Api::Admin namespace. The controller includes the ActionController::Serialization module, which allows it to serialize objects to be sent as responses to API requests. It also sets the serialization_scope to be the view_context object, which allows serialized objects to have access to helper methods from the view. The controller has several before_action filters: authenticate: calls the authenticate method to authenticate the user based on their authentication token. set_paper_trail_whodunnit: sets the whodunnit value for the paper_trail gem, which tracks changes to models in the application. verify_authorized: verifies that authorization has been performed for all actions except the index action. verify_policy_scoped: verifies that policy scoping has been performed for the index action. The controller has several rescue_from clauses that specify how to handle certain types of exceptions: ActionController::RoutingError, AbstractController::ActionNotFound, ActiveRecord::RecordNotFound: render a 404 response with the message \"resource not found\". ActionController::ParameterMissing, ActiveModel::ForbiddenAttributesError: render a 400 response with the message \"bad request\". Pundit::NotAuthorizedError: render a 403 response with the message \"forbidden\". The controller has several methods: pundit_user: returns the current user, which is used by the pundit gem to determine the user for whom authorization is being checked. user_for_paper_trail: returns the ID of the current user, or \"Missing\" if the current user is not present. This value is used by the paper_trail gem to set the whodunnit value for tracking changes to models. render_404: renders a 404 response with the message \"resource not found\". render_403: renders a 403 response with the message \"forbidden\". render_401: renders a 401 response with the message \"Invalid credentials\". render_400: renders a 400 response with the message \"bad request\". authenticate: authenticates the user based on their authentication token. If the authentication is successful, it sets the @current_user instance variable to the authenticated user. If the authentication fails, it returns nil. authenticate_token: uses the authenticate_with_http_token method to authenticate the user based on their authentication token. If the authentication is successful, it returns the authenticated user. If the authentication fails, it returns nil.","title":"ApiController"},{"location":"controller/api/#branchescontroller","text":"The BranchesController is a controller for managing branches in the API for an administrator. The routes handled by this controller include index, show, create, update, and destroy for branches. The models interacted with by this controller include the BusinessUnit model and the Branch model. Error conditions that are handled by this controller include routing errors, action not found errors, record not found errors, parameter missing errors, forbidden attributes errors, and not authorized errors. Examples of usage for this controller include retrieving a list of all branches for a specific business unit, retrieving details for a specific branch, creating a new branch, updating an existing branch, and deleting an existing branch.","title":"BranchesController"},{"location":"controller/api/#businessunitscontroller","text":"The BusinessUnitsController is a controller within the Api::Admin namespace that is responsible for handling requests related to business units. This controller has the following functions: index, show, create, update, and destroy. These functions correspond to the following routes: GET /api/admin/business_units: Returns a list of all business units for the current user's organization. GET /api/admin/business_units/:id: Returns the specified business unit. POST /api/admin/business_units: Creates a new business unit. PUT /api/admin/business_units/:id: Updates the specified business unit. DELETE /api/admin/business_units/:id: Deletes the specified business unit. This controller interacts with the BusinessUnit model. In the event of an error, this controller will render a JSON response with an HTTP status code of 422 (Unprocessable Entity) or 404 (Not Found). An example of usage for this controller would be a request to create a new business unit, which could be done with a POST request to the /api/admin/business_units route, with a JSON payload containing the attributes for the new business unit. PP The CategoriesController is a controller in the Api::Admin namespace. It handles the following routes: GET /api/admin/categories: retrieves a list of all categories. GET /api/admin/categories/:id: retrieves a specific category by its id. POST /api/admin/categories: creates a new category. PUT /api/admin/categories/:id: updates a specific category by its id. DELETE /api/admin/categories/:id: deletes a specific category by its id. The controller interacts with the Category model. In the case of an error, the controller returns a status code of 422 (Unprocessable Entity) for failed create and update actions, or a status code of 404 (Not Found) for failed show and delete actions. Example usage: To retrieve a list of all categories: GET /api/admin/categories To create a new category: POST /api/admin/categories with the desired category data in the request body. To update an existing category: PUT /api/admin/categories/:id with the updated category data in the request body. To delete an existing category: DELETE /api/admin/categories/:id","title":"BusinessUnitsController"},{"location":"controller/api/#apicontrollerquestionscontroller","text":"This is the QuestionsController for the API in the Admin namespace. It is a subclass of ApiController. This controller has actions for index, show, create, update, and destroy for Question models. The before_action callback find_question is called before all actions except index and create, and it sets an instance variable @question to the Question with the id specified in the request parameters. The index action sets the instance variable @questions to the collection of all Questions, and renders a JSON response of this collection if the collection is stale. The show action authorizes the @question instance variable and renders a JSON response of it if it is stale. The create action creates a new Question from the question_params in the request and authorizes it. If the Create operation is successful, it renders a JSON response of the new Question with a status of 201. If the operation is not successful, it renders a JSON response of the Question with a status of 422. The update action authorizes the @question instance variable and, if the Update operation is successful, renders a JSON response of it with a status of 200. If the operation is not successful, it renders a JSON response of the Question with a status of 422. The destroy action authorizes the @question instance variable and, if the Destroy operation is successful, renders an empty response with a status of 204. If the operation is not successful, it renders an empty","title":"ApiController::QuestionsController"},{"location":"controller/api/#rolescontroller","text":"RolesController is an API controller in the \"Api::Admin\" namespace. It has actions for index, show, create, update, and destroy. It sets the role instance variable before the show, update, and destroy actions using the set_role method. It also finds a new role to replace the one being destroyed using the find_new_role method before the destroy action. It uses the policy_scope method to set the @roles and @new_role instance variables to the appropriate records from the Role model. It authorizes the current user for each action using the authorize method. It calls the Role::Create, Role::Update, and Role::Destroy services for the corresponding actions. It renders a JSON response for each action, with a status code of 201 for create, 200 for update, 204 for destroy, 422 for unsuccessful actions, and 200 for index and show. The create and update actions require strong parameters, which are specified in the role_params method. The destroy action assigns the new role to all staff members who currently have the role being destroyed, using the assign_new_role method.","title":"RolesController"},{"location":"controller/api/#apicontroller_1","text":"StaffMembersController is a subclass of ApiController which provides authentication and authorization for the actions within the controller. This controller has actions for index, show, create, update, and destroy for staff members. The index action retrieves a list of all staff members in the system, authorizes the action, and then renders a JSON response of the staff members if the response is not stale. The show action retrieves a specific staff member, authorizes the action, and then renders a JSON response of the staff member if the response is not stale. The create action creates a new staff member with the provided parameters and then renders a JSON response of the staff member with a status of 201 if the creation was successful, or a status of 422 if the creation failed. The update action updates a specific staff member with the provided parameters and then renders a JSON response of the updated staff member with a status of 200 if the update was successful, or a status of 422 if the update failed. The destroy action destroys a specific staff member and then returns a status of 204 if the destroy action was successful, or a status of 422 if the destroy action failed. The controller also has private methods for finding a specific staff member and for allowing certain parameters to be passed based on the current user. The models interacted with in this controller include StaffMember, Role, and BusinessUnit. Error conditions that may be encountered include the staff member not being found, invalid parameters being passed, and the current user not being authorized to perform the action.","title":"ApiController"},{"location":"controller/api/#partnersv1managementauthenticationcontroller","text":"The AuthenticationController is a controller for managing authentication for partners in the V1 API. It handles the following routes: POST /api/partners/v1/management/authentication: creates a new session for a staff member. It interacts with the following models: StaffMember: authenticates the staff member with the given email and password. AuthenticationToken: creates and returns a new authentication token for the authenticated staff member. Error conditions: If the staff member cannot be authenticated, it will render an error with a status of 401. Examples of usage: A partner makes a POST request to /api/partners/v1/management/authentication with the appropriate email and password in the request body. If the staff member is successfully authenticated, it will return a JSON object containing the authentication token and an analytics token.","title":"Partners::V1::Management::AuthenticationController"},{"location":"controller/api/#partnersv1managementpasswordresetcontroller","text":"The PasswordResetController is a controller in the Api::Partners::V1::Management namespace. It inherits from Api::Partners::V1::BaseController. It skips the authenticate and find_branch filters for the create and update actions, respectively. The create action sends a password reset email to the user with the specified email address if the user is found. The update action resets the password for the user with the specified reset token and updates the user's password if the token is valid. The reset_params method combines the reset_password_token and other user parameters passed in the request. The unlockable? method checks if the user has the unlock_access! and unlock_strategy_enabled? methods and if the email unlock strategy is enabled for the user. The user_params method permits the email, password, password_confirmation, and token parameters.","title":"Partners::V1::Management::PasswordResetController"},{"location":"controller/api/#partnersv1staffauthenticationcontroller","text":"The AuthenticationController is a controller within the Api::Partners::V1::Staff namespace. The controller is responsible for handling the creation of authentication tokens for staff members. The create action is responsible for authenticating a staff member based on their employee ID and pin. If the authentication is successful, a login session is established for the staff member and an authentication token is returned in the response. The create action skips the authenticate before action, which means that it does not require an authentication token to be passed in the request headers. However, it does run the authenticate_manager before action, which means that only staff members with the role of manager are able to use this action. The render_error method is responsible for rendering errors in the response if the authentication fails. It uses the ActiveModel::Serializer::ErrorSerializer to serialize the errors. The user_params method is a private method that permits the email and password parameters to be passed in the request. It is not used in the create action.","title":"Partners::V1::Staff::AuthenticationController"},{"location":"controller/api/#partnersv1basecontroller","text":"The BaseController is an abstract class that serves as the base for the other controllers in the Api::Partners::V1 namespace. It includes various before and rescue actions to handle common tasks and errors across controllers. Functions and routes handled: The BaseController does not handle any specific functions or routes. Instead, it provides a set of common actions that are run before or after the actions of other controllers in its namespace. Models interacted with: The BaseController does not interact with any specific models. Error conditions and examples of usage: The BaseController has a number of rescue actions that handle common errors such as routing errors, action not found errors, and record not found errors. These rescue actions render a JSON response with the appropriate status code. An example of usage for the BaseController would be as the base class for other controllers in the Api::Partners::V1 namespace. The actions provided by the BaseController would then be run before or after the actions of the derived controllers.","title":"Partners::V1::BaseController"},{"location":"controller/api/#partnersv1graphqlcontroller","text":"The GraphqlController is a controller within the Api::Partners::V1 namespace. It is responsible for handling GraphQL requests. This controller has a single action, execute, which is responsible for handling GraphQL queries and mutations. The execute action first processes the request parameters, extracting the variables, query, and operationName from the request. It then constructs a context hash containing information about the current request, such as the token_context, current_branch, current_branch_id, current_organisation, current_user, and current_role. The execute action then passes the extracted query, variables, context, and operation_name to the execute method of the VistaPlatformSchema class. This class is a GraphQL schema which defines the GraphQL types and resolvers for the application. The result of the execute method is then rendered as a JSON response to the client. The ensure_hash private method is used to convert the variables parameter to a hash. If the variables parameter is a JSON string, it is parsed into a hash. If the variables parameter is already a hash, it is returned as is. If the variables parameter is nil, an empty hash is returned. The permitted_params private method is used to allow all request parameters. It is currently commented out as it does not work properly with a nested variables","title":"Partners::V1::GraphqlController"},{"location":"controller/api/#partnersv1radarcontroller","text":"The RadarController is a controller within the Api::Partners::V1 module in a Ruby on Rails application. This controller has a single action, index, which is used to search for users within a specified radius of a given latitude and longitude using the Radar.io API. The index action uses the RestClient gem to make a GET request to the Radar.io API, passing in the necessary authorization, parameters (near, radius, limit), and a block specifying the request headers. The index action then renders the response from the API as JSON. The index action is accessed via the /api/partners/v1/radar route. This controller does not interact with any models. An error condition that could occur in this controller is if the Radar.io API returns an error status code. An example of usage for this controller would be to make a GET request to the /api/partners/v1/radar route with the necessary query parameters (lat, lon, radius).","title":"Partners::V1::RadarController"},{"location":"controller/api/#partnersv1rolescontroller","text":"RolesController is a controller in the Api::Partners::V1 module. The RolesController handles the index route, which allows users to view a list of roles. The RolesController interacts with the Role model. There are no error conditions specified in the controller. An example of usage for this controller would be a request to api/partners/v1/roles to view a list of roles.","title":"Partners::V1::RolesController"},{"location":"controller/api/#v1branchescategoriescontroller","text":"The CategoriesController is a controller in the Api::V1::Branches namespace, under the V1 version of the API. This controller has a single action, index, which retrieves a paginated list of PartnerCategory objects and includes their associated photo records. The index action renders the list of categories as a JSON response. This controller does not interact with any models directly. It uses the PartnerCategory model to retrieve the categories. There are no error conditions explicitly defined in this controller. An example of usage for this controller could be a client making a GET request to the /api/v1/branches/categories route to retrieve a list of partner categories.","title":"V1::Branches::CategoriesController"},{"location":"controller/api/#v1branchescheckincontroller","text":"The CheckInController is a controller in the Api::V1::Branches namespace that is responsible for managing check-ins for a specific branch. Functions and routes handled: This controller has a single action - create - which is responsible for creating a new check-in for a user. The create action is accessed via the POST /api/v1/branches/:id/check_in route. Models interacted with: This controller interacts with the CheckIn and Branch models. Error conditions: If the create action is unsuccessful in creating a new check-in (for example, if the provided check-in parameters are invalid), it will render a JSON response with an HTTP status of 422 (Unprocessable Entity). Examples of usage: A client app can send a POST request to the /api/v1/branches/:id/check_in route with a JSON body containing the check-in parameters to create a new check-in for the user. The response will contain the newly created check-in object if successful, or an error object if unsuccessful.","title":"V1::Branches::CheckInController"},{"location":"controller/api/#v1branchesinteractionscontroller","text":"The InteractionsController is a controller for handling interactions within a specific branch. Functions and routes handled: This controller handles the following routes: Index: returns a paginated list of interactions for the current user within a specific branch. Models interacted with: Interaction: represents a user's interaction with a specific branch. Branch: represents a physical location where a user can check in. Error conditions: If the current user is not authenticated, the controller will return a 401 Unauthorized error. If the specified branch is not found, the controller will return a 404 Not Found error. Examples of usage: To retrieve a paginated list of interactions for the current user within a specific branch: GET /api/v1/branches/:id/interactions?page=1&limit=10","title":"V1::Branches::InteractionsController"},{"location":"controller/api/#v1branchessharecontroller","text":"The ShareController is a controller in the Api::V1::Branches namespace. The controller has three actions: create, destroy, and revoke_all. The create action calls the Authorise command of the Share module, passing in the current branch, current user, and the string 'user' as arguments. If the command is successful, it returns a HTTP status code of 204. Otherwise, it returns a status code of 422. The destroy action calls the Revoke command of the Share module, passing in the current branch and current user as arguments. If the command is successful, it returns a HTTP status code of 204. Otherwise, it returns a status code of 422. If an error occurs, it returns a status code of 422. The revoke_all action calls the RevokeAll command of the Share module, passing in the current user as an argument. If the command is successful, it returns a HTTP status code of 204. Otherwise, it returns a status code of 422. The branch method is a private method that returns the current branch by finding it using the id parameter passed in through the params hash.","title":"V1::Branches::ShareController"},{"location":"controller/api/#v1categoriesignorecontroller","text":"The IgnoreController is an API controller that allows users to ignore or unignore categories. Functions and routes handled: The controller has two actions, create and destroy, which handle the routes POST /api/v1/categories/:id/ignore and DELETE /api/v1/categories/:id/ignore, respectively. The create action allows a user to ignore a category, and the destroy action allows a user to unignore a category. Models interacted with: The controller interacts with the Category and Ignore models. Error conditions: If a category cannot be found or if there is an issue saving or destroying an ignore record, a HTTP status code of 422 (Unprocessable Entity) will be returned. Examples of usage: To ignore a category with id 1, a user could send a POST request to /api/v1/categories/1/ignore. To unignore a category with id 1, a user could send a DELETE request to /api/v1/categories/1/ignore.","title":"V1::Categories::IgnoreController"},{"location":"controller/api/#v1questionsanswercontroller","text":"The AnswerController is an API controller that belongs to the V1 version of the API under the Questions module. It is responsible for handling actions related to answers to questions. The AnswerController allows users to create and destroy answers to questions. It is also responsible for updating an answer if it already exists. The AnswerController interacts with the Answer model and the Question model. If an answer fails to save, the controller will render a status of 422 (unprocessable entity). If an answer is successfully destroyed, the controller will return a status of 204 (no content). An example of usage for this controller is when a user wants to answer a question or remove their answer to a question. The user could send a POST request to /api/v1/questions/:id/answer with the necessary parameters to create an answer, or send a DELETE request to /api/v1/questions/:id/answer to delete the answer.","title":"V1::Questions::AnswerController"},{"location":"controller/api/#v1synccheckcontroller","text":"The CheckController provides a check for synchronization between the client and the server. Functions and routes handled: The index action handles the route GET /sync/check and returns the latest updated timestamps for categories, questions, and the current user. Models interacted with: The Category, Question, and User models are queried to retrieve their latest updated timestamps. Error conditions: There are no known error conditions for this controller. Examples of usage: A client application might send a GET request to /sync/check to determine if it needs to synchronize its local data with the server. The response from this controller can be used to determine which records need to be fetched from the server to update the client's local data.","title":"V1::Sync::CheckController"},{"location":"controller/api/#v1usersauthenticationcontroller","text":"The Api::V1::Users::AuthenticationController is a controller within the V1 version of the API for interacting with user authentication. This controller's primary function is to handle user login requests by authenticating the provided email and password. If the authentication is successful, the controller returns a member ID, analytics token, and authentication token to the client. If the authentication is unsuccessful, an error is returned to the client. This controller does not interact with any models directly, but rather uses the User::Authenticate command to handle the authentication process. Error conditions that this controller handles include: Invalid email or password provided User is archived An example of usage for this controller could be a client app making a POST request to the /api/v1/users/authentication route with the required email and password parameters in the request body. The server would then respond with a JSON object containing the member ID, analytics token, and authentication token if the authentication is successful, or an error if it is unsuccessful.","title":"V1::Users::AuthenticationController"},{"location":"controller/api/#v1usersregistrationcontroller","text":"Api::V1::Users::RegistrationController is a controller within the Api::V1::Users module. It handles user registration. The controller includes a create action that creates a new user based on the user_params passed in the request. It does this by calling the User::Register service, passing in user_params. If the service is successful, the controller returns a JSON response with the token and needsOnboarding fields. If the service is unsuccessful, the controller returns a JSON error response. The controller interacts with the User model to create a new user and generate an authentication token for the user. The create action is skipped for the authenticate before action, so it does not require authentication to access. An example of usage would be a client sending a POST request to the /api/v1/users/registration route with email and password fields in the request body to create a new user.","title":"V1::Users::RegistrationController"},{"location":"controller/api/#v1basecontroller","text":"The Api::V1::BaseController is a base controller for the API version 1 of the application. It includes ActionController::Serialization and sets serialization_scope to the view_context. It has a before_action to authenticate the user and set the current_user instance variable. It has rescue_from clauses to handle routing errors, missing actions, record not found errors, parameter missing errors, forbidden attribute errors, and authorization errors. It has a protected method render_404 to render a 'Resource not found' message with a 404 status. It has a protected method render_403 to render a 'Forbidden' message with a 403 status. It has a protected method render_401 to render an 'Invalid credentials' message with a 401 status. It has a protected method render_400 to render a 'Bad request' message with a 400 status. It has a protected method authenticate to authenticate the user by calling authenticate_token. If authenticate_token fails, it calls render_401. It has a protected method authenticate_token to authenticate the user by checking the HTTP token and setting the current_user instance variable. It has a protected method set_raven_context to set the context for the error logging tool Raven. It has a protected method pundit_user which returns the current_user. It has a protected method user_for_paper_trail which returns the id of the current_user or 'Missing' if the current_user is not set.","title":"V1::BaseController"},{"location":"controller/api/#v1branchescontroller","text":"The BranchesController is a controller in the Api::V1 namespace. It is a subclass of Api::V1::BaseController. It uses the has_scope method provided by the HasScope module to define several scopes that can be used to filter the branches returned by the controller. These scopes include in_category, in_city, ordered_by_distance, vista_partners, and search. The index action retrieves a list of branches based on the provided scopes and includes the :address, :shares, :categories, :photo, and :business_unit associations in the query. It then paginates the results using the page method provided by the kaminari gem. The show action retrieves a single branch based on the provided id parameter. The branch_scope private method returns either all branches or only the branches authorized for the current user, based on the value of the authorised parameter.","title":"V1::BranchesController"},{"location":"controller/api/#v1categoriescontroller","text":"The CategoriesController is a controller in the Api::V1 namespace that handles HTTP requests related to categories. The index action handles requests for a list of categories. It uses the has_scope method to apply scoping parameters to the Category model, and then returns a paginated list of categories to the client. The show action handles requests for a specific category. It uses the find_category private method to find the requested category and authorize the request using the authorize method from the Pundit gem. If the request is authorized, the action returns the requested category to the client. The find_category private method finds the requested category using the Category model and the id parameter passed in the request. The in_category scope is applied to the Category model when the category parameter is present in the request. The stale? method is used to determine if the requested data is stale (i.e., if it has been modified since the client last requested it). If the data is stale, the action sends the data to the client. If the data is not stale, a 304 Not Modified response is returned to the client.","title":"V1::CategoriesController"},{"location":"controller/api/#v1citiescontroller","text":"The CitiesController is a class that belongs to the Api::V1 namespace and is a subclass of the Api::V1::BaseController class. Functions and routes handled: The controller has an \"index\" action that is used to handle the \"GET /cities\" route. This action retrieves a paginated list of cities from the database and renders them as a JSON response. Models interacted with: The CitiesController interacts with the City model to retrieve a list of cities from the database. Error conditions: If the cities list is stale, a new list is retrieved from the database and rendered as a JSON response. If the cities list cannot be retrieved from the database, an error message is rendered as a JSON response. Examples of usage: A client can make a GET request to the \"/cities\" route to retrieve a list of cities from the server. The server will then respond with a JSON object containing the list of cities.","title":"V1::CitiesController"},{"location":"controller/api/#v1contentcategoriescontroller","text":"The ContentCategoriesController is a controller in the V1 API that is responsible for handling actions related to ContentCategory models. Functions and routes handled: This controller only has one function, the index action, which is responsible for returning a list of all ContentCategory models. This action can be accessed via the /api/v1/content_categories route. Models interacted with: The ContentCategoriesController interacts with the ContentCategory model to retrieve a list of all content categories. Error conditions: There are no specific error conditions specified in this controller. Examples of usage: An example of usage for this controller would be to make a GET request to the /api/v1/content_categories route, which would return a list of all ContentCategory models in the API's response.","title":"V1::ContentCategoriesController"},{"location":"controller/api/#v1devicescontroller","text":"The DevicesController is responsible for handling device registration for the current user. Functions and routes handled: The create action handles the creation or updating of a device for the current user. The route for this action is a POST request to '/api/v1/devices'. Models interacted with: The Device model is interacted with to find or initialize a new device for the current user, and to update the device with the provided parameters. Error conditions: If the device fails to be created or updated, a 422 Unprocessable Entity response is returned. Examples of usage: A client app may send a POST request to '/api/v1/devices' with a JSON body containing the token and platform of the device being registered. The controller will create or update the device for the current user and return a 204 No Content response on success.","title":"V1::DevicesController"},{"location":"controller/api/#v1feedcontroller","text":"The Api::V1::FeedController is a subclass of Api::V1::BaseController and is responsible for handling requests related to the feed of content for a user. The index action allows a user to retrieve a feed of articles, interactions, category updates, and videos that have been published and are relevant to the user. It uses the has_scope method to allow for filtering the results based on the updated_since parameter. The controller interacts with the Article, Interaction, CategoryUpdate, and Video models to retrieve the relevant content for the feed. If the updated_since parameter is not a valid datetime, the scope is returned as is. If the feed can be retrieved successfully, a Feed object is created with the retrieved content and rendered as JSON in the response. Example usage: A GET request is made to /api/v1/feed?updated_since=2022-01-01T00:00:00Z to retrieve the feed for a user with content that was updated since January 1st, 2022.","title":"V1::FeedController"},{"location":"controller/api/#v1mecontroller","text":"The MeController is a controller in the Api::V1 namespace that handles actions related to the currently authenticated user. The show action responds with the current user's data if the data is not stale. The update action updates the current user's data with the provided params and responds with the updated data if the update was successful, or with a status of 422 if the update was unsuccessful. The user_params method returns a subset of the permitted attributes of the user param. The permitted_attributes method returns an array of permitted attributes for the user model. The transform_params_if_multipart! method modifies the params hash by transforming the keys to be underscore-separated if the request's content type is multipart/form-data. It also applies this transformation recursively to any nested hash or array values. This controller has a before action that calls transform_params_if_multipart!, which modifies the params before they are used in the update action.","title":"V1::MeController"},{"location":"controller/api/#v1memberrequestscontroller","text":"The MemberRequestsController is for the API of the V1 version of the application and is a subclass of Api::V1::BaseController. The controller handles the following routes: Index: returns a paginated list of member requests made by the current user for a specific branch (specified by branch_id in the params). Includes member_request_type information. The list is ordered by updated_at in descending order and is scoped to the current user. Show: returns a specific member request made by the current user, specified by the id in the params. Create: creates a new member request made by the current user with the member_request_type_id and branch_id specified in the params, and any messages attached to the request. Mark as read: marks all unread messages sent by staff members in the member request as read. Send message: creates and attaches a new message to the member request, with the current user as the messageable and the body specified in the params. Request details: returns the member request made by the current user that has a specific message id specified in the params. The controller interacts with the MemberRequest, MemberRequestType, and MemberRequestMessage models. In the index, show, and request_details actions, if the requested resource is not found or is stale, a 404 or 422 error is returned respectively. In the create and send message actions, if the resource is not successfully saved, a 422 error is returned. Example usage: making a GET request to /api/v1/member_requests with the branch_id parameter specified in the query string would return a paginated","title":"V1::MemberRequestsController"},{"location":"controller/api/#v1moodcontroller","text":"The MoodController is a controller within the Api::V1 namespace and is a subclass of Api::V1::BaseController. The MoodController has a single action, create, which is used to create a new mood record for the current user. The create action creates a new Mood record using the mood_params method to whitelist and retrieve the necessary parameters. If the Mood record is successfully saved, the action renders the @mood object in JSON format. If the save is unsuccessful, the action renders the @mood object in JSON format with a status of 422 (Unprocessable Entity). The mood_params method is a private method that uses the params.require(:mood).permit(:value) syntax to whitelist and retrieve the :value parameter from the incoming request.","title":"V1::MoodController"},{"location":"controller/api/#v1notificationscontroller","text":"The NotificationsController is a controller within the Api::V1 module. It is a subclass of Api::V1::BaseController. The controller has two actions: index and update. The index action retrieves a paginated list of notifications for the current user, and the update action updates a single notification belonging to the current user. The index action uses the Notification model to retrieve notifications for the current user and includes the object association in the query. It then renders the notifications as a JSON response. The update action uses the Notification model to find a notification belonging to the current user using the params[:id] value. It then updates the notification with the notification_params and renders a JSON response with a status of 204 if the update was successful, or a status of 422 if it was not. The notification_params method is a private method that whitelists the response attribute of the notification parameter. The mark_all_read method is an after_action callback that marks all unread notifications in the @notifications instance variable as read. This method is only called for the index action. Example usage of the NotificationsController: A GET request to /api/v1/notifications would retrieve a paginated list of notifications for the current user and render them as a JSON response. A PUT request to /api/v1/notifications/5 with a JSON body of { \"notification\": { \"response\": \"accepted\" } } would update the notification with ID 5 belonging to the current user and set the response attribute to \"accepted\", and render a JSON response with a status of 204.","title":"V1::NotificationsController"},{"location":"controller/api/#v1passwordresetscontroller","text":"The PasswordResetsController is a controller in the Api::V1 namespace. It is a subclass of Api::V1::BaseController and has skip_before_action :authenticate defined, meaning that it does not run the authenticate method before its actions. The create action allows a user to request a password reset by providing their email address. If a user with the provided email is found, they will receive an email with password reset instructions. If no user is found, an error message is returned to the client. The update action allows a user to reset their password by providing their email, a new password, and a reset token that was sent to them in the password reset email. If the provided token is valid and the user's password is successfully reset, the user's account is also unlocked if the unlockable? method returns true. If the reset fails, an error message is returned to the client. The user_params method allows strong parameters for the email, password, password_confirmation, and token parameters. The reset_params method combines the user params with the reset_password_token key set to the value of the token parameter. The unlockable? method returns true if the @user object has the unlock_access! and unlock_strategy_enabled? methods defined and if the unlock_strategy_enabled? method returns true when passed the :email symbol. This allows the controller to determine if the user's account should be unlocked after a password reset.","title":"V1::PasswordResetsController"},{"location":"controller/api/#v1profilescontroller","text":"The ProfilesController is a controller in the Api::V1 namespace. The controller has three actions: share, revoke, and revoke_all. The share action creates a new Share object and associates it with a branch and the current_user. It then calls the Profile::Share service to perform the share action. If the service is successful, it returns a status of 200, otherwise it returns a status of 422. The revoke action finds a Share object using the params[:share_id] and then calls the Profile::Revoke service to perform the revoke action. If the service is successful, it returns a status of 200, otherwise it returns a status of 422. The revoke_all action finds a member (presumably a User object) and then calls the Profile::RevokeAll service to perform the revoke all action. If the service is successful, it returns a status of 200, otherwise it returns a status of 422. The controller has private methods for finding or initializing the new_share, share, and branch objects based on the request parameters. The share and revoke actions have an authorize call to authorize the action for the appropriate object.","title":"V1::ProfilesController"},{"location":"controller/api/#v1qrcontroller","text":"The QrController is a controller in the Api::V1 namespace of the application. This controller has a single action, index, which generates a QR code image and returns it as a base64 encoded string in the response. The QR code contains the text \"Vista ID\" followed by the current user's member ID. The QR code is generated using the RQRCode gem and the ChunkyPNG gem. The index action does not interact with any models. An error condition could occur if there is an issue with the RQRCode or ChunkyPNG gem while generating the QR code image. An example of usage for this controller might be to make a GET request to /api/v1/qr to retrieve the base64 encoded QR code image for the current user's member ID.","title":"V1::QrController"},{"location":"controller/api/#v1questionscontroller","text":"The QuestionsController is a part of the V1 API and is a subclass of Api::V1::BaseController. The controller has two actions: index and show. The index action is used to retrieve a list of questions, and the show action is used to retrieve a specific question. The index action uses the has_scope method to apply a scope called intro to the list of questions. It also includes the answers and photos of the questions in the list. The list of questions is then rendered as JSON. The show action first finds the specific question using the find_question private method and the params[:id] parameter. It then authorizes the question using the authorize method, and finally renders the question as JSON if it is stale. The private find_question method is used to find a specific question using the params[:id] parameter.","title":"V1::QuestionsController"},{"location":"controller/api/#v1releasescontroller","text":"The ReleasesController is a controller in the Api::V1 namespace. The check action is responsible for retrieving the latest release timestamp from the database and rendering it as a JSON response. The latest action retrieves the latest release from the database and renders the file contents as a JSON response. If no release is found, it returns an empty JSON object. The ReleasesController does not interact with any models. An error condition that could occur in the check action is if there is a problem connecting to the database or if there is a problem executing the query to retrieve the latest release timestamp. In the latest action, an error condition could occur if there is a problem connecting to the database or if there is a problem executing the query to retrieve the latest release. Example usage of the check action: A client sends a GET request to /api/v1/releases/check and the server responds with a JSON object containing the latest release timestamp. Example usage of the latest action: A client sends a GET request to /api/v1/releases/latest and the server responds with a JSON object containing the contents of the latest release file.","title":"V1::ReleasesController"},{"location":"controller/api/#v1statuscontroller","text":"The StatusController is an API controller that handles requests related to the status of the service. Functions and routes handled: This controller has a single function called ping, which is associated with the /status/ping route. This function simply responds with a message indicating that the service is available and a 200 status code. Models interacted with: This controller does not interact with any models. Error conditions: There are no error conditions specified in this controller. Examples of usage: An example usage of this controller would be to send a GET request to the /status/ping route, which would return a message indicating that the service is available. This could be used to verify that the service is running and responsive.","title":"V1::StatusController"},{"location":"controller/api/#v1synccontroller","text":"The SyncController is a controller in the Api::V1 namespace and inherits from the Api::V1::BaseController. The controller has two actions: index and create. The index action returns a JSON object with a list of question ids and updated timestamps for all of the current user's answers. The create action processes a request to synchronize the current user's answers with the server. The request can include new answers to add, existing answers to update, and existing answers to delete. The action performs these operations within a transaction to ensure that the synchronization is atomic. After the synchronization is completed, the action returns a JSON object with the updated answers for the specified questions. The controller does not interact with any models directly. Instead, it uses the has-many association between the User model and the UserAnswer model to access the current user's answers. There are no error conditions explicitly handled in this controller. If an error occurs during the synchronization process, such as a validation error when creating a new answer, it will raise an exception and the transaction will be rolled back. Example usage: An HTTP GET request to /api/v1/sync will return a JSON object with a list of the current user's answers. An HTTP POST request to /api/v1/sync with a JSON body containing add, update, and delete arrays will synchronize the current user's answers with the server. The add array should contain objects representing new answers to create, the update array should contain objects representing existing answers to update, and the delete array should contain question ids for existing answers to delete.","title":"V1::SyncController"},{"location":"controller/api/#v1useranswerscontroller","text":"The UserAnswersController is part of the Api::V1 namespace and is a subclass of Api::V1::BaseController. This controller has four actions: index, show, create, and update. The before_action callback find_answer is run before all actions except for index and create. The index action retrieves all the answers for the current user and renders them as JSON. The show action renders a single answer as JSON. The create action creates a new answer with the provided parameters, wrapped in a transaction using the UserAnswer::Create service object. If the service is successful, the answer is rendered as JSON with a 201 status code. If it fails, the answer is rendered as JSON with a 422 status code. The update action updates an existing answer with the provided parameters, wrapped in a transaction using the UserAnswer::Update service object. If the service is successful, the answer is rendered as JSON with a 200 status code. If it fails, the answer is rendered as JSON with a 422 status code. The destroy action destroys an existing answer, wrapped in a transaction using the UserAnswer::Destroy service object. If the service is successful, a 204 status code is returned. If it fails, a 422 status code is returned. The answer_params method is a private method that permits the question_id, note, and values parameters for use in the create and update actions. The find_answer method is a private method that retrieves the answer with the question_id parameter specified in the request. It is used in the show, update, and destroy actions.","title":"V1::UserAnswersController"},{"location":"controller/partner/","text":"Staff::AdminsController Partners::Staff::AdminsController is a controller in the Partners namespace and Staff module that inherits from Partners::BaseController. It has actions for viewing and managing Admin objects, such as index, show, new, edit, create, update, and destroy. The before_action callback at the top of the controller runs the set_admin method before the show, edit, update, and destroy actions. This method sets the @admin instance variable to the Admin model with an id matching the :id parameter in the request. The index action sets the @admins instance variable to all Admin objects, scoped by the current policy, and authorized with the authorize method. The show action redirects to the edit action for the @admin object. The new action sets the @admin instance variable to a new Admin object belonging to the current organization and authorized with the authorize method. The edit action simply authorizes the @admin object. The create action creates a new Admin object belonging to the current organization with the admin_params method as its attributes, authorizes it with the authorize method, and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the new view. The update action updates the attributes of the @admin object with the admin_params method and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the edit view. The destroy action destroys the @admin object and redirects to the index action with a success message. The admin_params method whitelists certain parameters for mass assignment when creating or updating an Admin object. To use this controller, you will need to define routes that map to the various actions, such as get '/partners/staff/admins' => 'partners/staff/admins#index'. You can then visit the URL corresponding to that route in a web browser to see the view rendered by the corresponding action. Error conditions that may be encountered include attempting to access a non-existent Admin object and unauthorized access to certain actions. These error conditions may be handled with exception handling in the controller or by using Pundit policies to authorize actions. Staff::BranchManagersController Partners::Staff::BranchManagersController is a controller in the Partners namespace and Staff module that inherits from Partners::BaseController. It has actions for viewing and managing BranchManager objects, such as index, show, new, edit, create, update, and destroy. The before_action callback at the top of the controller runs the set_branch_manager method before the show, edit, update, and destroy actions. This method sets the @branch_manager instance variable to the BranchManager model with an id matching the :id parameter in the request. The index action sets the @branch_managers instance variable to all BranchManager objects, scoped by the current policy, and authorized with the authorize method. The show action redirects to the edit action for the @branch_manager object. The new action sets the @branch_manager instance variable to a new BranchManager object belonging to the current organization and authorized with the authorize method. The edit action simply authorizes the @branch_manager object. The create action creates a new BranchManager object belonging to the current organization with the branch_manager_params method as its attributes, authorizes it with the authorize method, and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the new view. The update action updates the attributes of the @branch_manager object with the branch_manager_params method and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the edit view. The destroy action destroys the @branch_manager object and redirects to the index action with a success message. The branch_manager_params method whitelists certain parameters for mass assignment when creating or updating a BranchManager object. To use this controller, you will need to define routes that map to the various actions, such as get '/partners/staff/branch_managers' => 'partners/staff/branch_managers#index'. You can then visit the URL corresponding to that route in a web browser to see the view rendered by the corresponding action. Error conditions that may be encountered include attempting to access a non-existent BranchManager object and unauthorized access to certain actions. These error conditions may be handled with exception handling in the controller or by using Pundit policies to authorize actions. Staff::StaffMembersController Partners::Staff::StaffMembersController is a controller in the Partners namespace and Staff module that inherits from Partners::BaseController. It has actions for viewing and managing StaffMember objects, such as index, show, new, edit, create, update, and destroy. The before_action callback at the top of the controller runs the set_staff_member method before the show, edit, update, and destroy actions. This method sets the @staff_member instance variable to the StaffMember model with an id matching the :id parameter in the request. The index action sets the @staff_members instance variable to all StaffMember objects, scoped by the current policy and filtered with the only_staff_members method, and authorized with the authorize method. The show action redirects to the edit action for the @staff_member object. The new action sets the @staff_member instance variable to a new StaffMember object belonging to the current organization and authorized with the authorize method. The edit action simply authorizes the @staff_member object. The create action creates a new StaffMember object belonging to the current organization with the staff_member_params method as its attributes, sets the confirmed_at attribute to the current time, authorizes it with the authorize method, and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the new view. The update action updates the attributes of the @staff_member object with the staff_member_params method and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the edit view. The destroy action destroys the @staff_member object and redirects to the index action with a success message. The staff_member_params method whitelists certain parameters for mass assignment when creating or updating a StaffMember object. To use this controller, you will need to define routes that map to the various actions, such as get '/partners/staff/staff_members' => 'partners/staff/staff_members#index'. You can then visit the URL corresponding to that route in a web browser to see the view rendered by the corresponding action. Error conditions that may be encountered include attempting to access a non-existent StaffMember object and unauthorized access to certain actions. These error conditions may be handled with exception handling in the controller or by using Pundit policies to authorize actions. StaffMembers::ConfirmationsController The Partners::StaffMembers::ConfirmationsController is a subclass of Devise::ConfirmationsController which handles staff member account confirmation. It has two actions: update and show. The update action is called when a staff member submits the confirmation form after clicking the confirmation link in their email. If the staff member has not yet set a password, it will attempt to set the password with the provided params. If the password is valid and the confirmation token is valid, it will confirm the staff member's account and sign them in. If the staff member has already set a password or the provided password is invalid, it will render the show action. The show action is called when a staff member clicks the confirmation link in their email and displays the confirmation form if the staff member has not yet set a password. If the staff member has already set a password, it will confirm the staff member's account and sign them in. In both cases, if there are any errors, it will render the staff_members/confirmations/new view. BaseController The Partners::BaseController is a base class for controllers in the Partners namespace. It defines a number of before and after actions that will be run for each request made to a controller that inherits from this base class. These actions include authenticating the staff member, setting the context for error tracking with Raven, setting the user responsible for any changes tracked by PaperTrail, and preparing unobtrusive flash messages. It also defines a layout and helper method that will be available to all controllers that inherit from it. The controller has a rescue_from block that catches a Pundit::NotAuthorizedError and redirects the user to the partners root path with a flash message. It also has a private method for determining the current organization for the signed in staff member. BranchesController The Partners::BranchesController is a subclass of Partners::BaseController, which provides common functionality to controllers in the Partners namespace. This controller is responsible for handling CRUD (create, read, update, delete) operations for branches. A branch is a location of a business that belongs to a business unit. A business unit is a logical grouping of branches, and each business unit belongs to a single organisation. This controller has six actions: index, show, new, edit, create, and destroy. The index action retrieves a paginated list of branches for a given business unit, and the show action redirects to the edit action for the given branch. The new and edit actions render a form for creating or updating a branch, respectively. The create and update actions handle the submission of the form and either create or update the branch, respectively. The destroy action deletes the given branch. This controller interacts with three models: BusinessUnit, Branch, and Address. The BusinessUnit model represents a business unit, the Branch model represents a branch, and the Address model represents the physical address of a branch. Error conditions that this controller handles include Pundit::NotAuthorizedError, which is raised when a staff member attempts to perform an action that they are not authorized to perform. When this error is raised, the controller responds by redirecting the user to the partners root path and displaying an alert message. Examples of usage for this controller include creating a new branch for a business unit, editing the details of an existing branch, and deleting a branch that is no longer in use. BusinessUnitsController The Partners::BusinessUnitsController is a subclass of Partners::BaseController, which means it has access to the helper methods and before actiPartners::BusinessUnitsControllerons defined in the base controller. This controller is responsible for handling actions related to business units within the Partners namespace. The controller can handle the following routes: index, show, new, create, update, and destroy. It interacts with the BusinessUnit model and uses policy scope to retrieve a paginated list of business units for the index action. The controller also has a private set_business_unit method which sets an instance variable @business_unit to a specific business unit based on the id provided in the params. The controller also has a private business_unit_params method which whitelists the name attribute for mass assignment. If a business unit fails to save or update, an error message will be displayed to the user. An example of usage for this controller might be visiting the index route to view a list of all business units within the current organisation. MemberRequestTypesController The Partners::MemberRequestTypesController is a subclass of Partners::BaseController, meaning it inherits behavior and methods from the base class. This controller is responsible for handling actions related to member request types within a business unit. It has actions for listing, creating, updating, and destroying member request types. The controller uses the before_action hook to set the business unit and request type for certain actions. The index action retrieves a paginated list of all member request types within the business unit and authorizes them for the current user. The new action creates a new instance of a member request type for the business unit. The create action creates a new member request type using the provided parameters and assigns it to the current business unit. If the save is successful, the user is redirected to the list of member request types for the business unit, otherwise the new template is rendered. The update action updates the provided member request type with the given parameters and redirects to the list of member request types upon success. The destroy action destroys the provided member request type and redirects to the list of member request types upon success. The private set_business_unit and set_request_type methods retrieve the business unit and member request type, respectively, based on the provided id in the params. The member_request_type_params method is used to whitelist the parameters for creating or updating a member request type. The models interacted with by this controller include the MemberRequestType model and the BusinessUnit model. An error condition that could occur is if the user is not authorized to perform an action, in which case they will be redirected to the root path with an alert message. An example of usage for this controller could be a business unit administrator wanting to create a new member request type for their business unit to track customer requests. QuestionsController The Partners::QuestionsController is a controller in the Partners namespace that inherits from the Partners::BaseController. It has a single action, \"index\", which defines an instance variable @questions as the result of a paginated query to the Question model using the policy_scope method. The index action then renders a JSON response containing the id and title attributes of each Question object in @questions. This controller does not interact with any models outside of the Question model. There are no error conditions or examples of usage specified in the given code. RolesController The Partners::RolesController is a controller for managing roles within a business unit. It is a subclass of the Partners::BaseController and includes several before_action filters to set the business unit and role, as well as a find_new_role filter to find a role to replace the one being destroyed. The controller has actions for index, show, new, create, update, and destroy for roles. The index action will paginate and retrieve all roles in the system and authorize them. The show action will redirect to the edit action for the role. The new action will create a new role for the business unit. The create action will create a new role with the provided role params and authorize it. The update action will update the role with the provided role params and authorize it. The destroy action will authorize the role and destroy it, optionally replacing it with a different role provided in the params. The controller also includes private methods to set the business unit and role based on the params, find a new role to replace the one being destroyed, assign the new role to staff members, and permit the necessary params for creating and updating a role. The model interacted with is the Role model. Error conditions include not specifying a replacement role when trying to destroy a role, and any validation errors when creating or updating a role. An example of usage would be a staff member visiting the index page to view all roles in the system, clicking on a role to view or edit it, creating a new role, updating an existing role, or destroying a role and replacing it with another. SessionsController The Partners::SessionsController is a subclass of the Devise::SessionsController, which is a controller that provides authentication for the application. This controller handles the routes for logging in and logging out of the application. It interacts with the StaffMember model, which is the model for staff members that are allowed to log in to the application. If a staff member attempts to log in with invalid credentials, an error message will be displayed. This controller does not have any specific functions, but rather it is inherited from the Devise::SessionsController and makes use of its functions. An example of usage for this controller would be a staff member navigating to the login page, entering their email and password, and then being redirected to the application's dashboard upon successful login.","title":"Partner"},{"location":"controller/partner/#staffadminscontroller","text":"Partners::Staff::AdminsController is a controller in the Partners namespace and Staff module that inherits from Partners::BaseController. It has actions for viewing and managing Admin objects, such as index, show, new, edit, create, update, and destroy. The before_action callback at the top of the controller runs the set_admin method before the show, edit, update, and destroy actions. This method sets the @admin instance variable to the Admin model with an id matching the :id parameter in the request. The index action sets the @admins instance variable to all Admin objects, scoped by the current policy, and authorized with the authorize method. The show action redirects to the edit action for the @admin object. The new action sets the @admin instance variable to a new Admin object belonging to the current organization and authorized with the authorize method. The edit action simply authorizes the @admin object. The create action creates a new Admin object belonging to the current organization with the admin_params method as its attributes, authorizes it with the authorize method, and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the new view. The update action updates the attributes of the @admin object with the admin_params method and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the edit view. The destroy action destroys the @admin object and redirects to the index action with a success message. The admin_params method whitelists certain parameters for mass assignment when creating or updating an Admin object. To use this controller, you will need to define routes that map to the various actions, such as get '/partners/staff/admins' => 'partners/staff/admins#index'. You can then visit the URL corresponding to that route in a web browser to see the view rendered by the corresponding action. Error conditions that may be encountered include attempting to access a non-existent Admin object and unauthorized access to certain actions. These error conditions may be handled with exception handling in the controller or by using Pundit policies to authorize actions.","title":"Staff::AdminsController"},{"location":"controller/partner/#staffbranchmanagerscontroller","text":"Partners::Staff::BranchManagersController is a controller in the Partners namespace and Staff module that inherits from Partners::BaseController. It has actions for viewing and managing BranchManager objects, such as index, show, new, edit, create, update, and destroy. The before_action callback at the top of the controller runs the set_branch_manager method before the show, edit, update, and destroy actions. This method sets the @branch_manager instance variable to the BranchManager model with an id matching the :id parameter in the request. The index action sets the @branch_managers instance variable to all BranchManager objects, scoped by the current policy, and authorized with the authorize method. The show action redirects to the edit action for the @branch_manager object. The new action sets the @branch_manager instance variable to a new BranchManager object belonging to the current organization and authorized with the authorize method. The edit action simply authorizes the @branch_manager object. The create action creates a new BranchManager object belonging to the current organization with the branch_manager_params method as its attributes, authorizes it with the authorize method, and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the new view. The update action updates the attributes of the @branch_manager object with the branch_manager_params method and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the edit view. The destroy action destroys the @branch_manager object and redirects to the index action with a success message. The branch_manager_params method whitelists certain parameters for mass assignment when creating or updating a BranchManager object. To use this controller, you will need to define routes that map to the various actions, such as get '/partners/staff/branch_managers' => 'partners/staff/branch_managers#index'. You can then visit the URL corresponding to that route in a web browser to see the view rendered by the corresponding action. Error conditions that may be encountered include attempting to access a non-existent BranchManager object and unauthorized access to certain actions. These error conditions may be handled with exception handling in the controller or by using Pundit policies to authorize actions.","title":"Staff::BranchManagersController"},{"location":"controller/partner/#staffstaffmemberscontroller","text":"Partners::Staff::StaffMembersController is a controller in the Partners namespace and Staff module that inherits from Partners::BaseController. It has actions for viewing and managing StaffMember objects, such as index, show, new, edit, create, update, and destroy. The before_action callback at the top of the controller runs the set_staff_member method before the show, edit, update, and destroy actions. This method sets the @staff_member instance variable to the StaffMember model with an id matching the :id parameter in the request. The index action sets the @staff_members instance variable to all StaffMember objects, scoped by the current policy and filtered with the only_staff_members method, and authorized with the authorize method. The show action redirects to the edit action for the @staff_member object. The new action sets the @staff_member instance variable to a new StaffMember object belonging to the current organization and authorized with the authorize method. The edit action simply authorizes the @staff_member object. The create action creates a new StaffMember object belonging to the current organization with the staff_member_params method as its attributes, sets the confirmed_at attribute to the current time, authorizes it with the authorize method, and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the new view. The update action updates the attributes of the @staff_member object with the staff_member_params method and then attempts to save it to the database. If the save is successful, it redirects to the index action with a success message. If the save is unsuccessful, it re-renders the edit view. The destroy action destroys the @staff_member object and redirects to the index action with a success message. The staff_member_params method whitelists certain parameters for mass assignment when creating or updating a StaffMember object. To use this controller, you will need to define routes that map to the various actions, such as get '/partners/staff/staff_members' => 'partners/staff/staff_members#index'. You can then visit the URL corresponding to that route in a web browser to see the view rendered by the corresponding action. Error conditions that may be encountered include attempting to access a non-existent StaffMember object and unauthorized access to certain actions. These error conditions may be handled with exception handling in the controller or by using Pundit policies to authorize actions.","title":"Staff::StaffMembersController"},{"location":"controller/partner/#staffmembersconfirmationscontroller","text":"The Partners::StaffMembers::ConfirmationsController is a subclass of Devise::ConfirmationsController which handles staff member account confirmation. It has two actions: update and show. The update action is called when a staff member submits the confirmation form after clicking the confirmation link in their email. If the staff member has not yet set a password, it will attempt to set the password with the provided params. If the password is valid and the confirmation token is valid, it will confirm the staff member's account and sign them in. If the staff member has already set a password or the provided password is invalid, it will render the show action. The show action is called when a staff member clicks the confirmation link in their email and displays the confirmation form if the staff member has not yet set a password. If the staff member has already set a password, it will confirm the staff member's account and sign them in. In both cases, if there are any errors, it will render the staff_members/confirmations/new view.","title":"StaffMembers::ConfirmationsController"},{"location":"controller/partner/#basecontroller","text":"The Partners::BaseController is a base class for controllers in the Partners namespace. It defines a number of before and after actions that will be run for each request made to a controller that inherits from this base class. These actions include authenticating the staff member, setting the context for error tracking with Raven, setting the user responsible for any changes tracked by PaperTrail, and preparing unobtrusive flash messages. It also defines a layout and helper method that will be available to all controllers that inherit from it. The controller has a rescue_from block that catches a Pundit::NotAuthorizedError and redirects the user to the partners root path with a flash message. It also has a private method for determining the current organization for the signed in staff member.","title":"BaseController"},{"location":"controller/partner/#branchescontroller","text":"The Partners::BranchesController is a subclass of Partners::BaseController, which provides common functionality to controllers in the Partners namespace. This controller is responsible for handling CRUD (create, read, update, delete) operations for branches. A branch is a location of a business that belongs to a business unit. A business unit is a logical grouping of branches, and each business unit belongs to a single organisation. This controller has six actions: index, show, new, edit, create, and destroy. The index action retrieves a paginated list of branches for a given business unit, and the show action redirects to the edit action for the given branch. The new and edit actions render a form for creating or updating a branch, respectively. The create and update actions handle the submission of the form and either create or update the branch, respectively. The destroy action deletes the given branch. This controller interacts with three models: BusinessUnit, Branch, and Address. The BusinessUnit model represents a business unit, the Branch model represents a branch, and the Address model represents the physical address of a branch. Error conditions that this controller handles include Pundit::NotAuthorizedError, which is raised when a staff member attempts to perform an action that they are not authorized to perform. When this error is raised, the controller responds by redirecting the user to the partners root path and displaying an alert message. Examples of usage for this controller include creating a new branch for a business unit, editing the details of an existing branch, and deleting a branch that is no longer in use.","title":"BranchesController"},{"location":"controller/partner/#businessunitscontroller","text":"The Partners::BusinessUnitsController is a subclass of Partners::BaseController, which means it has access to the helper methods and before actiPartners::BusinessUnitsControllerons defined in the base controller. This controller is responsible for handling actions related to business units within the Partners namespace. The controller can handle the following routes: index, show, new, create, update, and destroy. It interacts with the BusinessUnit model and uses policy scope to retrieve a paginated list of business units for the index action. The controller also has a private set_business_unit method which sets an instance variable @business_unit to a specific business unit based on the id provided in the params. The controller also has a private business_unit_params method which whitelists the name attribute for mass assignment. If a business unit fails to save or update, an error message will be displayed to the user. An example of usage for this controller might be visiting the index route to view a list of all business units within the current organisation.","title":"BusinessUnitsController"},{"location":"controller/partner/#memberrequesttypescontroller","text":"The Partners::MemberRequestTypesController is a subclass of Partners::BaseController, meaning it inherits behavior and methods from the base class. This controller is responsible for handling actions related to member request types within a business unit. It has actions for listing, creating, updating, and destroying member request types. The controller uses the before_action hook to set the business unit and request type for certain actions. The index action retrieves a paginated list of all member request types within the business unit and authorizes them for the current user. The new action creates a new instance of a member request type for the business unit. The create action creates a new member request type using the provided parameters and assigns it to the current business unit. If the save is successful, the user is redirected to the list of member request types for the business unit, otherwise the new template is rendered. The update action updates the provided member request type with the given parameters and redirects to the list of member request types upon success. The destroy action destroys the provided member request type and redirects to the list of member request types upon success. The private set_business_unit and set_request_type methods retrieve the business unit and member request type, respectively, based on the provided id in the params. The member_request_type_params method is used to whitelist the parameters for creating or updating a member request type. The models interacted with by this controller include the MemberRequestType model and the BusinessUnit model. An error condition that could occur is if the user is not authorized to perform an action, in which case they will be redirected to the root path with an alert message. An example of usage for this controller could be a business unit administrator wanting to create a new member request type for their business unit to track customer requests.","title":"MemberRequestTypesController"},{"location":"controller/partner/#questionscontroller","text":"The Partners::QuestionsController is a controller in the Partners namespace that inherits from the Partners::BaseController. It has a single action, \"index\", which defines an instance variable @questions as the result of a paginated query to the Question model using the policy_scope method. The index action then renders a JSON response containing the id and title attributes of each Question object in @questions. This controller does not interact with any models outside of the Question model. There are no error conditions or examples of usage specified in the given code.","title":"QuestionsController"},{"location":"controller/partner/#rolescontroller","text":"The Partners::RolesController is a controller for managing roles within a business unit. It is a subclass of the Partners::BaseController and includes several before_action filters to set the business unit and role, as well as a find_new_role filter to find a role to replace the one being destroyed. The controller has actions for index, show, new, create, update, and destroy for roles. The index action will paginate and retrieve all roles in the system and authorize them. The show action will redirect to the edit action for the role. The new action will create a new role for the business unit. The create action will create a new role with the provided role params and authorize it. The update action will update the role with the provided role params and authorize it. The destroy action will authorize the role and destroy it, optionally replacing it with a different role provided in the params. The controller also includes private methods to set the business unit and role based on the params, find a new role to replace the one being destroyed, assign the new role to staff members, and permit the necessary params for creating and updating a role. The model interacted with is the Role model. Error conditions include not specifying a replacement role when trying to destroy a role, and any validation errors when creating or updating a role. An example of usage would be a staff member visiting the index page to view all roles in the system, clicking on a role to view or edit it, creating a new role, updating an existing role, or destroying a role and replacing it with another.","title":"RolesController"},{"location":"controller/partner/#sessionscontroller","text":"The Partners::SessionsController is a subclass of the Devise::SessionsController, which is a controller that provides authentication for the application. This controller handles the routes for logging in and logging out of the application. It interacts with the StaffMember model, which is the model for staff members that are allowed to log in to the application. If a staff member attempts to log in with invalid credentials, an error message will be displayed. This controller does not have any specific functions, but rather it is inherited from the Devise::SessionsController and makes use of its functions. An example of usage for this controller would be a staff member navigating to the login page, entering their email and password, and then being redirected to the application's dashboard upon successful login.","title":"SessionsController"},{"location":"function/","text":"Folder structure \u251c\u2500\u2500\u2500helper \u251c\u2500\u2500\u2500admin \u2514\u2500\u2500\u2500partners \u2514\u2500\u2500\u2500staff ApplicationHelper module The ApplicationHelper module is a utility module that provides a set of helper methods that can be used in views and controllers throughout a Ruby on Rails application. Here is a description of the title method you provided: Description: This method sets the title of the page by setting the value of the :title content variable. Input parameters: text: A string containing the title text to set. Output values: None. Error conditions: None. Examples of usage: Here's an example of how you might use the title method in a view: <% title 'My Page' %> This would set the :title content variable to 'My Page', which could then be used to set the title of the page in the layout file. For example: <title><%= content_for :title %></title> This would insert the value of the :title content variable into the title element of the page. subdomain function Description: This function generates a URL for a given subdomain by concatenating the subdomain with the host of the application. Input parameters: subdomain (string): The subdomain to be used in the generated URL. This parameter is optional, and if it is not provided, the function will use an empty string as the subdomain. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: with_subdomain(\"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") with_subdomain(nil) # returns \"localhost\" with_subdomain(\"\") # returns \"localhost\" url_for function : Description: This function generates a URL based on the provided options. If the :subdomain option is present, it will be used to generate the URL using the with_subdomain function. Input parameters: options (hash): A hash of options to be used to generate the URL. This parameter is optional, and if it is not provided, the function will use the default options. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: url_for(subdomain: \"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") url_for(host: \"example.com\") # returns \"example.com\" url_for # returns the default URL for the application","title":"structure"},{"location":"function/#folder-structure","text":"\u251c\u2500\u2500\u2500helper \u251c\u2500\u2500\u2500admin \u2514\u2500\u2500\u2500partners \u2514\u2500\u2500\u2500staff","title":"Folder structure"},{"location":"function/#applicationhelper-module","text":"The ApplicationHelper module is a utility module that provides a set of helper methods that can be used in views and controllers throughout a Ruby on Rails application. Here is a description of the title method you provided: Description: This method sets the title of the page by setting the value of the :title content variable. Input parameters: text: A string containing the title text to set. Output values: None. Error conditions: None. Examples of usage: Here's an example of how you might use the title method in a view: <% title 'My Page' %> This would set the :title content variable to 'My Page', which could then be used to set the title of the page in the layout file. For example: <title><%= content_for :title %></title> This would insert the value of the :title content variable into the title element of the page.","title":"ApplicationHelper module"},{"location":"function/#subdomain-function","text":"Description: This function generates a URL for a given subdomain by concatenating the subdomain with the host of the application. Input parameters: subdomain (string): The subdomain to be used in the generated URL. This parameter is optional, and if it is not provided, the function will use an empty string as the subdomain. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: with_subdomain(\"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") with_subdomain(nil) # returns \"localhost\" with_subdomain(\"\") # returns \"localhost\" url_for function : Description: This function generates a URL based on the provided options. If the :subdomain option is present, it will be used to generate the URL using the with_subdomain function. Input parameters: options (hash): A hash of options to be used to generate the URL. This parameter is optional, and if it is not provided, the function will use the default options. Output values: A string containing the generated URL. Error conditions: None. Examples of usage: url_for(subdomain: \"test\") # returns \"test.localhost\" (assuming the host of the application is \"localhost\") url_for(host: \"example.com\") # returns \"example.com\" url_for # returns the default URL for the application","title":"subdomain function"},{"location":"function/admin/","text":"Admin The following are the helper functions under the admin directory category_parent_selection function Description: This function generates an array of arrays containing category names and IDs, with each category's ancestors included in the name. The resulting array is sorted by the category name. Input parameters: None. Output values: An array of arrays containing category names and IDs, with each category's ancestors included in the name, sorted by the category name. Error conditions: None. Examples of usage: category_parent_selection # returns an array of arrays containing category names and IDs, with each category's ancestors included in the name, sorted by the category name render_partner_categories function Description: This function renders a sortable list of categories using the render_sortable function and the provided reorder_admin_partner_categories_path URL. Input parameters: categories (collection): A collection of categories to be rendered. Output values: A rendered list of categories. Error conditions: If the categories parameter is nil or empty, the function returns nil. Examples of usage: render_partner_categories(Category.all) # renders a sortable list of all categories using the provided `reorder_admin_partner_categories_path` URL render_categories function Description: This function renders a sortable list of categories using the render_sortable function and the provided reorder_admin_categories_path URL. Input parameters: categories (collection): A collection of categories to be rendered. Output values: A rendered list of categories. Error conditions: If the categories parameter is nil or empty, the function returns nil. Examples of usage: render_categories(Category.all) # renders a sortable list of all categories using the provided `reorder_admin_categories_path` URL render_sortable function Description: This function renders a sortable list of items using the provided URL. Input parameters: collection (collection): A collection of items to be rendered. url (string): The URL to be used for sorting the items. Output values: A rendered list of items. Error conditions: If the collection parameter is nil or empty, the function returns nil. Examples of usage: render_sortable(Category.all, reorder_admin_categories_path) # renders a sortable list of all categories using the provided URL import_status function Description: This function returns an icon and text representing the status of a data import. Input parameters: data_import (object): An object representing a data import. The object should have a status attribute. Output values: An icon and text representing the status of the data import. Error conditions: If the data_import parameter is nil, the function returns nil. If the status attribute of the data_import object is not one of the expected values (\"new\", \"running\", \"finished\", \"failed\"), the function returns nil. Examples of usage: import_status(DataImport.first) # returns an icon and text representing the status of the first data import in the database navbar_breadcrumbs function Description: This function generates a breadcrumb navigation element with the specified options. Input parameters: None. Output values: A breadcrumb navigation element with the specified options. Error conditions: None. Examples of usage: navbar_breadcrumbs # generates a breadcrumb navigation element with the specified options category_selection function Description: This function generates an array of arrays containing category names and IDs, with each category's ancestors included in the name, for all non-root categories. The resulting array is sorted by the category name. Input parameters: None. Output values: An array of arrays containing category names and IDs, with each category's ancestors included in the name, for all non-root categories, sorted by the category name. Error conditions: None. Examples of usage: category_selection # returns an array of arrays containing category names and IDs, with each category's ancestors included in the name, for all non-root categories, sorted by the category name release_status function Description: This function returns an icon and text representing the status of a release. Input parameters: release (object): An object representing a release. The object should have a status attribute. Output values: An icon and text representing the status of the release. Error conditions: If the release parameter is nil, the functi codeon returns nil. If the status attribute of the release object is not one of the expected values (\"queued\", \"processing\", \"complete\"), the function returns nil. Examples of usage: release_status(Release.first) # returns an icon and text representing the status of the first release in the database published_status function Description: This function returns a string indicating whether a video is published or not. Input parameters: video (object): An object representing a video. The object should have a published? method. Output values: A string indicating whether the video is published or not. Error conditions: If the video parameter is nil, the function returns nil. Examples of usage: published_status(Video.first) # returns a string indicating whether the first video in the database is published or not published_at function Description: This function returns a string representing the date and time at which a video was published, or \"n/a\" if the video is not published. Input parameters: video (object): An object representing a video. The object should have a published? method and a published_at attribute. Output values: A string representing the date and time at which the video was published, or \"n/a\" if the video is not published. Error conditions: If the video parameter is nil, the function returns nil. Examples of usage: published_at(Video.first) # returns a string representing the date and time at which the first video in the database was published, or \"n/a\" if the video is not published organisation_name function Description: This function returns the name of the organisation associated with a video, or \"Vista\" if the video is not associated with an organisation. Input parameters: video (object): An object representing a video. The object should have an organisation attribute. Output values: The name of the organisation associated with the video, or \"Vista\" if the video is not associated with an organisation. Error conditions: If the video parameter is nil, the function returns nil. Examples of usage: organisation_name(Video.first) # returns the name of the organisation associated with the first video in the database, or \"Vista\" if the video is not associated with an organisation organisation_select function Description: This function generates an array of arrays containing the names and IDs of all organisations, with \"Vista\" included as the first option. Input parameters: None. Output values: An array of arrays containing the names and IDs of all organisations, with \"Vista\" included as the first option. Error conditions: None. Examples of usage: organisation_select # returns an array of arrays containing the names and IDs of all organisations, with \"Vista\" included as the first option","title":"admin"},{"location":"function/admin/#admin","text":"The following are the helper functions under the admin directory","title":"Admin"},{"location":"function/admin/#category_parent_selection-function","text":"Description: This function generates an array of arrays containing category names and IDs, with each category's ancestors included in the name. The resulting array is sorted by the category name. Input parameters: None. Output values: An array of arrays containing category names and IDs, with each category's ancestors included in the name, sorted by the category name. Error conditions: None. Examples of usage: category_parent_selection # returns an array of arrays containing category names and IDs, with each category's ancestors included in the name, sorted by the category name","title":"category_parent_selection function"},{"location":"function/admin/#render_partner_categories-function","text":"Description: This function renders a sortable list of categories using the render_sortable function and the provided reorder_admin_partner_categories_path URL. Input parameters: categories (collection): A collection of categories to be rendered. Output values: A rendered list of categories. Error conditions: If the categories parameter is nil or empty, the function returns nil. Examples of usage: render_partner_categories(Category.all) # renders a sortable list of all categories using the provided `reorder_admin_partner_categories_path` URL","title":"render_partner_categories function"},{"location":"function/admin/#render_categories-function","text":"Description: This function renders a sortable list of categories using the render_sortable function and the provided reorder_admin_categories_path URL. Input parameters: categories (collection): A collection of categories to be rendered. Output values: A rendered list of categories. Error conditions: If the categories parameter is nil or empty, the function returns nil. Examples of usage: render_categories(Category.all) # renders a sortable list of all categories using the provided `reorder_admin_categories_path` URL","title":"render_categories function"},{"location":"function/admin/#render_sortable-function","text":"Description: This function renders a sortable list of items using the provided URL. Input parameters: collection (collection): A collection of items to be rendered. url (string): The URL to be used for sorting the items. Output values: A rendered list of items. Error conditions: If the collection parameter is nil or empty, the function returns nil. Examples of usage: render_sortable(Category.all, reorder_admin_categories_path) # renders a sortable list of all categories using the provided URL","title":"render_sortable function"},{"location":"function/admin/#import_status-function","text":"Description: This function returns an icon and text representing the status of a data import. Input parameters: data_import (object): An object representing a data import. The object should have a status attribute. Output values: An icon and text representing the status of the data import. Error conditions: If the data_import parameter is nil, the function returns nil. If the status attribute of the data_import object is not one of the expected values (\"new\", \"running\", \"finished\", \"failed\"), the function returns nil. Examples of usage: import_status(DataImport.first) # returns an icon and text representing the status of the first data import in the database","title":"import_status function"},{"location":"function/admin/#navbar_breadcrumbs-function","text":"Description: This function generates a breadcrumb navigation element with the specified options. Input parameters: None. Output values: A breadcrumb navigation element with the specified options. Error conditions: None. Examples of usage: navbar_breadcrumbs # generates a breadcrumb navigation element with the specified options","title":"navbar_breadcrumbs function"},{"location":"function/admin/#category_selection-function","text":"Description: This function generates an array of arrays containing category names and IDs, with each category's ancestors included in the name, for all non-root categories. The resulting array is sorted by the category name. Input parameters: None. Output values: An array of arrays containing category names and IDs, with each category's ancestors included in the name, for all non-root categories, sorted by the category name. Error conditions: None. Examples of usage: category_selection # returns an array of arrays containing category names and IDs, with each category's ancestors included in the name, for all non-root categories, sorted by the category name","title":"category_selection function"},{"location":"function/admin/#release_status-function","text":"Description: This function returns an icon and text representing the status of a release. Input parameters: release (object): An object representing a release. The object should have a status attribute. Output values: An icon and text representing the status of the release. Error conditions: If the release parameter is nil, the functi codeon returns nil. If the status attribute of the release object is not one of the expected values (\"queued\", \"processing\", \"complete\"), the function returns nil. Examples of usage: release_status(Release.first) # returns an icon and text representing the status of the first release in the database","title":"release_status function"},{"location":"function/admin/#published_status-function","text":"Description: This function returns a string indicating whether a video is published or not. Input parameters: video (object): An object representing a video. The object should have a published? method. Output values: A string indicating whether the video is published or not. Error conditions: If the video parameter is nil, the function returns nil. Examples of usage: published_status(Video.first) # returns a string indicating whether the first video in the database is published or not","title":"published_status function"},{"location":"function/admin/#published_at-function","text":"Description: This function returns a string representing the date and time at which a video was published, or \"n/a\" if the video is not published. Input parameters: video (object): An object representing a video. The object should have a published? method and a published_at attribute. Output values: A string representing the date and time at which the video was published, or \"n/a\" if the video is not published. Error conditions: If the video parameter is nil, the function returns nil. Examples of usage: published_at(Video.first) # returns a string representing the date and time at which the first video in the database was published, or \"n/a\" if the video is not published","title":"published_at function"},{"location":"function/admin/#organisation_name-function","text":"Description: This function returns the name of the organisation associated with a video, or \"Vista\" if the video is not associated with an organisation. Input parameters: video (object): An object representing a video. The object should have an organisation attribute. Output values: The name of the organisation associated with the video, or \"Vista\" if the video is not associated with an organisation. Error conditions: If the video parameter is nil, the function returns nil. Examples of usage: organisation_name(Video.first) # returns the name of the organisation associated with the first video in the database, or \"Vista\" if the video is not associated with an organisation","title":"organisation_name function"},{"location":"function/admin/#organisation_select-function","text":"Description: This function generates an array of arrays containing the names and IDs of all organisations, with \"Vista\" included as the first option. Input parameters: None. Output values: An array of arrays containing the names and IDs of all organisations, with \"Vista\" included as the first option. Error conditions: None. Examples of usage: organisation_select # returns an array of arrays containing the names and IDs of all organisations, with \"Vista\" included as the first option","title":"organisation_select function"},{"location":"function/partner/","text":"Partners The following are the helper functions under the partners directory business_units_for_select function : Description: This function returns the business units of the current organisation if the current staff member is an admin, or the business units assigned to the current staff member if they are not an admin. Input parameters: None. Output values: The business units of the current organisation if the current staff member is an admin, or the business units assigned to the current staff member if they are not an admin. Error conditions: If the current_organisation or current_staff_member objects are nil, the function returns nil. Examples of usage: business_units_for_select # returns the business units of the current organisation if the current staff member is an admin, or the business units assigned to the current staff member if they are not an admin preference_groups_json function : Description: This function generates a JSON array of preference groups, including their IDs, titles, and the titles of their questions. Input parameters: preference_groups (collection): A collection of preference group objects. Output values: A JSON array of preference groups, including their IDs, titles, and the titles of their questions. Error conditions: If the preference_groups parameter is `nil","title":"partners"},{"location":"function/partner/#partners","text":"The following are the helper functions under the partners directory","title":"Partners"},{"location":"function/partner/#business_units_for_select-function","text":"Description: This function returns the business units of the current organisation if the current staff member is an admin, or the business units assigned to the current staff member if they are not an admin. Input parameters: None. Output values: The business units of the current organisation if the current staff member is an admin, or the business units assigned to the current staff member if they are not an admin. Error conditions: If the current_organisation or current_staff_member objects are nil, the function returns nil. Examples of usage: business_units_for_select # returns the business units of the current organisation if the current staff member is an admin, or the business units assigned to the current staff member if they are not an admin","title":"business_units_for_select function:"},{"location":"function/partner/#preference_groups_json-function","text":"Description: This function generates a JSON array of preference groups, including their IDs, titles, and the titles of their questions. Input parameters: preference_groups (collection): A collection of preference group objects. Output values: A JSON array of preference groups, including their IDs, titles, and the titles of their questions. Error conditions: If the preference_groups parameter is `nil","title":"preference_groups_json function:"},{"location":"graphql/","text":"Folder structure \u251c\u2500\u2500\u2500graphql \u251c\u2500\u2500\u2500mutations \u251c\u2500\u2500\u2500resolvers \u2514\u2500\u2500\u2500types BranchRequired It appears to be a field instrumentation that checks for the presence of a :current_branch key in the GraphQL context object ctx. If the :current_branch key is not present, it raises a GraphQL::ExecutionError with the message :branch_missing. Otherwise, it calls the original resolve function for the field. The instrument method is called with a GraphQL type and field as arguments. It checks if the :branch_required metadata key is present on the field. If it is not present, it simply returns the field. Otherwise, it creates a new resolve function using the authorization_proc method and assigns it to the field using the resolve method. The authorization_proc method creates a lambda function that checks for the presence of :current_branch in the ctx object and calls the original resolve function for the field if it is present. If :current_branch is not present, it raises a GraphQL::ExecutionError with the message :branch_missing. RoleRequired It appears to be a field instrumentation that checks for the presence of a :current_role key in the GraphQL context object ctx. If the :current_role key is not present, it raises a GraphQL::ExecutionError with the message :role_missing. Otherwise, it calls the original resolve function for the field. The instrument method is called with a GraphQL type and field as arguments. It checks if the :role_required metadata key is present on the field. If it is not present, it simply returns the field. Otherwise, it creates a new resolve function using the authorization_proc method and assigns it to the field using the resolve method. The authorization_proc method creates a lambda function that checks for the presence of :current_role in the ctx object and calls the original resolve function for the field if it is present. If :current_role is not present, it raises a GraphQL::ExecutionError with the message :role_missing. TokenContext It appears to be a field instrumentation that checks for the presence of a :token_context key in the GraphQL context object ctx and compares its value to a required context specified in the field's metadata. If the :token_context value does not match the required context, it raises a GraphQL::ExecutionError with the message :forbidden. Otherwise, it calls the original resolve function for the field. The instrument method is called with a GraphQL type and field as arguments. It checks if the :token_context metadata key is present on the field and has a non-blank value. If it is not present or has a blank value, it simply returns the field. Otherwise, it creates a new resolve function using the authorization_proc method and assigns it to the field using the resolve method. The authorization_proc method creates a lambda function that checks for the presence of :token_context in the ctx object and compares its value to the required context. If the values do not match, it raises a GraphQL::ExecutionError with the message :forbidden. Otherwise, it calls the original resolve function for the field. VistaPlatformSchema It is a subclass of the GraphQL::Schema class and is defined using the GraphQL::Schema.define method. It includes three field instrumentations: TokenContext, BranchRequired, and RoleRequired. The GraphQL::Field.accepts_definitions method is used to define metadata keys for the three field instrumentations. The GraphQL::Define.assign_metadata_key method assigns a metadata key with a symbol as an argument to a field. The instrument method is called on the VistaPlatformSchema class to apply the field instrumentations to the fields in the schema. The VistaPlatformSchema class also includes a mutation field for the Types::MutationType, a query field for the Types::QueryType, and a subscription field for the Types::SubscriptionType. The VistaPlatformSchema class also includes the GraphQL::Backtrace and GraphQL::Subscriptions::ActionCableSubscriptions middlewares. The VistaPlatformSchema.graphql_definition method is called at the end as a hack to pre-warm the schema to avoid race conditions when loading types. This is a known issue in the graphql-ruby library and is discussed in this GitHub issue: https://github.com/rmosolgo/graphql-ruby/issues/1505","title":"structure"},{"location":"graphql/#folder-structure","text":"\u251c\u2500\u2500\u2500graphql \u251c\u2500\u2500\u2500mutations \u251c\u2500\u2500\u2500resolvers \u2514\u2500\u2500\u2500types","title":"Folder structure"},{"location":"graphql/#branchrequired","text":"It appears to be a field instrumentation that checks for the presence of a :current_branch key in the GraphQL context object ctx. If the :current_branch key is not present, it raises a GraphQL::ExecutionError with the message :branch_missing. Otherwise, it calls the original resolve function for the field. The instrument method is called with a GraphQL type and field as arguments. It checks if the :branch_required metadata key is present on the field. If it is not present, it simply returns the field. Otherwise, it creates a new resolve function using the authorization_proc method and assigns it to the field using the resolve method. The authorization_proc method creates a lambda function that checks for the presence of :current_branch in the ctx object and calls the original resolve function for the field if it is present. If :current_branch is not present, it raises a GraphQL::ExecutionError with the message :branch_missing.","title":"BranchRequired"},{"location":"graphql/#rolerequired","text":"It appears to be a field instrumentation that checks for the presence of a :current_role key in the GraphQL context object ctx. If the :current_role key is not present, it raises a GraphQL::ExecutionError with the message :role_missing. Otherwise, it calls the original resolve function for the field. The instrument method is called with a GraphQL type and field as arguments. It checks if the :role_required metadata key is present on the field. If it is not present, it simply returns the field. Otherwise, it creates a new resolve function using the authorization_proc method and assigns it to the field using the resolve method. The authorization_proc method creates a lambda function that checks for the presence of :current_role in the ctx object and calls the original resolve function for the field if it is present. If :current_role is not present, it raises a GraphQL::ExecutionError with the message :role_missing.","title":"RoleRequired"},{"location":"graphql/#tokencontext","text":"It appears to be a field instrumentation that checks for the presence of a :token_context key in the GraphQL context object ctx and compares its value to a required context specified in the field's metadata. If the :token_context value does not match the required context, it raises a GraphQL::ExecutionError with the message :forbidden. Otherwise, it calls the original resolve function for the field. The instrument method is called with a GraphQL type and field as arguments. It checks if the :token_context metadata key is present on the field and has a non-blank value. If it is not present or has a blank value, it simply returns the field. Otherwise, it creates a new resolve function using the authorization_proc method and assigns it to the field using the resolve method. The authorization_proc method creates a lambda function that checks for the presence of :token_context in the ctx object and compares its value to the required context. If the values do not match, it raises a GraphQL::ExecutionError with the message :forbidden. Otherwise, it calls the original resolve function for the field.","title":"TokenContext"},{"location":"graphql/#vistaplatformschema","text":"It is a subclass of the GraphQL::Schema class and is defined using the GraphQL::Schema.define method. It includes three field instrumentations: TokenContext, BranchRequired, and RoleRequired. The GraphQL::Field.accepts_definitions method is used to define metadata keys for the three field instrumentations. The GraphQL::Define.assign_metadata_key method assigns a metadata key with a symbol as an argument to a field. The instrument method is called on the VistaPlatformSchema class to apply the field instrumentations to the fields in the schema. The VistaPlatformSchema class also includes a mutation field for the Types::MutationType, a query field for the Types::QueryType, and a subscription field for the Types::SubscriptionType. The VistaPlatformSchema class also includes the GraphQL::Backtrace and GraphQL::Subscriptions::ActionCableSubscriptions middlewares. The VistaPlatformSchema.graphql_definition method is called at the end as a hack to pre-warm the schema to avoid race conditions when loading types. This is a known issue in the graphql-ruby library and is discussed in this GitHub issue: https://github.com/rmosolgo/graphql-ruby/issues/1505","title":"VistaPlatformSchema"},{"location":"graphql/resolver/","text":"CreateInteractionResolver It is a subclass of the GraphQL::Function class and is used to create a new interaction record in the database. It takes four arguments as inputs: type, notes, userId, and memberRequestId. type and notes are required and are both strings, while userId is a required ID field and memberRequestId is an optional ID field. The function returns an object of type Types::InteractionType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the Interactions::Create command to create a new interaction record with the input arguments and the current_user and current_branch values from the context object. If the command is successful, the function checks if a memberRequestId was provided. If it was, it calls the MemberRequests::Finalise command with the memberRequestId, current_user, and the newly created interaction's id. If the Interactions::Create command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors. CreateMemberRequestMessageResolver It is a subclass of the GraphQL::Function class and is used to create a new message for a member request in the database. It takes two arguments as inputs: body, a required string field, and requestId, a required ID field. The function returns an object of type Types::MemberRequestMessageType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequestMessage::Create command to create a new message for a member request with the input arguments and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors. ReadMemberRequestResolver It is a subclass of the GraphQL::Function class and is used to mark a member request as read in the database. It takes one argument as input: memberRequestId, a required ID field. The function returns an object of type Types::MemberRequestType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequests::MarkAsRead command to mark a member request as read with the memberRequestId argument and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors. It appears that this function is intended to be called by the partner app's GraphQL mutation, with a staff member marking member messages as read. SendMemberRequestMessageResolver It is a subclass of the GraphQL::Function class and is used to send a message for a member request in the database. It takes two arguments as inputs: memberRequestId, a required ID field, and body, an optional string field. The function returns an object of type Types::MemberRequestMessageType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequests::Message command to send a message for a member request with the memberRequestId and body arguments and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors. StaffLogin It is a subclass of the GraphQL::Function class and is used to authenticate a staff member and generate an authentication token. It takes two arguments as inputs: employee_id, a required string field, and pin, a required string field. The function returns an object of type Types::TokenType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the StaffMember::Staff::Authenticate command to authenticate the staff member with the employee_id and pin arguments and the current_organisation value from the context object. If the command is successful, the function creates an authentication token using the AuthenticationToken.create_and_return_staff_token method and passes in the authenticated user and the request from the context object. It returns an OpenStruct object with the token attribute set to the generated token. If the command fails, it raises a GraphQL::ExecutionError with the errors from the command. UpdateMemberRequestResolver It is a subclass of the GraphQL::Function class and is used to update a member request in the database. It takes three arguments as inputs: memberRequestId, a required ID field, memberRequestTypeId, an optional ID field, and status, an optional string field. The function returns an object of type Types::MemberRequestType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequests::Update command to update the member request with the memberRequestId, memberRequestTypeId, and status arguments and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the errors from the command.","title":"resolver"},{"location":"graphql/resolver/#createinteractionresolver","text":"It is a subclass of the GraphQL::Function class and is used to create a new interaction record in the database. It takes four arguments as inputs: type, notes, userId, and memberRequestId. type and notes are required and are both strings, while userId is a required ID field and memberRequestId is an optional ID field. The function returns an object of type Types::InteractionType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the Interactions::Create command to create a new interaction record with the input arguments and the current_user and current_branch values from the context object. If the command is successful, the function checks if a memberRequestId was provided. If it was, it calls the MemberRequests::Finalise command with the memberRequestId, current_user, and the newly created interaction's id. If the Interactions::Create command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors.","title":"CreateInteractionResolver"},{"location":"graphql/resolver/#creatememberrequestmessageresolver","text":"It is a subclass of the GraphQL::Function class and is used to create a new message for a member request in the database. It takes two arguments as inputs: body, a required string field, and requestId, a required ID field. The function returns an object of type Types::MemberRequestMessageType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequestMessage::Create command to create a new message for a member request with the input arguments and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors.","title":"CreateMemberRequestMessageResolver"},{"location":"graphql/resolver/#readmemberrequestresolver","text":"It is a subclass of the GraphQL::Function class and is used to mark a member request as read in the database. It takes one argument as input: memberRequestId, a required ID field. The function returns an object of type Types::MemberRequestType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequests::MarkAsRead command to mark a member request as read with the memberRequestId argument and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors. It appears that this function is intended to be called by the partner app's GraphQL mutation, with a staff member marking member messages as read.","title":"ReadMemberRequestResolver"},{"location":"graphql/resolver/#sendmemberrequestmessageresolver","text":"It is a subclass of the GraphQL::Function class and is used to send a message for a member request in the database. It takes two arguments as inputs: memberRequestId, a required ID field, and body, an optional string field. The function returns an object of type Types::MemberRequestMessageType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequests::Message command to send a message for a member request with the memberRequestId and body arguments and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the command's errors.","title":"SendMemberRequestMessageResolver"},{"location":"graphql/resolver/#stafflogin","text":"It is a subclass of the GraphQL::Function class and is used to authenticate a staff member and generate an authentication token. It takes two arguments as inputs: employee_id, a required string field, and pin, a required string field. The function returns an object of type Types::TokenType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the StaffMember::Staff::Authenticate command to authenticate the staff member with the employee_id and pin arguments and the current_organisation value from the context object. If the command is successful, the function creates an authentication token using the AuthenticationToken.create_and_return_staff_token method and passes in the authenticated user and the request from the context object. It returns an OpenStruct object with the token attribute set to the generated token. If the command fails, it raises a GraphQL::ExecutionError with the errors from the command.","title":"StaffLogin"},{"location":"graphql/resolver/#updatememberrequestresolver","text":"It is a subclass of the GraphQL::Function class and is used to update a member request in the database. It takes three arguments as inputs: memberRequestId, a required ID field, memberRequestTypeId, an optional ID field, and status, an optional string field. The function returns an object of type Types::MemberRequestType. The function defines a call method that is called with an object, arguments, and context as arguments. It uses the MemberRequests::Update command to update the member request with the memberRequestId, memberRequestTypeId, and status arguments and the current_user value from the context object. If the command is successful, the function returns the result of the command. If the command fails, it raises a GraphQL::ExecutionError with the errors from the command.","title":"UpdateMemberRequestResolver"},{"location":"graphql/type/","text":"BaseObject Objects in GraphQL represent a group of related fields. They define a set of fields that can be queried by clients, and specify the type of data that each field returns. The BaseObject class is intended to be used as a base class for application-specific GraphQL object types. This allows developers to define their own GraphQL object types that inherit common behavior from the base class. For example, developers can define a UserObject class that inherits from BaseObject and adds fields specific to a user object type. To use BaseObject , developers should define their own GraphQL object types by creating subclasses of BaseObject and defining the fields for the object type. The fields can then be queried by clients using GraphQL queries. BaseScalar The BaseScalar class is a subclass of the GraphQL::Schema::Scalar class. It represents a scalar type in a GraphQL schema. A scalar type is a leaf node in the GraphQL type system, representing a primitive value like a string, number, or boolean. The BaseScalar class can be used to define custom scalar types for a GraphQL schema. For example, you could define a custom Date scalar type by creating a subclass of BaseScalar : class Date < BaseScalar description \"A date value in the format 'YYYY-MM-DD'\" def self.coerce_input(input_value, context) # Parse the input value and return a Time object end def self.coerce_result(ruby_value, context) # Format the ruby value as a string and return it end end You can then use this Date scalar type in your GraphQL schema: field :birthday, Date, null: false This field represents a date value that can be queried and modified using GraphQL. The coerce_input and coerce_result methods handle converting between the GraphQL input and Ruby values. BranchType The BranchType is a GraphQL object type that represents a branch in the system. It has three fields, id , name , and address , all of which are required. The id field is of type ID , the name field is of type String , and the address field is also of type String . These fields represent the unique identifier for a branch, the name of the branch, and the address of the branch, respectively. This object type can be used in GraphQL queries and mutations to retrieve and manipulate data about branches in the system. BusinessUnitType BusinessUnitType is a GraphQL object type representing a business unit in the application. It has two fields: \u2022 id : a unique identifier for the business unit, of type ID. \u2022 name : the name of the business unit, of type String. This object type can be used as a return type for GraphQL queries and mutations related to business units, allowing clients to request and receive data about business units. For example, a GraphQL query might include a field for fetching a business unit by its ID, and this object type would be used to define the shape of the data returned in the response. CategoryType The CategoryType is a GraphQL object type representing a category. It has several fields: \u2022 id : The ID of the category, represented as a string. \u2022 title : The title of the category, represented as a string. \u2022 description : A description of the category, represented as a string. \u2022 ancestry : A string representing the ancestry of the category in the category tree. \u2022 position : The position of the category in the category tree, represented as an integer. \u2022 questions : An array of QuestionType objects representing the questions belonging to this category. \u2022 categories : An array of CategoryType objects representing the child categories of this category. \u2022 questionsCount : An integer representing the number of questions belonging to this category. \u2022 answeredQuestionsCount : An integer representing the number of questions belonging to this category that have been answered by a specific user. This field takes an argument userId , which is the ID of the user as a string. CheckInType The CheckInType is a GraphQL object type that represents a check-in. It has the following fields: \u2022 id : This is the ID of the check-in. It is a scalar type of types.ID . \u2022 userId : This is the ID of the user who checked in. It is a scalar type of types.ID . It maps to the user_id field in the database. \u2022 branchId : This is the ID of the branch where the user checked in. It is a scalar type of types.ID . It maps to the branch_id field in the database. \u2022 arrivalDate : This is the date of the check-in. It is a scalar type of DateType . It maps to the arrival_date field in the database. \u2022 arrivalTimeStart : This is the start time of the check-in. It is a scalar type of TimeType . It maps to the arrival_time_start field in the database. \u2022 arrivalTimeEnd : This is the end time of the check-in. It is a scalar type of TimeType . It maps to the arrival_time_end field in the database. DateTimeType The DateTimeType is a GraphQL scalar type that represents a date and time value in the ISO-8601 format. It is defined as a subclass of BaseScalar , which is a base class for custom scalar types in the GraphQL schema. The coerce_input method is used to convert the input value (a string in ISO-8601 format) into a Ruby Time object. The coerce_result method is used to convert a Ruby Time object into a string in ISO-8601 format, which is the format expected by the GraphQL schema. This scalar type can be used in the GraphQL schema to define fields that return date and time values. For example: field :createdAt, DateTimeType, null: false This will define a createdAt field that returns a date and time value in the ISO-8601 format. When queried, the field will return a string in the following format: \"YYYY-MM-DDTHH:MM:SS.SSSZ\" . DateType The DateType is a GraphQL scalar type representing a date value. It includes two methods, coerce_input and coerce_result , which define how input values should be coerced (converted) when they are passed to the GraphQL server, and how result values should be coerced when they are returned from the server to the client. In this case, coerce_input converts the input value to a date object, and coerce_result converts the date object to an ISO 8601 formatted string. This allows the GraphQL server to accept and return date values in a standardized way. InteractionType The InteractionType is a GraphQL object type that represents an interaction between a user and a staff member. It has several fields: \u2022 id : The ID of the interaction. This is an integer and cannot be null. \u2022 user : The user who is interacting with the staff member. This is a UserType object and cannot be null. \u2022 type : The type of interaction. This is a string and cannot be null. \u2022 date : The date of the interaction. This is a DateType object and cannot be null. \u2022 value : The value of the interaction. This is a string and can be null. \u2022 staffMember : The staff member who is interacting with the user. This is a StaffMemberType object and can be null. JsonType The JsonType is a custom scalar type for GraphQL that allows for passing JSON data between the client and server. The coerce_input and coerce_result methods define how the server should handle incoming and outgoing data of this type. In this implementation, the methods simply return the passed in value, which means that the server is not doing any additional processing or manipulation of the JSON data. This scalar type can be used in GraphQL queries and mutations to pass complex data structures as arguments or return values. MemberRequestMessageType The MemberRequestMessageType is a GraphQL object type that represents a message sent in relation to a member request. It has the following fields: \u2022 id : The ID of the message. It is of type types.ID which is a GraphQL type representing a unique identifier. \u2022 messageable : The sender of the message. It is of type MessageableType , which represents the message sender. \u2022 body : The content of the message. It is of type types.String , which is a GraphQL type representing a string value. \u2022 memberRequest : The member request that this message is related to. It is of type MemberRequestType , which represents a member request. \u2022 senderName : The name of the sender of the message. It is of type types.String . \u2022 senderType : The type of the sender of the message. It is of type types.String . \u2022 createdAt : The time when the message was created. It is of type DateTimeType , which represents a date and time value. MemberRequestTypeType The MemberRequestTypeType GraphQL object type represents a type of member request in the system. It has three fields: id : The ID of the member request type. business_unit : The business unit that this member request type belongs to. This field is of the type BusinessUnitType . name : The name of the member request type. This object type is typically used to represent a member request type in a GraphQL query or mutation. For example, a GraphQL query might request the id , name , and business_unit fields for a given member request type. MemberRequestType The MemberRequestType is a GraphQL object type that represents a member request. It has the following fields: \u2022 id : The ID of the member request, represented as an integer. \u2022 user : The user who made the member request, represented as a UserType object. \u2022 branch : The branch associated with the member request, represented as a BranchType object. \u2022 status : The status of the member request, represented as a string. \u2022 read : A boolean indicating whether the member request has been read by the member. \u2022 updatedAt : The last update time of the member request, represented as a DateTimeType object. \u2022 displayName : The name of the user who made the member request, represented as a string. \u2022 memberRequestType : The type of the member request, represented as a MemberRequestTypeType object. \u2022 memberRequestMessages : An array of MemberRequestMessageType objects that represent the messages associated with the member request. \u2022 lastMessage : The last message associated with the member request, represented as a MemberRequestMessageType object. MessageableType The MessageableType is a GraphQL union type that represents a user or a staff member who may send a MemberRequest message. It is composed of the UserType and StaffMemberType types and defines a resolve_type method that determines which of these types an object belongs to. When a member request message is queried, this union type is used to determine whether the sender is a user or a staff member and return the appropriate type. This allows the GraphQL API to return a consistent shape of data for messages sent by either type of messageable. MoodType The MoodType is a GraphQL object type that represents a mood. It has three fields: userId : This is the ID of the user who has the mood. description : This is a description of the mood. user : This is the user who has the mood. This object type is used to query for moods and get information about them. It is likely used in a GraphQL query or mutation to get or set the mood of a user. MutationType The MutationType is an object type in GraphQL that defines a set of fields that a client can mutate (create, update, delete) on the server. In this case, the MutationType has four fields: staffLogin: This field accepts input and returns a staff member's token if the login is successful. It is implemented using the StaffLogin Resolver. createInteraction: This field accepts input and creates a new interaction record. It is implemented using the CreateInteractionResolver. updateMemberRequest: This field accepts input and updates a member request record. It is implemented using the UpdateMemberRequestResolver. sendMemberRequestMessage: This field accepts input and creates a new member request message record. It is implemented using the SendMemberRequestMessageResolver. readMemberRequest: This field accepts input and marks a member request as read. It is implemented using the ReadMemberRequestResolver. PartnerInteractionType It is a subclass of the BaseObject class and represents a partner interaction. It has two fields: label, a string that is required and non-null, and value, a string that is required and non-null. This object type can be used in a GraphQL schema to define a type for partner interactions. The label and value fields can be used to represent the name and value of the interaction respectively. PhotoType It represents a photo and has several fields: id, a required ID field; previewUrl, a required string field that maps to the member_id property; largeUrl, a required string field that is resolved using the large URL of the image object; thumbUrl, a required string field that is resolved using the thumb URL of the image object; and previewUrl, a required string field that is resolved using the preview_data value of the image object. This object type can be used in a GraphQL schema to define a type for photos. The id field represents the ID of the photo, the previewUrl field represents the URL for the preview of the photo, the largeUrl and thumbUrl fields represent the URLs for the large and thumbnail versions of the photo respectively, and the previewUrl field represents the URL for the preview data of the photo. PreferenceGroupType It takes in two arguments: memberRequestId and body, both of which are required. The memberRequestId argument is the ID of the member request to which the message is being sent, and the body argument is the contents of the message. This function returns an object of type MemberRequestMessageType, which represents a message sent in response to a member request. The function first calls the MemberRequests::Message command, passing in the memberRequestId, body, and the current_user from the context. If the command is successful, the function returns the result of the command. If the command is not successful, it raises a GraphQL execution error with the command's errors. QueryType This GraphQL query type defines fields that can be queried by the client. Each field has a name, a type, and a resolve function that specifies how to retrieve the data for that field. The branches field returns an array of BranchType objects and is only accessible to users with the manager token context. It retrieves the branches for the current user's organization if the user is an admin, or the branches assigned to the user if they are a branch manager. The currentBranch field returns a single BranchType object and is only accessible to users with the staff token context. It retrieves the current branch of the user. The roles field returns an array of RoleType objects and is only accessible to users with the manager token context and a current branch. It retrieves the roles for the current user's branch. The staffMembers field returns an array of StaffMemberType objects and is only accessible to users with the manager token context, a current branch, and a current role. It retrieves the staff members for the current user's branch and role. The user field returns a single UserType object and is only accessible to users with the staff token context and a current branch. It takes an id argument and retrieves the user with the matching id in the current user's branch. The users field returns an array of UserType objects and is only accessible to users with the staff token context and a current branch. It takes optional search, before, and limit arguments and retrieves users in the current user's branch, filtered by the search term, limited to those before a certain id, and limited to the specified number. The nearbyUsers field returns an array of UserType objects and is only accessible to users with the staff token QuestionType The QuestionType is a GraphQL object type that represents a question in the system. It has fields for the id, title, kind, and lockingConditions of the question, as well as a field for the allowsNote property. The allowsNote field represents whether the question allows for a note to be added. The QuestionType also has a field called userAnswer, which represents the answer given by a specific user to the question. This field takes an argument of userId, which is the ID of the user for which the answer is being retrieved. The userAnswer field is resolved using a lambda function that fetches the user answer from the user_answers association of the Question object. The QuestionType is used to represent a question in the GraphQL API and is typically used in queries to retrieve information about questions. RoleType The RoleType is a GraphQL object type that represents a role within an organization. It contains fields such as id, name, interactions, preferenceStructure, and topQuestions. The preferenceStructure field is commented out and replaced with an alternative field. This type also has a resolve function that is commented out. This function appears to be generating image URLs for small and large sizes, and returning an object with information about the height, source, and width of the images. This object is likely used to provide the client with information about the image to be displayed. ShareAuthoriseType The ShareAuthoriseType is a GraphQL object type that represents the result of an authorization to share user data with a partner app. It has a single field, user, which is of the UserType object type and is required. This field represents the user whose data has been authorized for sharing. ShareRevokeType The ShareRevokeType is a GraphQL object type that represents a share that has been revoked. It has two fields: user: This is an instance of the UserType object and represents the user whose share has been revoked. revoked_at: This field represents the date and time at which the share was revoked. It is an instance of the DateTimeType and is not nullable. This object type is likely used to represent the result of a GraphQL mutation that revokes a share. It allows the client to get information about the user whose share was revoked and when the share was revoked. ShareType The ShareType GraphQL object type represents a share. It has fields for the ID of the branch and user, the status of the share, the method through which the share was made (via), and the timestamps for when the share was created and updated. It also has fields for the user and branch objects related to the share, as well as the timestamps for when the share was authorized and revoked. StaffMemberType The StaffMemberType GraphQL object type represents a staff member. It has fields for the ID, employee ID, name, and first and last names of the staff member. SubscriptionType The SubscriptionType GraphQL object type defines several fields for subscriptions that a client can subscribe to in order to receive updates in real-time. The shareChanged field will emit an update when a user shares or revokes their profile with another user. The type of the update is ShareType, and the subscription scope is limited to the current branch ID. The moodChanged field will emit an update when a user updates their mood. The type of the update is MoodType, and the subscription scope is limited to the current branch ID. The newMessage field will emit an update when a user sends a new message in a member request. The type of the update is MemberRequestMessageType, and the subscription scope is limited to the current user ID. The newMemberRequest field will emit an update when a user submits a new member request. The type of the update is MemberRequestType, and the subscription scope is limited to the current user ID. The requestCountChanged field will emit an update when a user's request count changes for a branch. The type of the update is MemberRequestType, and the subscription scope is limited to the current branch ID. TimeType The TimeType is a GraphQL scalar type that represents a specific point in time. It is defined to parse input values as a Time object in the application's time zone, and to output the result as a formatted string in UTC time, in the format '%H:%M' (hours and minutes). This allows clients to send and receive time values in a standard format, while allowing the server to store and manipulate them in the time zone it is configured to use. TokenType The TokenType GraphQL object type represents an authentication token for a user. It has a single field, token, which is a string representing the token. This type is likely used in the context of a GraphQL mutation or query that allows a user to authenticate with a token in order to access certain resources. UserAnswerType The UserAnswerType is a GraphQL object type that represents a user's answer to a question. It has fields for the id, userId, questionId, note, and values of the answer, as well as timestamps for when the answer was created and last updated. It also has a field for linkedCategories, which returns an array of categories that are linked to the user's answer through their visibility conditions. The linkedCategories field is resolved by querying the Category model for categories whose visibility conditions match the user's answer. UserType The UserType is a GraphQL object type that represents a user. It has several fields, including: id: the ID of the user, represented as a string memberId: the ID of the user's member, represented as a string firstName: the first name of the user, represented as a string lastName: the last name of the user, represented as a string name: the full name of the user, represented as a string sharedAt: the date and time when the user shared their profile with the current branch, represented as a DateTime object mood: the mood of the user, represented as a string checkIn: the current check-in of the user at the current branch, represented as a CheckInType object photo: the photo of the user, represented as a PhotoType object jobTitle: the job title of the user, represented as a string company: the company the user works for, represented as a string address: the address of the user, represented as a string gender: the gender of the user, represented as a string personality: the personality traits of the user, represented as a JSON object requestCount: the number of open and pending member requests the user has at the current branch, represented as an integer","title":"type"},{"location":"graphql/type/#baseobject","text":"Objects in GraphQL represent a group of related fields. They define a set of fields that can be queried by clients, and specify the type of data that each field returns. The BaseObject class is intended to be used as a base class for application-specific GraphQL object types. This allows developers to define their own GraphQL object types that inherit common behavior from the base class. For example, developers can define a UserObject class that inherits from BaseObject and adds fields specific to a user object type. To use BaseObject , developers should define their own GraphQL object types by creating subclasses of BaseObject and defining the fields for the object type. The fields can then be queried by clients using GraphQL queries.","title":"BaseObject"},{"location":"graphql/type/#basescalar","text":"The BaseScalar class is a subclass of the GraphQL::Schema::Scalar class. It represents a scalar type in a GraphQL schema. A scalar type is a leaf node in the GraphQL type system, representing a primitive value like a string, number, or boolean. The BaseScalar class can be used to define custom scalar types for a GraphQL schema. For example, you could define a custom Date scalar type by creating a subclass of BaseScalar : class Date < BaseScalar description \"A date value in the format 'YYYY-MM-DD'\" def self.coerce_input(input_value, context) # Parse the input value and return a Time object end def self.coerce_result(ruby_value, context) # Format the ruby value as a string and return it end end You can then use this Date scalar type in your GraphQL schema: field :birthday, Date, null: false This field represents a date value that can be queried and modified using GraphQL. The coerce_input and coerce_result methods handle converting between the GraphQL input and Ruby values.","title":"BaseScalar"},{"location":"graphql/type/#branchtype","text":"The BranchType is a GraphQL object type that represents a branch in the system. It has three fields, id , name , and address , all of which are required. The id field is of type ID , the name field is of type String , and the address field is also of type String . These fields represent the unique identifier for a branch, the name of the branch, and the address of the branch, respectively. This object type can be used in GraphQL queries and mutations to retrieve and manipulate data about branches in the system.","title":"BranchType"},{"location":"graphql/type/#businessunittype","text":"BusinessUnitType is a GraphQL object type representing a business unit in the application. It has two fields: \u2022 id : a unique identifier for the business unit, of type ID. \u2022 name : the name of the business unit, of type String. This object type can be used as a return type for GraphQL queries and mutations related to business units, allowing clients to request and receive data about business units. For example, a GraphQL query might include a field for fetching a business unit by its ID, and this object type would be used to define the shape of the data returned in the response.","title":"BusinessUnitType"},{"location":"graphql/type/#categorytype","text":"The CategoryType is a GraphQL object type representing a category. It has several fields: \u2022 id : The ID of the category, represented as a string. \u2022 title : The title of the category, represented as a string. \u2022 description : A description of the category, represented as a string. \u2022 ancestry : A string representing the ancestry of the category in the category tree. \u2022 position : The position of the category in the category tree, represented as an integer. \u2022 questions : An array of QuestionType objects representing the questions belonging to this category. \u2022 categories : An array of CategoryType objects representing the child categories of this category. \u2022 questionsCount : An integer representing the number of questions belonging to this category. \u2022 answeredQuestionsCount : An integer representing the number of questions belonging to this category that have been answered by a specific user. This field takes an argument userId , which is the ID of the user as a string.","title":"CategoryType"},{"location":"graphql/type/#checkintype","text":"The CheckInType is a GraphQL object type that represents a check-in. It has the following fields: \u2022 id : This is the ID of the check-in. It is a scalar type of types.ID . \u2022 userId : This is the ID of the user who checked in. It is a scalar type of types.ID . It maps to the user_id field in the database. \u2022 branchId : This is the ID of the branch where the user checked in. It is a scalar type of types.ID . It maps to the branch_id field in the database. \u2022 arrivalDate : This is the date of the check-in. It is a scalar type of DateType . It maps to the arrival_date field in the database. \u2022 arrivalTimeStart : This is the start time of the check-in. It is a scalar type of TimeType . It maps to the arrival_time_start field in the database. \u2022 arrivalTimeEnd : This is the end time of the check-in. It is a scalar type of TimeType . It maps to the arrival_time_end field in the database.","title":"CheckInType"},{"location":"graphql/type/#datetimetype","text":"The DateTimeType is a GraphQL scalar type that represents a date and time value in the ISO-8601 format. It is defined as a subclass of BaseScalar , which is a base class for custom scalar types in the GraphQL schema. The coerce_input method is used to convert the input value (a string in ISO-8601 format) into a Ruby Time object. The coerce_result method is used to convert a Ruby Time object into a string in ISO-8601 format, which is the format expected by the GraphQL schema. This scalar type can be used in the GraphQL schema to define fields that return date and time values. For example: field :createdAt, DateTimeType, null: false This will define a createdAt field that returns a date and time value in the ISO-8601 format. When queried, the field will return a string in the following format: \"YYYY-MM-DDTHH:MM:SS.SSSZ\" .","title":"DateTimeType"},{"location":"graphql/type/#datetype","text":"The DateType is a GraphQL scalar type representing a date value. It includes two methods, coerce_input and coerce_result , which define how input values should be coerced (converted) when they are passed to the GraphQL server, and how result values should be coerced when they are returned from the server to the client. In this case, coerce_input converts the input value to a date object, and coerce_result converts the date object to an ISO 8601 formatted string. This allows the GraphQL server to accept and return date values in a standardized way.","title":"DateType"},{"location":"graphql/type/#interactiontype","text":"The InteractionType is a GraphQL object type that represents an interaction between a user and a staff member. It has several fields: \u2022 id : The ID of the interaction. This is an integer and cannot be null. \u2022 user : The user who is interacting with the staff member. This is a UserType object and cannot be null. \u2022 type : The type of interaction. This is a string and cannot be null. \u2022 date : The date of the interaction. This is a DateType object and cannot be null. \u2022 value : The value of the interaction. This is a string and can be null. \u2022 staffMember : The staff member who is interacting with the user. This is a StaffMemberType object and can be null.","title":"InteractionType"},{"location":"graphql/type/#jsontype","text":"The JsonType is a custom scalar type for GraphQL that allows for passing JSON data between the client and server. The coerce_input and coerce_result methods define how the server should handle incoming and outgoing data of this type. In this implementation, the methods simply return the passed in value, which means that the server is not doing any additional processing or manipulation of the JSON data. This scalar type can be used in GraphQL queries and mutations to pass complex data structures as arguments or return values.","title":"JsonType"},{"location":"graphql/type/#memberrequestmessagetype","text":"The MemberRequestMessageType is a GraphQL object type that represents a message sent in relation to a member request. It has the following fields: \u2022 id : The ID of the message. It is of type types.ID which is a GraphQL type representing a unique identifier. \u2022 messageable : The sender of the message. It is of type MessageableType , which represents the message sender. \u2022 body : The content of the message. It is of type types.String , which is a GraphQL type representing a string value. \u2022 memberRequest : The member request that this message is related to. It is of type MemberRequestType , which represents a member request. \u2022 senderName : The name of the sender of the message. It is of type types.String . \u2022 senderType : The type of the sender of the message. It is of type types.String . \u2022 createdAt : The time when the message was created. It is of type DateTimeType , which represents a date and time value.","title":"MemberRequestMessageType"},{"location":"graphql/type/#memberrequesttypetype","text":"The MemberRequestTypeType GraphQL object type represents a type of member request in the system. It has three fields: id : The ID of the member request type. business_unit : The business unit that this member request type belongs to. This field is of the type BusinessUnitType . name : The name of the member request type. This object type is typically used to represent a member request type in a GraphQL query or mutation. For example, a GraphQL query might request the id , name , and business_unit fields for a given member request type.","title":"MemberRequestTypeType"},{"location":"graphql/type/#memberrequesttype","text":"The MemberRequestType is a GraphQL object type that represents a member request. It has the following fields: \u2022 id : The ID of the member request, represented as an integer. \u2022 user : The user who made the member request, represented as a UserType object. \u2022 branch : The branch associated with the member request, represented as a BranchType object. \u2022 status : The status of the member request, represented as a string. \u2022 read : A boolean indicating whether the member request has been read by the member. \u2022 updatedAt : The last update time of the member request, represented as a DateTimeType object. \u2022 displayName : The name of the user who made the member request, represented as a string. \u2022 memberRequestType : The type of the member request, represented as a MemberRequestTypeType object. \u2022 memberRequestMessages : An array of MemberRequestMessageType objects that represent the messages associated with the member request. \u2022 lastMessage : The last message associated with the member request, represented as a MemberRequestMessageType object.","title":"MemberRequestType"},{"location":"graphql/type/#messageabletype","text":"The MessageableType is a GraphQL union type that represents a user or a staff member who may send a MemberRequest message. It is composed of the UserType and StaffMemberType types and defines a resolve_type method that determines which of these types an object belongs to. When a member request message is queried, this union type is used to determine whether the sender is a user or a staff member and return the appropriate type. This allows the GraphQL API to return a consistent shape of data for messages sent by either type of messageable.","title":"MessageableType"},{"location":"graphql/type/#moodtype","text":"The MoodType is a GraphQL object type that represents a mood. It has three fields: userId : This is the ID of the user who has the mood. description : This is a description of the mood. user : This is the user who has the mood. This object type is used to query for moods and get information about them. It is likely used in a GraphQL query or mutation to get or set the mood of a user.","title":"MoodType"},{"location":"graphql/type/#mutationtype","text":"The MutationType is an object type in GraphQL that defines a set of fields that a client can mutate (create, update, delete) on the server. In this case, the MutationType has four fields: staffLogin: This field accepts input and returns a staff member's token if the login is successful. It is implemented using the StaffLogin Resolver. createInteraction: This field accepts input and creates a new interaction record. It is implemented using the CreateInteractionResolver. updateMemberRequest: This field accepts input and updates a member request record. It is implemented using the UpdateMemberRequestResolver. sendMemberRequestMessage: This field accepts input and creates a new member request message record. It is implemented using the SendMemberRequestMessageResolver. readMemberRequest: This field accepts input and marks a member request as read. It is implemented using the ReadMemberRequestResolver.","title":"MutationType"},{"location":"graphql/type/#partnerinteractiontype","text":"It is a subclass of the BaseObject class and represents a partner interaction. It has two fields: label, a string that is required and non-null, and value, a string that is required and non-null. This object type can be used in a GraphQL schema to define a type for partner interactions. The label and value fields can be used to represent the name and value of the interaction respectively.","title":"PartnerInteractionType"},{"location":"graphql/type/#phototype","text":"It represents a photo and has several fields: id, a required ID field; previewUrl, a required string field that maps to the member_id property; largeUrl, a required string field that is resolved using the large URL of the image object; thumbUrl, a required string field that is resolved using the thumb URL of the image object; and previewUrl, a required string field that is resolved using the preview_data value of the image object. This object type can be used in a GraphQL schema to define a type for photos. The id field represents the ID of the photo, the previewUrl field represents the URL for the preview of the photo, the largeUrl and thumbUrl fields represent the URLs for the large and thumbnail versions of the photo respectively, and the previewUrl field represents the URL for the preview data of the photo.","title":"PhotoType"},{"location":"graphql/type/#preferencegrouptype","text":"It takes in two arguments: memberRequestId and body, both of which are required. The memberRequestId argument is the ID of the member request to which the message is being sent, and the body argument is the contents of the message. This function returns an object of type MemberRequestMessageType, which represents a message sent in response to a member request. The function first calls the MemberRequests::Message command, passing in the memberRequestId, body, and the current_user from the context. If the command is successful, the function returns the result of the command. If the command is not successful, it raises a GraphQL execution error with the command's errors.","title":"PreferenceGroupType"},{"location":"graphql/type/#querytype","text":"This GraphQL query type defines fields that can be queried by the client. Each field has a name, a type, and a resolve function that specifies how to retrieve the data for that field. The branches field returns an array of BranchType objects and is only accessible to users with the manager token context. It retrieves the branches for the current user's organization if the user is an admin, or the branches assigned to the user if they are a branch manager. The currentBranch field returns a single BranchType object and is only accessible to users with the staff token context. It retrieves the current branch of the user. The roles field returns an array of RoleType objects and is only accessible to users with the manager token context and a current branch. It retrieves the roles for the current user's branch. The staffMembers field returns an array of StaffMemberType objects and is only accessible to users with the manager token context, a current branch, and a current role. It retrieves the staff members for the current user's branch and role. The user field returns a single UserType object and is only accessible to users with the staff token context and a current branch. It takes an id argument and retrieves the user with the matching id in the current user's branch. The users field returns an array of UserType objects and is only accessible to users with the staff token context and a current branch. It takes optional search, before, and limit arguments and retrieves users in the current user's branch, filtered by the search term, limited to those before a certain id, and limited to the specified number. The nearbyUsers field returns an array of UserType objects and is only accessible to users with the staff token","title":"QueryType"},{"location":"graphql/type/#questiontype","text":"The QuestionType is a GraphQL object type that represents a question in the system. It has fields for the id, title, kind, and lockingConditions of the question, as well as a field for the allowsNote property. The allowsNote field represents whether the question allows for a note to be added. The QuestionType also has a field called userAnswer, which represents the answer given by a specific user to the question. This field takes an argument of userId, which is the ID of the user for which the answer is being retrieved. The userAnswer field is resolved using a lambda function that fetches the user answer from the user_answers association of the Question object. The QuestionType is used to represent a question in the GraphQL API and is typically used in queries to retrieve information about questions.","title":"QuestionType"},{"location":"graphql/type/#roletype","text":"The RoleType is a GraphQL object type that represents a role within an organization. It contains fields such as id, name, interactions, preferenceStructure, and topQuestions. The preferenceStructure field is commented out and replaced with an alternative field. This type also has a resolve function that is commented out. This function appears to be generating image URLs for small and large sizes, and returning an object with information about the height, source, and width of the images. This object is likely used to provide the client with information about the image to be displayed.","title":"RoleType"},{"location":"graphql/type/#shareauthorisetype","text":"The ShareAuthoriseType is a GraphQL object type that represents the result of an authorization to share user data with a partner app. It has a single field, user, which is of the UserType object type and is required. This field represents the user whose data has been authorized for sharing.","title":"ShareAuthoriseType"},{"location":"graphql/type/#sharerevoketype","text":"The ShareRevokeType is a GraphQL object type that represents a share that has been revoked. It has two fields: user: This is an instance of the UserType object and represents the user whose share has been revoked. revoked_at: This field represents the date and time at which the share was revoked. It is an instance of the DateTimeType and is not nullable. This object type is likely used to represent the result of a GraphQL mutation that revokes a share. It allows the client to get information about the user whose share was revoked and when the share was revoked.","title":"ShareRevokeType"},{"location":"graphql/type/#sharetype","text":"The ShareType GraphQL object type represents a share. It has fields for the ID of the branch and user, the status of the share, the method through which the share was made (via), and the timestamps for when the share was created and updated. It also has fields for the user and branch objects related to the share, as well as the timestamps for when the share was authorized and revoked.","title":"ShareType"},{"location":"graphql/type/#staffmembertype","text":"The StaffMemberType GraphQL object type represents a staff member. It has fields for the ID, employee ID, name, and first and last names of the staff member.","title":"StaffMemberType"},{"location":"graphql/type/#subscriptiontype","text":"The SubscriptionType GraphQL object type defines several fields for subscriptions that a client can subscribe to in order to receive updates in real-time. The shareChanged field will emit an update when a user shares or revokes their profile with another user. The type of the update is ShareType, and the subscription scope is limited to the current branch ID. The moodChanged field will emit an update when a user updates their mood. The type of the update is MoodType, and the subscription scope is limited to the current branch ID. The newMessage field will emit an update when a user sends a new message in a member request. The type of the update is MemberRequestMessageType, and the subscription scope is limited to the current user ID. The newMemberRequest field will emit an update when a user submits a new member request. The type of the update is MemberRequestType, and the subscription scope is limited to the current user ID. The requestCountChanged field will emit an update when a user's request count changes for a branch. The type of the update is MemberRequestType, and the subscription scope is limited to the current branch ID.","title":"SubscriptionType"},{"location":"graphql/type/#timetype","text":"The TimeType is a GraphQL scalar type that represents a specific point in time. It is defined to parse input values as a Time object in the application's time zone, and to output the result as a formatted string in UTC time, in the format '%H:%M' (hours and minutes). This allows clients to send and receive time values in a standard format, while allowing the server to store and manipulate them in the time zone it is configured to use.","title":"TimeType"},{"location":"graphql/type/#tokentype","text":"The TokenType GraphQL object type represents an authentication token for a user. It has a single field, token, which is a string representing the token. This type is likely used in the context of a GraphQL mutation or query that allows a user to authenticate with a token in order to access certain resources.","title":"TokenType"},{"location":"graphql/type/#useranswertype","text":"The UserAnswerType is a GraphQL object type that represents a user's answer to a question. It has fields for the id, userId, questionId, note, and values of the answer, as well as timestamps for when the answer was created and last updated. It also has a field for linkedCategories, which returns an array of categories that are linked to the user's answer through their visibility conditions. The linkedCategories field is resolved by querying the Category model for categories whose visibility conditions match the user's answer.","title":"UserAnswerType"},{"location":"graphql/type/#usertype","text":"The UserType is a GraphQL object type that represents a user. It has several fields, including: id: the ID of the user, represented as a string memberId: the ID of the user's member, represented as a string firstName: the first name of the user, represented as a string lastName: the last name of the user, represented as a string name: the full name of the user, represented as a string sharedAt: the date and time when the user shared their profile with the current branch, represented as a DateTime object mood: the mood of the user, represented as a string checkIn: the current check-in of the user at the current branch, represented as a CheckInType object photo: the photo of the user, represented as a PhotoType object jobTitle: the job title of the user, represented as a string company: the company the user works for, represented as a string address: the address of the user, represented as a string gender: the gender of the user, represented as a string personality: the personality traits of the user, represented as a JSON object requestCount: the number of open and pending member requests the user has at the current branch, represented as an integer","title":"UserType"},{"location":"models/","text":"Models Folder structure \u251c\u2500\u2500\u2500models \u251c\u2500\u2500\u2500concerns \u251c\u2500\u2500\u2500personality \u2514\u2500\u2500\u2500versions Address The Address model represents an address in the system. It has the following attributes: id (integer): a unique ID for the address label (string): a label or nickname for the address line1 (string): the first line of the address line2 (string): the second line of the address town (string): the town or city where the address is located county (string): the county or region where the address is located postcode (string): the postal code for the address country (string): the country where the address is located phone (string): a phone number associated with the address latitude (decimal): the latitude of the address longitude (decimal): the longitude of the address addressable_type (string): the type of model that the address belongs to** (e.g. \"User\" or \"Company\") addressable_id (integer): the ID of the model that the address belongs to created_at (datetime): the date and time that the address was created updated_at (datetime): the date and time that the address was last updated city_id (integer): the ID of the city where the address is located The Address model has the following relationships: belongs_to :addressable, polymorphic: true: this indicates that the address belongs to a parent model, and the addressable_type and addressable_id attributes are used to specify which model the address belongs to. The polymorphic option indicates that the parent model can be any type of model, and the inverse_of: :address option specifies the name of the has_one or has_many association on the parent model. belongs_to :city: this indicates that the address belongs to a city. The city_id attribute is used to specify which city the address belongs to. The Address model has the following custom methods: country_name: this method returns the name of the country for the address. It uses the ISO3166 gem to look up the name of the country based on the country attribute. country_code: this method returns the country code for the address. It simply returns the value of the country attribute. Here are some examples of how the Address model might be used: # Find all addresses for a user user = User.find(123) addresses = user.addresses # Find the nearest address to a given location latitude = 37.774929 longitude = -122.419416 radius = 5 # miles addresses = Address.within(radius, origin: [latitude, longitude]) # Find the address for a specific user user = User.find(123) address = user.address # Set the address for a user user = User.find(123) Admin The following are the Attributes of Admin: id : bigint, primary key for the model email : string, the email address of the admin first_name : string, the first name of the admin last_name : string, the last name of the admin mobile_number : string, the mobile phone number of the admin encrypted_password : string, a hashed version of the admin's password reset_password_token : string, a token used for resetting the admin's password reset_password_sent_at : datetime, the time at which the reset password token was sent remember_created_at : datetime, the time at which the admin selected the \"remember me\" option during login sign_in_count : integer, the number of times the admin has signed in current_sign_in_at : datetime, the time at which the admin signed in during the current session last_sign_in_at : datetime, the time at which the admin signed in during the previous session current_sign_in_ip : inet, the IP address of the admin during the current session last_sign_in_ip : inet, the IP address of the admin during the previous session authentication_token : string, a token used for authenticating the admin created_at : datetime, the time at which the admin's record was created updated_at : datetime, the time at which the admin's record was last updated organisation_id : bigint, the ID of the organization to which the admin belongs type : string, the type of staff member (in this case, \"Admin\") employee_id : string, the employee ID of the admin confirmation_token : string, a token used for confirming the admin's email address confirmed_at : datetime, the time at which the admin's email address was confirmed confirmation_sent_at : datetime, the time at which the confirmation token was sent suspended_at : datetime, the time at which the admin's access was suspended archived_at : datetime, the time at which the admin's record was archived encrypted_pin : string, a hashed version of the admin's PIN (personal identification number) unconfirmed_email : string, the unconfirmed email address of the admin (if the admin has requested a change to their email address) Inherits from StaffMember model Custom methods: None Examples of usage: An instance of the Admin model could represent a staff member with administrative privileges within an organization. The email, password, and authentication token attributes could be used for authenticating the admin when logging in to the system. The sign_in_count, current_sign_in_at, and last_sign_in_at attributes could be used for tracking the admin's login history. Answer Attributes: id (integer): The primary key for the model. question_id (integer): The ID of the question that the answer belongs to. title (text): The title of the answer. description (text): A description of the answer. created_at (datetime): The timestamp for when the answer was created. updated_at (datetime): The timestamp for when the answer was last updated. position (integer): The position of the answer within its parent question. Relationships: question (belongs_to): The question that the answer belongs to. photo (has_one): The photo associated with the answer. Custom methods: siblings : Returns the other answers within the same question as the current answer. reject_photo? : Determines whether a photo should be rejected when creating or updating an answer. set_position : Sets the position of the answer within its parent question. Examples of usage: # Create a new answer with a title and description answer = Answer.new(title: 'Yes', description: 'The answer is yes') # Set the question that the answer belongs to answer.question = Question.first # Save the answer answer.save # Update the title of the answer answer.title = 'Yes, definitely' answer.save # Delete the answer answer.destroy ApplicationRecord Attributes: None. ApplicationRecord is an abstract base class and does not have any attributes of its own. Relationships: None. ApplicationRecord is an abstract base class and does not have any relationships of its own. Custom methods: updated_since(datetime): Returns all records that have been updated since the specified datetime. pluck_to_hash(*keys): Returns an array of hashes, where each hash represents a record in the database with keys corresponding to the specified attributes. Examples of usage: # Find all records in the database that have been updated since yesterday ApplicationRecord.updated_since(1.day.ago) # Retrieve the IDs and titles of all records in the database ApplicationRecord.pluck_to_hash(:id, :title) Note: ApplicationRecord is an abstract base class and cannot be instantiated directly. Instead, you will need to use a concrete subclass of ApplicationRecord (such as Answer, Question, etc.) to create and manipulate records in the database. ArticleContentCategory Attributes: id (integer): The primary key for the model. article_id (integer): The ID of the article that the content category belongs to. content_category_id (integer): The ID of the content category. created_at (datetime): The timestamp for when the article content category was created. updated_at (datetime): The timestamp for when the article content category was last updated. Relationships: article (belongs_to): The article that the content category belongs to. content_category (belongs_to): The content category. Custom methods: None. Examples of usage: # Create a new article content category article_content_category = ArticleContentCategory.new # Set the article and content category that the article content category belongs to article_content_category.article = Article.first article_content_category.content_category = ContentCategory.first # Save the article content category article_content_category.save # Delete the article content category article_content_category.destroy Article Attributes: id (integer): The primary key for the model. title (string): The title of the article. content (text): The content of the article. publish_at (datetime): The timestamp for when the article should be published. created_at (datetime): The timestamp for when the article was created. updated_at (datetime): The timestamp for when the article was last updated. notification_job_id (integer): The ID of the job used to send notifications when the article is published. Relationships: header_image (has_one): The header image for the article. photos (has_many): The photos associated with the article. article_content_categories (has_many): The article content categories associated with the article. content_categories (has_many): The content categories associated with the article. Custom methods: header_image=(header_image) : Sets the header image for the article. publish_at=(publish_at) : Sets the publish timestamp for the article. published? : Returns true if the article has been published, false otherwise. status : Returns the current status of the article. self.start_draft : Creates a new draft article. Examples of usage: # Create a new article article = Article.new # Set the title and content of the article article.title = 'My article' article.content = 'This is the content of my article' # Set the publish timestamp for the article article.publish_at = 1.day.from_now # Save the article article.save # Check if the article has been published article.published? # Get the status of the article article.status # Delete the article article.destroy AuthenticationToken The AuthenticationToken model represents a token that is used to authenticate a user. It belongs to a polymorphic user, which means that it can belong to any model that includes the User module. Attributes: id : a unique identifier for the token (integer, primary key) context : the context in which the token is used (string) body : the actual token (string) user_type : the type of the user that the token belongs to (string) user_id : the ID of the user that the token belongs to (integer) last_used_at : the last time the token was used (datetime) ip_address : the IP address from which the token was last used (inet) user_agent : the user agent string from the device that used the token last (string) created_at : the time the token was created (datetime) updated_at : the time the token was last updated (datetime) Relationships: user : the user that the token belongs to (polymorphic association) Custom methods: decode : decodes a token from the headers find_for_context : finds a token for a given context and token body create_and_return_staff_token : creates a new staff token and returns it create_and_return_manager_token : creates a new manager token and returns it create_and_return_token : creates a new token for a given context and returns it create_and_return_analytics_token : creates and returns an analytics token Examples of usage: To create a new staff token for a user: token = AuthenticationToken.create_and_return_staff_token(current_user, request) To find a token for a given context and token body: token = AuthenticationToken.find_for BranchCategorisation The BranchCategorisation model represents the many-to-many relationship between branches and partner categories. This allows a branch to be associated with one or more partner categories, and a partner category to be associated with one or more branches. Attributes: id : A unique identifier for the branch categorisation record, stored as an integer and generated automatically by the database. branch_id : The ID of the branch that is associated with a partner category, stored as an integer. partner_category_id : The ID of the partner category that is associated with a branch, stored as an integer. created_at : A timestamp indicating when the branch categorisation record was created, stored as a datetime. updated_at : A timestamp indicating when the branch categorisation record was last updated, stored as a datetime. Relationships: belongs_to : A branch categorisation belongs to a single branch and a single partner category. branch : This relationship specifies the branch that is associated with a partner category. partner_category : This relationship specifies the partner category that is associated with a branch. Custom methods: There are no custom methods defined for the BranchCategorisation model. Examples of usage: Creating a new branch categorisation: branch = Branch.first partner_category = PartnerCategory.first branch_categorisation = BranchCategorisation.new(branch: branch, partner_category: partner_category) branch_categorisation.save Retrieving all branch categorisations for a particular branch: branch = Branch.first branch_categorisations = branch.branch_categorisations Retrieving all branches that belong to a particular partner category: partner_category = PartnerCategory.first branches = partner_category.branches Removing a branch categorisation: branch_categorisation = BranchCategorisation.first branch_categorisation.destroy BranchManager The BranchManager model is a subclass of the StaffMember model and represents a staff member who is a branch manager at an organisation. attributes: id : a bigint that serves as the primary key for the model email : a string that stores the email address of the staff member first_name : a string that stores the first name of the staff member last_name : a string that stores the last name of the staff member mobile_number : a string that stores the mobile phone number of the staff member encrypted_password : a string that stores the encrypted password of the staff member reset_password_token : a string that stores a token used to reset the staff member's password reset_password_sent_at : a datetime that stores the time at which the reset password token was sent to the staff member remember_created_at : a datetime that stores the time at which the staff member requested to be remembered on the device they are using sign_in_count : an integer that stores the number of times the staff member has signed in current_sign_in_at : a datetime that stores the time at which the staff member last signed in last_sign_in_at : a datetime that stores the time at which the staff member signed in before the last time they signed in current_sign_in_ip : an inet data type that stores the IP address the staff member is currently signed in from last_sign_in_ip : an inet data type that stores the IP address the staff member last signed in from authentication_token : a string that stores a unique token used for authentication purposes created_at : a datetime that stores the time at which the staff Relationships: BranchManager has a one-to-many relationship with Branch through the branches association. Custom methods: assigned_branches: returns a collection of branches that the branch manager is assigned to. Examples of usage: # Find a branch manager by their email and assign them to a branch manager = BranchManager.find_by(email: 'branch_manager@example.com') branch = Branch.find(1) manager.branches << branch # Find all the branches that a branch manager is assigned to manager = BranchManager.find(1) manager.assigned_branches Branch Attributes: id : integer, primary key business_unit_id : integer name : string created_at : datetime updated_at : datetime email : string telephone : string archived_at : datetime image : string branch_info : string booking_url : string vista_partner : boolean, default: false ratings_count : integer, default: 0 Relationships: business_unit : belongs to a BusinessUnit organisation : has one Organisation through the BusinessUnit photo : has one Photo as owner address : has one Address as addressable staff_assignments : has many StaffAssignments as target staff_members : has many StaffMembers through StaffAssignments shares : has many Shares users : has many Users through Shares with the condition that the Share is authorised branch_categorisations : has many BranchCategorisations categories : has many PartnerCategories through BranchCategorisations interactions : has many Interactions roles : has many Roles through the BusinessUnit check_ins : has many CheckIns member_requests : has many MemberRequests member_request_messages : has many MemberRequestMessages as messageable Custom methods: category_titles : returns an array of the titles of the categories associated with the branch destroy_staff : destroys the staff members associated with the branch BusinessUnit Attributes: id : integer, primary key name : string organisation_id : integer, foreign key to the organisations table created_at : datetime updated_at : datetime archived_at : datetime Relationships: belongs_to :organisation has_many :branches has_many :roles has_many :member_request_types Custom methods: None Examples of usage: Fetch all business units belonging to a particular organisation: organisation = Organisation.find(1) business_units = organisation.business_units Fetch all branches belonging to a particular business unit: business_unit = BusinessUnit.find(1) branches = business_unit.branches Fetch all roles belonging to a particular business unit: business_unit = BusinessUnit.find(1) roles = business_unit.roles Fetch all member request types belonging to a particular business unit: business_unit = BusinessUnit.find(1) member_request_types = business_unit.member_request_types CategoryUpdate Attributes: id : integer category_id : integer question_ids : array of integers created_at : datetime updated_at : datetime Relationships: belongs_to :category Custom methods : title : returns the title of the associated category photo : returns the photo of the associated category questions : returns an array of Question objects that have an id in the question_ids attribute Examples of usage: Find the category update with id 1 update = CategoryUpdate.find(1) Access the title of the associated category update.title Access the photo of the associated category update.photo Access the questions associated with this update update.questions Category It has the following attributes: id : a unique identifier for the update, stored as a bigint category_id : a foreign key referencing the category that this update is for question_ids : an array of integers representing the question IDs that are associated with this update created_at : a timestamp for when the update was created updated_at : a timestamp for when the update was last updated It has the following relationships: belongs_to :category : indicates that each category update belongs to a single category It has the following custom methods: title : returns the title of the category that this update is for. If the category's title is \"general\" and it has a parent, the parent's title is returned instead. photo : returns the photo of the category that this update is for. questions: returns a collection of Question objects that are associated with this update. Here is an example of how the CategoryUpdate model could be used: Find a category update by its ID update = CategoryUpdate.find(1) Access the title of the update's category puts update.title Access the questions associated with the update questions = update.questions CheckIn The CheckIn model represents a check-in by a user to a branch in the application. It has the following attributes: id : a unique identifier for the check-in, stored as a bigint user_id : a foreign key referencing the user who checked in branch_id : a foreign key referencing the branch that the user checked in to arrival_date : a date representing the date on which the user checked in arrival_time_start : a time representing the start time of the user's check-in arrival_time_end : a time representing the end time of the user's check-in created_at : a timestamp for when the check-in was created updated_at : a timestamp for when the check-in was last updated It has the following relationships: belongs_to :user, touch: true : indicates that each check-in belongs to a single user, and the updated_at timestamp of the user will be updated whenever this check-in is saved. belongs_to :branch: indicates that each check-in belongs to a single branch It has the following custom methods: earliest : a scope that orders check-ins by their arrival_date in ascending order. future: a scope that filters check-ins to only include those with an arrival_date in the future. for_branch: a scope that filters check-ins to only include those for a particular branch. Here is an example of how the CheckIn model could be used: Find a user by their ID user = User.find(1) Find a branch by its ID branch = Branch.find(1) Create a new check-in for the user at the branch check_in = CheckIn.new(user: user, branch: branch, arrival_date: Date.today, arrival_time_start: Time.now) Save the check-in check_in.save Find all future check-ins for a particular branch future_check_ins = CheckIn.for_branch(branch).future City The City model represents a city in the application. It has the following attributes: id : a unique identifier for the city, stored as a bigint name : the name of the city created_at : a timestamp for when the city was created updated_at : a timestamp for when the city was last updated status : a string representing the status of the city, with possible values of \"enabled\", \"disabled\", and \"coming_soon\" It has the following relationships: HasPhoto : indicates that the City model includes the HasPhoto module, which provides it with the ability to have a photo associated with it. It has the following custom methods: to_s : returns the name of the city as a string. It also has the following scopes: default_scope : orders cities by their name in ascending order. not_disabled : filters cities to only include those with a status of \"enabled\" or \"coming_soon\". Here is an example of how the City model could be used: Find a city by its ID city = City.find(1) Access the name of the city puts city.name Update the status of the city city.status = \"disabled\" city.save Find all cities that are not disabled cities = City.not_disabled ContentCategory The ContentCategory model represents a category for organizing content (e.g. articles, videos) in the application. It has the following attributes: id : a unique identifier for the content category, stored as a bigint name : the name of the content category created_at : a timestamp for when the content category was created updated_at : a timestamp for when the content category was last updated It has the following relationships: has_many :article_content_categories, dependent: :destroy: indicates that each content category can have many associations with articles through the article_content_categories join table, and these associations will be destroyed if the content category is deleted. has_many :articles, through: :article_content_categories : indicates that a content category can have many articles associated with it through the article_content_categories join table. has_many :video_content_categories, dependent: :destroy : indicates that each content category can have many associations with videos through the video_content_categories join table, and these associations will be destroyed if the content category is deleted. has_many :videos, through: :video_content_categories : indicates that a content category can have many videos associated with it through the video_content_categories join table. Here is an example of how the ContentCategory model could be used: Find a content category by its ID category = ContentCategory.find(1) Access the name of the category puts category.name Find all articles in the category articles = category.articles Find all videos in the category videos = category.videos Create a new article and associate it with the category article = Article.new(title: \"New Article\") article.content_categories << category article.save DataImport The DataImport model represents an import of data from a file (e.g. a spreadsheet) in the application. It has the following attributes: id : a unique identifier for the data import, stored as a bigint file : a string representing the file that was imported, stored as a file on the filesystem status : a string representing the status of the data import, with possible values of \"new\", \"running\", \"finished\", and \"failed\" log : a text field that stores log messages for the data import finished_at : a timestamp for when the data import finished created_at : a timestamp for when the data import was created updated_at : a timestamp for when the data import was last updated options : a JSONB field that stores options for the data import, including whether to import categories, questions, locking conditions, and visibility conditions The DataImport model has the following relationships: mount_uploader :file, FileUploader : indicates that the file attribute is a file that is managed by the FileUploader uploader. It has the following custom methods: filename : returns the filename of the imported file as a string. import_all : performs the data import, updating the status of the data import to \"running\" and setting it to \"finished\" or \"failed\" upon completion. This method also broadcasts the status of the data import to a channel on the Action Cable server. import_categories : imports categories from the data import file. import_questions : imports questions from the data import file. update_visibility_conditions : updates visibility conditions for questions in the data import file. update_locking_conditions : updates locking conditions for questions in the data import file. categories_spreadsheet : returns a Spreadsheet object for the categories sheet in the data import file. questions_spreadsheet : returns a Spreadsheet object for the questions sheet in the data import file. visibility_conditions_spreadsheet : returns a Spreadsheet object for the visibility conditions sheet in the data import file. locking_conditions_spreadsheet : returns a Spreadsheet object for the locking conditions sheet in the data import file. Here is an example of how the DataImport model could be used: Create a new data import with a file and options data_import = DataImport.new(file: params[:file], options: { categories: true, questions: true }) Save the data import and perform the import if data_import.save data_import.import_all end Find all data imports ordered by the most recently created data_imports = DataImport.all Device The Device model represents a device that a user has used to sign in to the application. It has the following attributes: id : a unique identifier for the device, stored as a bigint user_id : a foreign key for the user associated with the device platform : a string representing the platform of the device (e.g. \"ios\" or \"android\") token : a string representing a unique token for the device created_at : a timestamp for when the device was created updated_at : a timestamp for when the device was last updated It has the following relationships: belongs_to :user : indicates that each device belongs to a single user. It has the following custom methods: ios? : returns true if the platform of the device is \"ios\", false otherwise. android?: returns true if the platform of the device is \"android\", false otherwise. Here is an example of how the Device model could be used: Find a device by its token device = Device.find_by(token: params[:token]) Check if the device is an iOS device if device.ios? # Do something end Create a new device for a user device = Device.new(user: current_user, platform: params[:platform], token: params[:token]) Save the device device.save Feed The Feed model is a serializable model that represents a feed of content for a user. It has the following attributes: articles : an array of articles to be included in the feed interactions : an array of interactions to be included in the feed category_updates : an array of category updates to be included in the feed videos : an array of videos to be included in the feed It does not have any relationships or custom methods. Here is an example of how the Feed model could be used: Initialize a new feed with arrays of articles, interactions, category updates, and videos feed = Feed.new(articles: articles, interactions: interactions, category_updates: category_updates, videos: videos) Render the feed as JSON using a serializer render json: feed Ignore The Ignore model represents a relationship between a user and a category where the user has indicated that they do not want to receive notifications for updates to the category. It has the following attributes: id : a unique identifier for the ignore relationship, stored as a bigint user_id : a foreign key for the user associated with the ignore relationship category_id : a foreign key for the category associated with the ignore relationship created_at : a timestamp for when the ignore relationship was created updated_at : a timestamp for when the ignore relationship was last updated It has the following relationships: belongs_to :user : indicates that each ignore relationship belongs to a single user. belongs_to :category : indicates that each ignore relationship belongs to a single category. It does not have any custom methods. Here is an example of how the Ignore model could be used: Create a new ignore relationship between a user and a category ignore = Ignore.new(user: current_user, category: category) Save the ignore relationship ignore.save Find all the categories that a user is ignoring ignored_categories = Ignore.where(user: current_user).includes(:category) Interaction The Interaction model represents a user interaction with a staff member, branch, or category. These interactions can be of different types, such as a recommendation or booking a taxi. Attributes: id : a unique identifier for the interaction user_id : the ID of the user who is interacting staff_member_id : the ID of the staff member involved in the interaction branch_id : the ID of the branch involved in the interaction category_id : the ID of the category involved in the interaction description : a description of the interaction created_at : the date and time that the interaction was created updated_at : the date and time that the interaction was last updated type : the type of interaction Relationships: belongs_to :user : the interaction belongs to a user belongs_to :staff_member : the interaction may involve a staff member belongs_to :branch : the interaction may involve a branch belongs_to :category : the interaction may involve a category Custom methods: mood? : returns a boolean indicating whether the interaction is a mood type partner_type? : returns a boolean indicating whether the interaction is a partner type (i.e. a type that involves a staff member or branch) Examples of usage: Retrieving a list of interactions for a particular user: Interaction.where(user_id: user.id) Retrieving a list of mood interactions for today: Interaction.where(type: 'mood').for_today MemberRequestMessage The MemberRequestMessage model represents a message sent within a MemberRequest conversation between a staff member and a user. Attributes: id (integer) : The unique identifier for the message. body (text) : The content of the message. status (string) : The current status of the message, which can be pending, sent, or read. member_request_id (integer) : The identifier for the MemberRequest conversation to which the message belongs. messageable_id (integer) : The identifier for the user or staff member who sent the message. messageable_type (string) : The type of the sender, either User or StaffMember. created_at (datetime) : The timestamp when the message was created. updated_at (datetime) : The timestamp when the message was last updated. Relationships: belongs_to member_request : The MemberRequest conversation to which the message belongs. belongs_to messageable (polymorphic) : The user or staff member who sent the message. Custom methods: mark_as_read : Changes the status attribute to read. mark_as_unread : Changes the status attribute to pending. mark_as_sent : Changes the status attribute to sent. read? : Returns a boolean indicating whether the status attribute is read. Examples of usage: Create a new message: mr = MemberRequest.first message = MemberRequestMessage.new(body: 'Hello, how are you doing?', member_request: mr, messageable: staff_member) message.save Mark a message as read: message = MemberRequestMessage.first message.mark_as_read! Check if a message has been read: message = MemberRequestMessage.first message.read? Get all unread messages sent by staff members: MemberRequestMessage.from_staff_member.unread MemberRequestTypeAssignment The MemberRequestTypeAssignment model represents a many-to-many relationship between Role and MemberRequestType models. It allows the assignment of one or more roles to a member request type, indicating which staff members are responsible for handling member requests of that type. Attributes: id (integer) : the primary key for the model. role_id (integer) : the foreign key for the Role model, indicating the role being assigned to the member request type. member_request_type_id (integer) : the foreign key for the MemberRequestType model, indicating the member request type being assigned to the role. created_at (datetime) : the timestamp for when the record was created. updated_at (datetime) : the timestamp for when the record was last updated. Relationships: belongs_to : the MemberRequestTypeAssignment model belongs to both the Role and MemberRequestType models. Custom methods: None. Examples of usage: Assign the 'customer_service' role to the 'booking' member request type member_request_type = MemberRequestType.find_by(name: 'booking') role = Role.find_by(name: 'customer_service') assignment = MemberRequestTypeAssignment.create(member_request_type: member_request_type, role: role) Get the member request types assigned to the 'customer_service' role role = Role.find_by(name: 'customer_service') member_request_types = role.member_request_types MemberRequestType The MemberRequestType model represents a type of request that can be made by a member (user) to staff members in an organisation. Attributes: id : a unique identifier for the request type (integer, primary key) name : the name of the request type (string) business_unit_id : the unique identifier of the business unit to which the request type belongs (integer) created_at : the date and time at which the request type was created (datetime) updated_at : the date and time at which the request type was last updated (datetime) archived_at : the date and time at which the request type was archived (datetime) Relationships: business_unit : a belongs-to relationship with the BusinessUnit model. A request type belongs to a single business unit. organisation : a has-one-through relationship with the Organisation model. A request type has a single organisation through its business unit. member_request_type_assignments : a has-many relationship with the MemberRequestTypeAssignment model. A request type has many type assignments. roles : a has-many-through relationship with the Role model. A request type has many roles through its type assignments. staff_members : a has-many-through relationship with the StaffMember model. A request type has many staff members through its roles. Custom methods: acts_as_paranoid : this is a method provided by the ActsAsParanoid gem which allows the request type to be \"soft deleted\" by setting the archived_at attribute to the current date and time. This allows the request type to be restored if necessary. Examples of usage: Creating a new request type: request_type = MemberRequestType.new(name: 'Booking assistance') request_type.business_unit = BusinessUnit.first request_type.save MemberRequest Description: This model represents a request made by a member (user) to the staff of a branch. It has a type (e.g. booking, service request, etc.) and a status (open, pending, closed). The request can be composed of multiple messages exchanged between the member and the staff. Attributes: id : a unique identifier for the request (integer, primary key) user_id : the id of the member who made the request (integer, foreign key to the users table) branch_id : the id of the branch where the request was made (integer, foreign key to the branches table) member_request_type_id: the id of the type of request (integer, foreign key to the member_request_types table) status : the current status of the request (string, can be \"open\", \"pending\", or \"closed\") created_at : the timestamp for when the request was created (datetime) updated_at : the timestamp for when the request was last updated (datetime) last_message_sent_at : the timestamp for when the last message was sent for this request (datetime) Relationships: belongs_to :user belongs_to :branch belongs_to :member_request_type has_many :member_request_messages, dependent: :destroy Custom methods: mark_as_unread : marks the last message from the member as unread. Examples of usage: Create a new member request: request = MemberRequest.new(user_id: 1, branch_id: 2, member_request_type_id: 3, status: \"open\") request.member_request_messages.build(body: \"Hi, I would like to book a table for two on Friday at 7pm.\", messageable_type: \"User\") request.save Find all open member requests for a specific branch: requests = MemberRequest.for_branch(2).in_status(\"open\") Find all member requests for a specific member: requests = MemberRequest.for_member(1) Find all member requests with a specific message: requests = MemberRequest.with_message(5) Notification The Notification model represents a notification that can be sent to a user. It can be associated with a specific object, such as a Branch or MemberRequestMessage, through a polymorphic association. Attributes: user_id : The ID of the user who will receive the notification. type : The type of notification, represented as a string. response : A JSONb field that can store a response from the user to the notification. object_type : The type of object that the notification is associated with, stored as a string. object_id : The ID of the object that the notification is associated with. created_at : The timestamp when the notification was created. updated_at : The timestamp when the notification was last updated. read_at : The timestamp when the notification was marked as read by the user. responded_at : The timestamp when the user responded to the notification. Relationships: belongs_to :user : The user who will receive the notification. belongs_to :object, polymorphic: true: The object that the notification is associated with. Custom methods: human_type : Returns the type of the notification in a human-readable format (e.g. \"new_message\" for Notification::NewMessage). mark_as_read : Marks the notification as read by updating the read_at attribute. self.mark_all_read: Marks all notifications as read for the current user by updating the read_at attribute. name : Returns the name of the object that the notification is associated with, or the name of the branch if the object is a MemberRequestMessage. Examples of usage: Create a new notification notification = Notification::NewMessage.create!(user: user, object: member_request_message) Mark a notification as read notification.mark_as_read Mark all notifications as read for a user Notification.where(user: user).mark_all_read Find unread notifications for a user unread_notifications = Notification.where(user: user).unread Organisation The Organisation model represents a company or organization in the system. It has the following attributes: id : a unique identifier for the organisation, stored as a big integer and generated automatically by the database. name : a string containing the name of the organization. This attribute is required. about : a text field containing information about the organization. archived_at : a datetime field containing the date and time at which the organization was archived. If the organization has not been archived, this field is nil. The Organisation model has the following relationships: address : a one-to-one relationship with the Address model, representing the address of the organization. photo : a one-to-one relationship with the Photo model, representing a photo of the organization. staff_members : a one-to-many relationship with the StaffMember model, representing the staff members of the organization. branch_managers : a one-to-many relationship with the BranchManager model, representing the branch managers of the organization. admins : a one-to-many relationship with the Admin model, representing the administrators of the organization. business_units : a one-to-many relationship with the BusinessUnit model, representing the business units within the organization. branches : a many-to-many relationship with the Branch model, through the BusinessUnit model, representing the branches that belong to the organization. roles : a many-to-many relationship with the Role model, through the BusinessUnit model, representing the roles that exist within the organization. videos : a one-to-many relationship with the Video model, representing the videos associated with the organization. The Organisation model has the following custom methods: reject_photo?(attributes) : a private method used to determine whether a photo should be rejected when creating or updating an organization. It returns true if the image attribute of the attributes parameter is blank, and false otherwise. An example of usage for the Organisation model could be: Create a new organization org = Organisation.new(name: \"My Organization\") PartnerCategory The PartnerCategory model represents categories for partners in the system. A partner can belong to multiple categories and each category can have multiple partners. Attributes: id : a unique identifier for the partner category (integer, primary key) title : the name of the partner category (string) position : the position of the partner category in a list (integer) created_at : the timestamp when the partner category was created (datetime) updated_at : the timestamp when the partner category was last updated (datetime) Relationships: branch_categorisations : a has-many relationship with the BranchCategorisation model, representing the categories a branch belongs to (a branch can belong to multiple categories and a category can have multiple branches) branches : a has-many-through relationship with the Branch model, representing the branches that belong to the partner category Custom methods: to_s : returns the title of the partner category as a string Examples of usage: Creating a new partner category: category = PartnerCategory.new(title: 'Technology') category.save Adding a branch to a partner category: category = PartnerCategory.find(1) branch = Branch.find(2) category.branches << branch Displaying the title of a partner category: category = PartnerCategory.find(1) puts category.to_s # outputs the title of the partner category Personality The Personality model represents the personality of a user. It is composed of three sub-models: Lifestyle, Food, and Wine. Attributes: None. Relationships: The Personality model has three sub-models: Lifestyle, Food, and Wine. Each of these sub-models has a one-to-one relationship with the Personality model. Custom Methods: initialize(user): Initializes a new instance of the Personality model with a given user. result: Returns a hash containing the results of the Lifestyle, Food, and Wine sub-models. Examples of usage: user = User.find(1) personality = Personality.new(user) results = personality.result Photo The Photo model represents a photo that belongs to an owner object through polymorphic association. It has the following attributes: id : a unique integer identifier for the photo, generated by the database owner_id : an integer representing the ID of the owner object that this photo belongs to owner_type : a string representing the type of the owner object that this photo belongs to (e.g. \"Branch\", \"User\") image : a string representing the location of the photo file on the filesystem or in a file storage service (e.g. Amazon S3) created_at : a datetime representing the time when the photo was created updated_at : a datetime representing the time when the photo was last updated photo_type : a string representing the type of the photo (e.g. \"logo\", \"cover photo\") The Photo model also has the following relationships: belongs_to :owner, polymorphic: true, touch: true : this indicates that a photo belongs to an owner object, and the owner object can be any type of object (specified by the owner_type attribute). The touch: true option tells Rails to update the updated_at timestamp of the owner object when the photo is updated. The Photo model has the following custom methods: safe_recreate_versions! : this method is used to recreate the different versions (resized versions) of the photo file. It first retrieves the original file from the cache, then recreates the versions and saves the changes to the model. preview_data : this method returns a base64-encoded version of the photo file's preview version, suitable for use in a data URI. It uses the Rails.cache to store the result and avoid recalculating it every time it is called. An example of usage for the Photo model might be: # Create a new photo for a branch object branch = Branch.first photo = Photo.new(owner: branch, image: params[:image]) if photo.save PreferenceGroup The PreferenceGroup model represents a group of questions that are related to each other. It has the following attributes: id: a unique identifier for the preference group (integer, primary key). title: a string representing the title of the preference group. question_ids: an array of integers representing the ids of the questions that belong to the preference group. created_at: a datetime representing when the preference group was created. updated_at: a datetime representing the last time the preference group was updated. It has the following relationships: has_many :role_preference_group_assignments: this indicates that a preference group can have many assignments to roles. It has the following custom methods: question_ids=: this method is used to set the question_ids attribute, and it removes any blank values from the array of new ids before saving them. questions: this method returns a collection of Question objects that belong to the preference group, based on the question_ids attribute. An example of usage could be: # Find the preference group with id 1 pg = PreferenceGroup.find(1) # Display the title of the preference group puts pg.title # => \"Food Preferences\" # Display the questions that belong to the preference group pg.questions.each do |question| puts question.text end # => \"What is your favourite type of cuisine?\" # => \"Do you have any dietary restrictions?\" # => \"Do you have any food allergies?\" ProfileRequest The ProfileRequest model represents a request made by a user for access to a branch's profile page. It has the following attributes: id : a unique identifier for the request branch_id : the ID of the branch that the user is requesting access to user_id : the ID of the user making the request created_at : a timestamp for when the request was created updated_at : a timestamp for when the request was last updated It has the following relationships: belongs_to :branch: indicates that each ProfileRequest belongs to a single Branch belongs_to :user: indicates that each ProfileRequest belongs to a single User It does not have any custom methods or examples of usage. Question The Question model represents a question that can be asked to a user. It has various attributes such as title, kind, and locking_conditions that define the question and its behavior. The Question model also has relationships with other models such as Category, Photo, Answer, and UserAnswer. Attributes id (bigint, primary key) : a unique identifier for the question. category_id (integer) : the id of the category that the question belongs to. title (citext) : the title of the question. kind (string) : the type of question, which can be one of the following values: 'option', 'unordered_list', 'ordered_list', 'boolean', 'number', 'number_range', 'temperature', 'temperature_range', 'text', 'time', 'time_range'. created_at (datetime) : the timestamp when the question was created. updated_at (datetime) : the timestamp when the question was last updated. locking_conditions (jsonb) : a JSON object that defines the conditions under which the question should be locked. intro (boolean) : a flag indicating whether the question is an introduction question. allows_note (boolean) : a flag indicating whether the question allows the user to add a note. note_title (string) : the title of the note that the user can add to the question. processed_at (datetime) : the timestamp when the question was processed. text_style (string) : the style of the text for the question. Can be one of the following values: 'dark', 'light', 'dark-gold', 'light-gold'. blur_background (boolean) : a flag indicating whether the background should be blurred for the question. background_overlay (boolean): a flag indicating whether there should be an overlay on the background for the question. Relationships category (belongs_to) : the category that the question belongs to. photo (has_one) : the photo that is associated with the question. answers (has_many) : the answers that are available for the question. user_answers (has_many) : the answers that have been given by users for the question. Custom Methods enumerable_kind? : returns a boolean indicating whether the question is one of the following types: 'option', 'unordered_list', 'ordered_list', 'boolean', 'number', 'number_range', 'temperature', 'temperature_range'. diverse_kind? : returns a boolean indicating whether the question is one of the following types: 'text', 'time', 'time_range'. Examples of Usage Here are some examples of how the Question model can be used: To create a new question: question = Question.new(title: 'What is your favorite color?', kind: 'option') question.save To retrieve all the questions in a particular category: category = Category.find_by(name: 'Personal') questions = Question.in_category(category) Rating The Rating model represents a rating given by a user for a particular branch. It has various attributes such as value that define the rating, and relationships with other models such as Branch and User. Attributes id (bigint, primary key) : a unique identifier for the rating. branch_id (bigint) : the id of the branch that the rating is for. user_id (bigint) : the id of the user who gave the rating. value (integer) : the value of the rating, which must be an integer between 1 and 5. created_at (datetime) : the timestamp when the rating was created. updated_at (datetime) : the timestamp when the rating was last updated. Relationships branch (belongs_to) : the branch that the rating is for. user (belongs_to) : the user who gave the rating. Custom Methods There are no custom methods defined in the Rating model. Examples of Usage Here are some examples of how the Rating model can be used: To create a new rating: branch = Branch.find_by(name: 'My Branch') user = User.find_by(email: 'user@example.com') rating = Rating.new(branch: branch, user: user, value: 4) rating.save To retrieve all the ratings for a particular branch: branch = Branch.find_by(name: 'My Branch') ratings = Rating.where(branch: branch) To retrieve the average rating value for a particular branch: branch = Branch.find_by(name: 'My Branch') average_rating = Rating.where(branch: branch).average(:value) Release The Release model represents a release of data. It has various attributes such as file and status that define the release, and a relationship with the ReleaseFileUploader uploader. Attributes id (bigint, primary key) : a unique identifier for the release. file (string) : the file that contains the data for the release. status (string) : the status of the release, which can be one of the following values: 'queued', 'processing', 'complete'. created_at (datetime) : the timestamp when the release was created. updated_at (datetime) : the timestamp when the release was last updated. Relationships file (mount_uploader) : the ReleaseFileUploader uploader that is used to handle the file for the release. Custom Methods latest : returns the latest complete release. latest_timestamp : returns the timestamp of the latest complete release. latest_id : returns the id of the latest complete release. latest? : returns a boolean indicating whether the release is the latest complete release. queued? : returns a boolean indicating whether the release is in the 'queued' status. processing? : returns a boolean indicating whether the release is in the 'processing' status. complete? : returns a boolean indicating whether the release is in the 'complete' status. process! : sets the status of the release to 'processing' and broadcasts the status change. complete! : sets the status of the release to 'complete' and broadcasts the status change. Examples of Usage Here are some examples of how the Release model can be used: To create a new release: release = Release.new(file: '/path/to/file.csv') release.save To retrieve the latest complete release: latest_release = Release.latest To retrieve the timestamp of the latest complete release: latest_timestamp = Release.latest_timestamp To check if a particular release is the latest complete release: release = Release.find(1) release.latest? To set the status of a release to 'processing': release = Release.find(1) release.process! To set the status of a release to 'complete': release = Release.find(1) release.complete! RoleAssignment The RoleAssignment model represents a role that has been assigned to a staff member. It has various attributes such as role_id and staff_member_id that define the assignment, and relationships with other models such as Role and StaffMember. Attributes id (bigint, primary key) : a unique identifier for the role assignment. role_id (bigint) : the id of the role that has been assigned. staff_member_id (bigint) : the id of the staff member who has been assigned the role. archived_at (datetime) : the timestamp when the role assignment was archived. created_at (datetime) : the timestamp when the role assignment was created. updated_at (datetime) : the timestamp when the role assignment was last updated. Relationships role (belongs_to) : the role that has been assigned. staff_member (belongs_to) : the staff member who has been assigned the role. Custom Methods There are no custom methods defined in the RoleAssignment model. Examples of Usage Here are some examples of how the RoleAssignment model can be used: To create a new role assignment: role = Role.find_by(name: 'Manager') staff_member = StaffMember.find_by(email: 'staff@example.com') role_assignment = RoleAssignment.new(role: role, staff_member: staff_member) role_assignment.save To retrieve all the role assignments for a particular role: role = Role.find_by(name: 'Manager') role_assignments = RoleAssignment.where(role: role) To retrieve all the role assignments for a particular staff member: staff_member = StaffMember.find_by(email: 'staff@example.com') role_assignments = RoleAssignment.where(staff_member: staff_member) RolePreferenceGroupAssignment The RolePreferenceGroupAssignment model represents the assignment of a preference group to a role. It has various attributes such as role_id, preference_group_id, and position that define the assignment, and relationships with other models such as Role and PreferenceGroup. Attributes id (bigint, primary key) : a unique identifier for the role preference group assignment. role_id (bigint) : the id of the role to which the preference group has been assigned. preference_group_id (bigint) : the id of the preference group that has been assigned to the role. position (integer) : the position of the preference group within the role. column (string) : the column in which the preference group should be displayed (either 'left' or 'right'). created_at (datetime) : the timestamp when the role preference group assignment was created. updated_at (datetime) : the timestamp when the role preference group assignment was last updated. Relationships role (belongs_to) : the role to which the preference group has been assigned. preference_group (belongs_to) : the preference group that has been assigned to the role. **Custom Methods left : a scope that returns all the role preference group assignments with the column attribute set to 'left'. right : a scope that returns all the role preference group assignments with the column attribute set to 'right'. Examples of Usage Here are some examples of how the RolePreferenceGroupAssignment model can be used: To create a new role preference group assignment: role = Role.find_by(name: 'Manager') preference_group = PreferenceGroup.find_by(name: 'General') role_preference_group_assignment = RolePreferenceGroupAssignment.new( role: role, preference_group: preference_group, position: 1, column: 'left' ) role_preference_group Role The Role model represents a role within an organization. It has various attributes such as name, business_unit_id, and interactions that define the role, and relationships with other models such as BusinessUnit, StaffMember, and MemberRequestType. Attributes id (bigint, primary key) :a unique identifier for the role. name (string) :the name of the role. created_at (datetime) :the timestamp when the role was created. updated_at (datetime) :the timestamp when the role was last updated. archived_at (datetime) :the timestamp when the role was archived (if applicable). business_unit_id (bigint) :the id of the business unit to which the role belongs. top_questions_data (jsonb) :a JSON object containing data about the top questions for the role. interactions (string, array) :an array of strings representing the interactions that are allowed for the role. Relationships business_unit (belongs_to) :the business unit to which the role belongs. organisation (has_one, through: business_unit) :the organization to which the role belongs. role_assignments (has_many) :the assignments of staff members to the role. staff_members (has_many, through: role_assignments) :the staff members who have been assigned to the role. member_request_type_assignments (has_many) :the assignments of member request types to the role. member_request_types (has_many, through: member_request_type_assignments) :the member request types that have been assigned to the role. Custom Methods **top_questions_data=: a setter method that sets the top_questions_data attribute and converts the values to integers. top_question(position) :a method that returns the id of the top question at the specified position. top_question_ids : a method that returns an array of ids of the top questions for the role. top_questions : a method that returns the top questions for the role as a collection of Question objects. Share The Share model represents a user's request to share a Branch with another user. It has several attributes: branch_id : an integer that represents the Branch being shared user_id : an integer that represents the User making the request status : a string that represents the current state of the share request (e.g. requested, authorised, revoked, denied) via : a string that represents how the request was made (e.g. web, email, sms) requested_at, authorised_at, denied_at, revoked_at : timestamps for when the respective actions were taken It has several relationships: belongs_to :branch : a Share belongs to a Branch belongs_to :user : a Share belongs to a User It has several custom methods: request, authorise, deny, revoke : methods that update the status attribute and perform other actions depending on the transition (e.g. sending notifications, scheduling a reminder job). These methods are implemented using the aasm gem for state management. revoke_all : a class method that updates the status attribute of all authorised shares to revoked create_request_notification, authorise_notifications, deny_notifications, update_notifications, schedule_reminder, notify_graphql_share_change : private methods that perform actions such as creating notifications, scheduling jobs, and triggering GraphQL subscriptions. An example of usage: share = Share.new(branch_id: 1, user_id: 2) share.request This will create a new Share object with a status of requested, and trigger the create_request_notification method to send a notification to the user. StaffAssignment The StaffAssignment model represents an association between a staff member and a target object. The target object can be any object that has an id column in the database and is polymorphic (can be associated with multiple types of objects). Attributes id : A big integer primary key. staff_member_id : An integer that represents the id of the associated staff member. target_type : A string that represents the class name of the associated target object. target_id : An integer that represents the id of the associated target object. created_at : A datetime that represents the time at which the staff assignment was created. updated_at : A datetime that represents the time at which the staff assignment was last updated. archived_at : A datetime that represents the time at which the staff assignment was archived. Relationships belongs_to :staff_member: The staff assignment belongs to a staff member. belongs_to :target, polymorphic: true: The staff assignment belongs to a target object that is polymorphic. Custom Methods None. Examples of Usage Suppose we have a Project model and a StaffMember model and we want to create a staff assignment that associates a staff member with a project. We could do so as follows: project = Project.find(1) staff_member = StaffMember.find(2) staff_assignment = StaffAssignment.new( staff_member: staff_member, target: project ) if staff_assignment.save puts \"Staff assignment created successfully!\" else puts \"Error creating staff assignment: #{staff_assignment.errors.full_messages.join(', ')}\" end TopQuestion The TopQuestion model is a subclass of the Question model, which represents a question that can be asked to users. It has the following attributes: id : a primary key, an integer, that uniquely identifies the question. category_id : an integer that represents the category to which the question belongs. title : a string that represents the title of the question. kind : a string that represents the type of question, such as multiple choice or true/false. created_at : a datetime that represents the time when the question was created. updated_at : a datetime that represents the time when the question was last updated. locking_conditions : a jsonb field that represents the conditions under which the question is locked. intro : a boolean field that represents whether the question is an introduction question or not. allows_note : a boolean field that represents whether the question allows users to add a note or not. note_title : a string that represents the title of the note that users can add. processed_at : a datetime that represents the time when the question was processed. text_style : a string that represents the style of the text used in the question. blur_background : a boolean field that represents whether the background of the question should be blurred or not. background_overlay : a boolean field that represents whether an overlay should be applied to the background of the question or not. The TopQuestion model has the following custom method: answers: returns a relation that represents the answers given by the user specified by the user_id class attribute to the question. An example of usage of the TopQuestion model is as follows: # Set the user ID for the current thread TopQuestion.user_id = current_user.id # Find the top question for the user top_question = TopQuestion.find(params[:id]) # Get the answers given by the user to the top question answers = top_question.answers UserAnswer The UserAnswer model represents an answer to a question by a user. It has the following attributes: id : a unique identifier for the answer, stored as a bigint user_id : the identifier of the user who provided the answer, stored as an integer question_id : the identifier of the question being answered, stored as an integer created_at : a timestamp for when the answer was created, stored as a datetime updated_at : a timestamp for when the answer was last updated, stored as a datetime note : a text field for storing a note or explanation related to the answer values : a text field for storing the actual answer, which can be serialized into different data types depending on the type of the question It has the following relationships: belongs_to :question : each answer belongs to a single question belongs_to :user : each answer is provided by a single user It has the following custom methods: Question::KINDS.each do |kind_name| define_method(\"#{kind_name}?\") { kind == kind_name } end : this generates methods for each type of question, such as ordered_list?, unordered_list?, text?, etc., which return a boolean indicating whether the answer's question has the corresponding type. values_format : a private method that validates the format of the values attribute based on the type of the question. If the format is invalid, it adds an error to the values attribute. Here are some examples of how the UserAnswer model could be used: # Create a new user answer answer = UserAnswer.new(user_id: 1, question_id: 2, values: 'This is my answer') answer.save # Find a user answer by its id answer = UserAnswer.find(5) # Update an existing user answer answer.values = 'This is my updated answer' answer.save # Check if a user answer's question is of a certain type answer.text? # returns true if the question is a text type, false otherwise # Access the user and question associated with a user answer user = answer.user question = answer.question VideoContentCategory VideoContentCategory is a model in a Ruby on Rails application that represents the many-to-many relationship between videos and content categories. It has the following attributes: id : a bigint that serves as the primary key for the model and is automatically generated by the database. video_id : a bigint that represents the foreign key for the video model. content_category_id : a bigint that represents the foreign key for the content_category model. created_at : a datetime that represents when the record was created. updated_at : a datetime that represents when the record was last updated. It has the following relationships: belongs_to :video : This indicates that each instance of the VideoContentCategory model belongs to a single video model. belongs_to :content_category : This indicates that each instance of the VideoContentCategory model belongs to a single content_category model. It has the following custom methods: None. Here is an example of how the VideoContentCategory model might be used: # Create a new video content category record that associates a video with a content category video_content_category = VideoContentCategory.new(video_id: 1, content_category_id: 2) # Save the video content category record to the database video_content_category.save Video Video is a model in a Ruby on Rails application that represents a video that can be published and viewed by users. It has the following attributes: id : a bigint that serves as the primary key for the model and is automatically generated by the database. name : a string that represents the name of the video. description : a text field that provides a description of the video. url : a string that represents the URL of the video. published_at : a datetime that represents when the video was published. organisation_id : a bigint that represents the foreign key for the organisation model. vista_admin_id : a bigint that represents the foreign key for the vista_admin model. notification_job_id : an integer that represents the ID of a notification job related to the video. created_at : a datetime that represents when the record was created. updated_at : a datetime that represents when the record was last updated. published : a boolean that indicates whether the video has been published or not. archived_at : a datetime that represents when the video was archived. platform_id : a string that represents the ID of the video on a platform like Vimeo. It has the following relationships: has_many :video_content_categories, dependent: :destroy : This indicates that a video can have many video content categories and that these should be destroyed when the video is destroyed. has_many :content_categories, through: :video_content_categories : This indicates that a video can have many content categories through its video content categories. belongs_to :vista_admin : This indicates that a video belongs to a single vista admin. belongs_to :organisation, optional : true: This indicates that a video can optionally belong to an organisation. It has the following custom methods: check_published_status : This method is called before the video is saved and checks if the published status has changed. If it has and the video is being published, it sets the published_at attribute to the current time. extract_platform_id : This method is called before the video is saved and extracts the ID of the video on a platform like Vimeo from the url attribute. It also has the following scope methods: in_organisation : This scope filters videos by the given organisation. newest_first : This scope orders videos by their created_at attribute in descending order. for_vista : This scope filters videos that do not belong to an organisation. search : This scope filters videos by a search term that is matched against the name and description attributes. published : This scope filters published videos. Here is an example of how the Video model might be used: Copy code # Find all published videos in an organisation videos = Video.in_organisation(1).published # Find the most recently created video newest_video = Video.newest_first.first # Search for videos with the term 'cat' in their name or description cat_videos = Video.search('cat') VistaAdmin VistaAdmin is a model in a Ruby on Rails application that represents an administrator for the Vista platform. It has the following attributes: id : a bigint that serves as the primary key for the model and is automatically generated by the database. first_name : a string that represents the first name of the administrator. last_name : a string that represents the last name of the administrator. email : a string that represents the email address of the administrator. encrypted_password : a string that represents the encrypted password of the administrator. reset_password_token : a string that represents a token used for resetting the password. reset_password_sent_at : a datetime that represents when the reset password token was sent. remember_created_at : a datetime that represents when the administrator chose to be remembered. sign_in_count : an integer that represents the number of times the administrator has signed in. current_sign_in_at : a datetime that represents the current sign in time of the administrator. last_sign_in_at : a datetime that represents the last sign in time of the administrator. current_sign_in_ip : an inet field that represents the current sign in IP address of the administrator. last_sign_in_ip : an inet field that represents the last sign in IP address of the administrator. confirmation_token : a string that represents a confirmation token for the administrator. confirmed_at : a datetime that represents when the administrator was confirmed. confirmation_sent_at : a datetime that represents when the confirmation token was sent. unconfirmed_email : a string that represents the unconfirmed email address of the administrator. failed_attempts : an integer that represents the number of failed attempts by the administrator. unlock_token : a string that represents a token used to unlock the administrator's account. locked_at : a datetime that represents when the administrator's account was locked. created_at : a datetime that represents when the record was created. updated_at : a datetime that represents when the record was last updated. It has the following relationships: has_many :videos : This indicates that a VistaAdmin can have many videos. It has the following custom methods: attempt_set_password : This method allows the administrator to set a new password without knowing the current password. no_password? : This method returns a boolean indicating whether the administrator has a password set. only_if_unconfirmed : This method yields to a block if the administrator has not been confirmed. password_match? : This method returns a boolean indicating whether the entered password and password confirmation match. It also includes the Devise module for authentication and confirmation. Here is an example of how the VistaAdmin model might be used: # Find a VistaAdmin by email vista_admin = VistaAdmin.find_by(email: 'admin@example.com') # Check if the VistaAdmin's password is blank if vista_admin.no_password?","title":"structure"},{"location":"models/#models","text":"","title":"Models"},{"location":"models/#folder-structure","text":"\u251c\u2500\u2500\u2500models \u251c\u2500\u2500\u2500concerns \u251c\u2500\u2500\u2500personality \u2514\u2500\u2500\u2500versions","title":"Folder structure"},{"location":"models/#address","text":"The Address model represents an address in the system. It has the following attributes: id (integer): a unique ID for the address label (string): a label or nickname for the address line1 (string): the first line of the address line2 (string): the second line of the address town (string): the town or city where the address is located county (string): the county or region where the address is located postcode (string): the postal code for the address country (string): the country where the address is located phone (string): a phone number associated with the address latitude (decimal): the latitude of the address longitude (decimal): the longitude of the address addressable_type (string): the type of model that the address belongs to** (e.g. \"User\" or \"Company\") addressable_id (integer): the ID of the model that the address belongs to created_at (datetime): the date and time that the address was created updated_at (datetime): the date and time that the address was last updated city_id (integer): the ID of the city where the address is located The Address model has the following relationships: belongs_to :addressable, polymorphic: true: this indicates that the address belongs to a parent model, and the addressable_type and addressable_id attributes are used to specify which model the address belongs to. The polymorphic option indicates that the parent model can be any type of model, and the inverse_of: :address option specifies the name of the has_one or has_many association on the parent model. belongs_to :city: this indicates that the address belongs to a city. The city_id attribute is used to specify which city the address belongs to. The Address model has the following custom methods: country_name: this method returns the name of the country for the address. It uses the ISO3166 gem to look up the name of the country based on the country attribute. country_code: this method returns the country code for the address. It simply returns the value of the country attribute. Here are some examples of how the Address model might be used: # Find all addresses for a user user = User.find(123) addresses = user.addresses # Find the nearest address to a given location latitude = 37.774929 longitude = -122.419416 radius = 5 # miles addresses = Address.within(radius, origin: [latitude, longitude]) # Find the address for a specific user user = User.find(123) address = user.address # Set the address for a user user = User.find(123)","title":"Address"},{"location":"models/#admin","text":"The following are the Attributes of Admin: id : bigint, primary key for the model email : string, the email address of the admin first_name : string, the first name of the admin last_name : string, the last name of the admin mobile_number : string, the mobile phone number of the admin encrypted_password : string, a hashed version of the admin's password reset_password_token : string, a token used for resetting the admin's password reset_password_sent_at : datetime, the time at which the reset password token was sent remember_created_at : datetime, the time at which the admin selected the \"remember me\" option during login sign_in_count : integer, the number of times the admin has signed in current_sign_in_at : datetime, the time at which the admin signed in during the current session last_sign_in_at : datetime, the time at which the admin signed in during the previous session current_sign_in_ip : inet, the IP address of the admin during the current session last_sign_in_ip : inet, the IP address of the admin during the previous session authentication_token : string, a token used for authenticating the admin created_at : datetime, the time at which the admin's record was created updated_at : datetime, the time at which the admin's record was last updated organisation_id : bigint, the ID of the organization to which the admin belongs type : string, the type of staff member (in this case, \"Admin\") employee_id : string, the employee ID of the admin confirmation_token : string, a token used for confirming the admin's email address confirmed_at : datetime, the time at which the admin's email address was confirmed confirmation_sent_at : datetime, the time at which the confirmation token was sent suspended_at : datetime, the time at which the admin's access was suspended archived_at : datetime, the time at which the admin's record was archived encrypted_pin : string, a hashed version of the admin's PIN (personal identification number) unconfirmed_email : string, the unconfirmed email address of the admin (if the admin has requested a change to their email address) Inherits from StaffMember model Custom methods: None Examples of usage: An instance of the Admin model could represent a staff member with administrative privileges within an organization. The email, password, and authentication token attributes could be used for authenticating the admin when logging in to the system. The sign_in_count, current_sign_in_at, and last_sign_in_at attributes could be used for tracking the admin's login history.","title":"Admin"},{"location":"models/#answer","text":"Attributes: id (integer): The primary key for the model. question_id (integer): The ID of the question that the answer belongs to. title (text): The title of the answer. description (text): A description of the answer. created_at (datetime): The timestamp for when the answer was created. updated_at (datetime): The timestamp for when the answer was last updated. position (integer): The position of the answer within its parent question. Relationships: question (belongs_to): The question that the answer belongs to. photo (has_one): The photo associated with the answer. Custom methods: siblings : Returns the other answers within the same question as the current answer. reject_photo? : Determines whether a photo should be rejected when creating or updating an answer. set_position : Sets the position of the answer within its parent question. Examples of usage: # Create a new answer with a title and description answer = Answer.new(title: 'Yes', description: 'The answer is yes') # Set the question that the answer belongs to answer.question = Question.first # Save the answer answer.save # Update the title of the answer answer.title = 'Yes, definitely' answer.save # Delete the answer answer.destroy","title":"Answer"},{"location":"models/#applicationrecord","text":"Attributes: None. ApplicationRecord is an abstract base class and does not have any attributes of its own. Relationships: None. ApplicationRecord is an abstract base class and does not have any relationships of its own. Custom methods: updated_since(datetime): Returns all records that have been updated since the specified datetime. pluck_to_hash(*keys): Returns an array of hashes, where each hash represents a record in the database with keys corresponding to the specified attributes. Examples of usage: # Find all records in the database that have been updated since yesterday ApplicationRecord.updated_since(1.day.ago) # Retrieve the IDs and titles of all records in the database ApplicationRecord.pluck_to_hash(:id, :title) Note: ApplicationRecord is an abstract base class and cannot be instantiated directly. Instead, you will need to use a concrete subclass of ApplicationRecord (such as Answer, Question, etc.) to create and manipulate records in the database.","title":"ApplicationRecord"},{"location":"models/#articlecontentcategory","text":"Attributes: id (integer): The primary key for the model. article_id (integer): The ID of the article that the content category belongs to. content_category_id (integer): The ID of the content category. created_at (datetime): The timestamp for when the article content category was created. updated_at (datetime): The timestamp for when the article content category was last updated. Relationships: article (belongs_to): The article that the content category belongs to. content_category (belongs_to): The content category. Custom methods: None. Examples of usage: # Create a new article content category article_content_category = ArticleContentCategory.new # Set the article and content category that the article content category belongs to article_content_category.article = Article.first article_content_category.content_category = ContentCategory.first # Save the article content category article_content_category.save # Delete the article content category article_content_category.destroy","title":"ArticleContentCategory"},{"location":"models/#article","text":"Attributes: id (integer): The primary key for the model. title (string): The title of the article. content (text): The content of the article. publish_at (datetime): The timestamp for when the article should be published. created_at (datetime): The timestamp for when the article was created. updated_at (datetime): The timestamp for when the article was last updated. notification_job_id (integer): The ID of the job used to send notifications when the article is published. Relationships: header_image (has_one): The header image for the article. photos (has_many): The photos associated with the article. article_content_categories (has_many): The article content categories associated with the article. content_categories (has_many): The content categories associated with the article. Custom methods: header_image=(header_image) : Sets the header image for the article. publish_at=(publish_at) : Sets the publish timestamp for the article. published? : Returns true if the article has been published, false otherwise. status : Returns the current status of the article. self.start_draft : Creates a new draft article. Examples of usage: # Create a new article article = Article.new # Set the title and content of the article article.title = 'My article' article.content = 'This is the content of my article' # Set the publish timestamp for the article article.publish_at = 1.day.from_now # Save the article article.save # Check if the article has been published article.published? # Get the status of the article article.status # Delete the article article.destroy","title":"Article"},{"location":"models/#authenticationtoken","text":"The AuthenticationToken model represents a token that is used to authenticate a user. It belongs to a polymorphic user, which means that it can belong to any model that includes the User module. Attributes: id : a unique identifier for the token (integer, primary key) context : the context in which the token is used (string) body : the actual token (string) user_type : the type of the user that the token belongs to (string) user_id : the ID of the user that the token belongs to (integer) last_used_at : the last time the token was used (datetime) ip_address : the IP address from which the token was last used (inet) user_agent : the user agent string from the device that used the token last (string) created_at : the time the token was created (datetime) updated_at : the time the token was last updated (datetime) Relationships: user : the user that the token belongs to (polymorphic association) Custom methods: decode : decodes a token from the headers find_for_context : finds a token for a given context and token body create_and_return_staff_token : creates a new staff token and returns it create_and_return_manager_token : creates a new manager token and returns it create_and_return_token : creates a new token for a given context and returns it create_and_return_analytics_token : creates and returns an analytics token Examples of usage: To create a new staff token for a user: token = AuthenticationToken.create_and_return_staff_token(current_user, request) To find a token for a given context and token body: token = AuthenticationToken.find_for","title":"AuthenticationToken"},{"location":"models/#branchcategorisation","text":"The BranchCategorisation model represents the many-to-many relationship between branches and partner categories. This allows a branch to be associated with one or more partner categories, and a partner category to be associated with one or more branches. Attributes: id : A unique identifier for the branch categorisation record, stored as an integer and generated automatically by the database. branch_id : The ID of the branch that is associated with a partner category, stored as an integer. partner_category_id : The ID of the partner category that is associated with a branch, stored as an integer. created_at : A timestamp indicating when the branch categorisation record was created, stored as a datetime. updated_at : A timestamp indicating when the branch categorisation record was last updated, stored as a datetime. Relationships: belongs_to : A branch categorisation belongs to a single branch and a single partner category. branch : This relationship specifies the branch that is associated with a partner category. partner_category : This relationship specifies the partner category that is associated with a branch. Custom methods: There are no custom methods defined for the BranchCategorisation model. Examples of usage: Creating a new branch categorisation: branch = Branch.first partner_category = PartnerCategory.first branch_categorisation = BranchCategorisation.new(branch: branch, partner_category: partner_category) branch_categorisation.save Retrieving all branch categorisations for a particular branch: branch = Branch.first branch_categorisations = branch.branch_categorisations Retrieving all branches that belong to a particular partner category: partner_category = PartnerCategory.first branches = partner_category.branches Removing a branch categorisation: branch_categorisation = BranchCategorisation.first branch_categorisation.destroy","title":"BranchCategorisation"},{"location":"models/#branchmanager","text":"The BranchManager model is a subclass of the StaffMember model and represents a staff member who is a branch manager at an organisation. attributes: id : a bigint that serves as the primary key for the model email : a string that stores the email address of the staff member first_name : a string that stores the first name of the staff member last_name : a string that stores the last name of the staff member mobile_number : a string that stores the mobile phone number of the staff member encrypted_password : a string that stores the encrypted password of the staff member reset_password_token : a string that stores a token used to reset the staff member's password reset_password_sent_at : a datetime that stores the time at which the reset password token was sent to the staff member remember_created_at : a datetime that stores the time at which the staff member requested to be remembered on the device they are using sign_in_count : an integer that stores the number of times the staff member has signed in current_sign_in_at : a datetime that stores the time at which the staff member last signed in last_sign_in_at : a datetime that stores the time at which the staff member signed in before the last time they signed in current_sign_in_ip : an inet data type that stores the IP address the staff member is currently signed in from last_sign_in_ip : an inet data type that stores the IP address the staff member last signed in from authentication_token : a string that stores a unique token used for authentication purposes created_at : a datetime that stores the time at which the staff Relationships: BranchManager has a one-to-many relationship with Branch through the branches association. Custom methods: assigned_branches: returns a collection of branches that the branch manager is assigned to. Examples of usage: # Find a branch manager by their email and assign them to a branch manager = BranchManager.find_by(email: 'branch_manager@example.com') branch = Branch.find(1) manager.branches << branch # Find all the branches that a branch manager is assigned to manager = BranchManager.find(1) manager.assigned_branches","title":"BranchManager"},{"location":"models/#branch","text":"Attributes: id : integer, primary key business_unit_id : integer name : string created_at : datetime updated_at : datetime email : string telephone : string archived_at : datetime image : string branch_info : string booking_url : string vista_partner : boolean, default: false ratings_count : integer, default: 0 Relationships: business_unit : belongs to a BusinessUnit organisation : has one Organisation through the BusinessUnit photo : has one Photo as owner address : has one Address as addressable staff_assignments : has many StaffAssignments as target staff_members : has many StaffMembers through StaffAssignments shares : has many Shares users : has many Users through Shares with the condition that the Share is authorised branch_categorisations : has many BranchCategorisations categories : has many PartnerCategories through BranchCategorisations interactions : has many Interactions roles : has many Roles through the BusinessUnit check_ins : has many CheckIns member_requests : has many MemberRequests member_request_messages : has many MemberRequestMessages as messageable Custom methods: category_titles : returns an array of the titles of the categories associated with the branch destroy_staff : destroys the staff members associated with the branch","title":"Branch"},{"location":"models/#businessunit","text":"Attributes: id : integer, primary key name : string organisation_id : integer, foreign key to the organisations table created_at : datetime updated_at : datetime archived_at : datetime Relationships: belongs_to :organisation has_many :branches has_many :roles has_many :member_request_types Custom methods: None Examples of usage: Fetch all business units belonging to a particular organisation: organisation = Organisation.find(1) business_units = organisation.business_units Fetch all branches belonging to a particular business unit: business_unit = BusinessUnit.find(1) branches = business_unit.branches Fetch all roles belonging to a particular business unit: business_unit = BusinessUnit.find(1) roles = business_unit.roles Fetch all member request types belonging to a particular business unit: business_unit = BusinessUnit.find(1) member_request_types = business_unit.member_request_types","title":"BusinessUnit"},{"location":"models/#categoryupdate","text":"Attributes: id : integer category_id : integer question_ids : array of integers created_at : datetime updated_at : datetime Relationships: belongs_to :category Custom methods : title : returns the title of the associated category photo : returns the photo of the associated category questions : returns an array of Question objects that have an id in the question_ids attribute Examples of usage: Find the category update with id 1 update = CategoryUpdate.find(1) Access the title of the associated category update.title Access the photo of the associated category update.photo Access the questions associated with this update update.questions","title":"CategoryUpdate"},{"location":"models/#category","text":"It has the following attributes: id : a unique identifier for the update, stored as a bigint category_id : a foreign key referencing the category that this update is for question_ids : an array of integers representing the question IDs that are associated with this update created_at : a timestamp for when the update was created updated_at : a timestamp for when the update was last updated It has the following relationships: belongs_to :category : indicates that each category update belongs to a single category It has the following custom methods: title : returns the title of the category that this update is for. If the category's title is \"general\" and it has a parent, the parent's title is returned instead. photo : returns the photo of the category that this update is for. questions: returns a collection of Question objects that are associated with this update. Here is an example of how the CategoryUpdate model could be used: Find a category update by its ID update = CategoryUpdate.find(1) Access the title of the update's category puts update.title Access the questions associated with the update questions = update.questions","title":"Category"},{"location":"models/#checkin","text":"The CheckIn model represents a check-in by a user to a branch in the application. It has the following attributes: id : a unique identifier for the check-in, stored as a bigint user_id : a foreign key referencing the user who checked in branch_id : a foreign key referencing the branch that the user checked in to arrival_date : a date representing the date on which the user checked in arrival_time_start : a time representing the start time of the user's check-in arrival_time_end : a time representing the end time of the user's check-in created_at : a timestamp for when the check-in was created updated_at : a timestamp for when the check-in was last updated It has the following relationships: belongs_to :user, touch: true : indicates that each check-in belongs to a single user, and the updated_at timestamp of the user will be updated whenever this check-in is saved. belongs_to :branch: indicates that each check-in belongs to a single branch It has the following custom methods: earliest : a scope that orders check-ins by their arrival_date in ascending order. future: a scope that filters check-ins to only include those with an arrival_date in the future. for_branch: a scope that filters check-ins to only include those for a particular branch. Here is an example of how the CheckIn model could be used: Find a user by their ID user = User.find(1) Find a branch by its ID branch = Branch.find(1) Create a new check-in for the user at the branch check_in = CheckIn.new(user: user, branch: branch, arrival_date: Date.today, arrival_time_start: Time.now) Save the check-in check_in.save Find all future check-ins for a particular branch future_check_ins = CheckIn.for_branch(branch).future","title":"CheckIn"},{"location":"models/#city","text":"The City model represents a city in the application. It has the following attributes: id : a unique identifier for the city, stored as a bigint name : the name of the city created_at : a timestamp for when the city was created updated_at : a timestamp for when the city was last updated status : a string representing the status of the city, with possible values of \"enabled\", \"disabled\", and \"coming_soon\" It has the following relationships: HasPhoto : indicates that the City model includes the HasPhoto module, which provides it with the ability to have a photo associated with it. It has the following custom methods: to_s : returns the name of the city as a string. It also has the following scopes: default_scope : orders cities by their name in ascending order. not_disabled : filters cities to only include those with a status of \"enabled\" or \"coming_soon\". Here is an example of how the City model could be used: Find a city by its ID city = City.find(1) Access the name of the city puts city.name Update the status of the city city.status = \"disabled\" city.save Find all cities that are not disabled cities = City.not_disabled","title":"City"},{"location":"models/#contentcategory","text":"The ContentCategory model represents a category for organizing content (e.g. articles, videos) in the application. It has the following attributes: id : a unique identifier for the content category, stored as a bigint name : the name of the content category created_at : a timestamp for when the content category was created updated_at : a timestamp for when the content category was last updated It has the following relationships: has_many :article_content_categories, dependent: :destroy: indicates that each content category can have many associations with articles through the article_content_categories join table, and these associations will be destroyed if the content category is deleted. has_many :articles, through: :article_content_categories : indicates that a content category can have many articles associated with it through the article_content_categories join table. has_many :video_content_categories, dependent: :destroy : indicates that each content category can have many associations with videos through the video_content_categories join table, and these associations will be destroyed if the content category is deleted. has_many :videos, through: :video_content_categories : indicates that a content category can have many videos associated with it through the video_content_categories join table. Here is an example of how the ContentCategory model could be used: Find a content category by its ID category = ContentCategory.find(1) Access the name of the category puts category.name Find all articles in the category articles = category.articles Find all videos in the category videos = category.videos Create a new article and associate it with the category article = Article.new(title: \"New Article\") article.content_categories << category article.save","title":"ContentCategory"},{"location":"models/#dataimport","text":"The DataImport model represents an import of data from a file (e.g. a spreadsheet) in the application. It has the following attributes: id : a unique identifier for the data import, stored as a bigint file : a string representing the file that was imported, stored as a file on the filesystem status : a string representing the status of the data import, with possible values of \"new\", \"running\", \"finished\", and \"failed\" log : a text field that stores log messages for the data import finished_at : a timestamp for when the data import finished created_at : a timestamp for when the data import was created updated_at : a timestamp for when the data import was last updated options : a JSONB field that stores options for the data import, including whether to import categories, questions, locking conditions, and visibility conditions The DataImport model has the following relationships: mount_uploader :file, FileUploader : indicates that the file attribute is a file that is managed by the FileUploader uploader. It has the following custom methods: filename : returns the filename of the imported file as a string. import_all : performs the data import, updating the status of the data import to \"running\" and setting it to \"finished\" or \"failed\" upon completion. This method also broadcasts the status of the data import to a channel on the Action Cable server. import_categories : imports categories from the data import file. import_questions : imports questions from the data import file. update_visibility_conditions : updates visibility conditions for questions in the data import file. update_locking_conditions : updates locking conditions for questions in the data import file. categories_spreadsheet : returns a Spreadsheet object for the categories sheet in the data import file. questions_spreadsheet : returns a Spreadsheet object for the questions sheet in the data import file. visibility_conditions_spreadsheet : returns a Spreadsheet object for the visibility conditions sheet in the data import file. locking_conditions_spreadsheet : returns a Spreadsheet object for the locking conditions sheet in the data import file. Here is an example of how the DataImport model could be used: Create a new data import with a file and options data_import = DataImport.new(file: params[:file], options: { categories: true, questions: true }) Save the data import and perform the import if data_import.save data_import.import_all end Find all data imports ordered by the most recently created data_imports = DataImport.all","title":"DataImport"},{"location":"models/#device","text":"The Device model represents a device that a user has used to sign in to the application. It has the following attributes: id : a unique identifier for the device, stored as a bigint user_id : a foreign key for the user associated with the device platform : a string representing the platform of the device (e.g. \"ios\" or \"android\") token : a string representing a unique token for the device created_at : a timestamp for when the device was created updated_at : a timestamp for when the device was last updated It has the following relationships: belongs_to :user : indicates that each device belongs to a single user. It has the following custom methods: ios? : returns true if the platform of the device is \"ios\", false otherwise. android?: returns true if the platform of the device is \"android\", false otherwise. Here is an example of how the Device model could be used: Find a device by its token device = Device.find_by(token: params[:token]) Check if the device is an iOS device if device.ios? # Do something end Create a new device for a user device = Device.new(user: current_user, platform: params[:platform], token: params[:token]) Save the device device.save","title":"Device"},{"location":"models/#feed","text":"The Feed model is a serializable model that represents a feed of content for a user. It has the following attributes: articles : an array of articles to be included in the feed interactions : an array of interactions to be included in the feed category_updates : an array of category updates to be included in the feed videos : an array of videos to be included in the feed It does not have any relationships or custom methods. Here is an example of how the Feed model could be used: Initialize a new feed with arrays of articles, interactions, category updates, and videos feed = Feed.new(articles: articles, interactions: interactions, category_updates: category_updates, videos: videos) Render the feed as JSON using a serializer render json: feed","title":"Feed"},{"location":"models/#ignore","text":"The Ignore model represents a relationship between a user and a category where the user has indicated that they do not want to receive notifications for updates to the category. It has the following attributes: id : a unique identifier for the ignore relationship, stored as a bigint user_id : a foreign key for the user associated with the ignore relationship category_id : a foreign key for the category associated with the ignore relationship created_at : a timestamp for when the ignore relationship was created updated_at : a timestamp for when the ignore relationship was last updated It has the following relationships: belongs_to :user : indicates that each ignore relationship belongs to a single user. belongs_to :category : indicates that each ignore relationship belongs to a single category. It does not have any custom methods. Here is an example of how the Ignore model could be used: Create a new ignore relationship between a user and a category ignore = Ignore.new(user: current_user, category: category) Save the ignore relationship ignore.save Find all the categories that a user is ignoring ignored_categories = Ignore.where(user: current_user).includes(:category)","title":"Ignore"},{"location":"models/#interaction","text":"The Interaction model represents a user interaction with a staff member, branch, or category. These interactions can be of different types, such as a recommendation or booking a taxi. Attributes: id : a unique identifier for the interaction user_id : the ID of the user who is interacting staff_member_id : the ID of the staff member involved in the interaction branch_id : the ID of the branch involved in the interaction category_id : the ID of the category involved in the interaction description : a description of the interaction created_at : the date and time that the interaction was created updated_at : the date and time that the interaction was last updated type : the type of interaction Relationships: belongs_to :user : the interaction belongs to a user belongs_to :staff_member : the interaction may involve a staff member belongs_to :branch : the interaction may involve a branch belongs_to :category : the interaction may involve a category Custom methods: mood? : returns a boolean indicating whether the interaction is a mood type partner_type? : returns a boolean indicating whether the interaction is a partner type (i.e. a type that involves a staff member or branch) Examples of usage: Retrieving a list of interactions for a particular user: Interaction.where(user_id: user.id) Retrieving a list of mood interactions for today: Interaction.where(type: 'mood').for_today","title":"Interaction"},{"location":"models/#memberrequestmessage","text":"The MemberRequestMessage model represents a message sent within a MemberRequest conversation between a staff member and a user. Attributes: id (integer) : The unique identifier for the message. body (text) : The content of the message. status (string) : The current status of the message, which can be pending, sent, or read. member_request_id (integer) : The identifier for the MemberRequest conversation to which the message belongs. messageable_id (integer) : The identifier for the user or staff member who sent the message. messageable_type (string) : The type of the sender, either User or StaffMember. created_at (datetime) : The timestamp when the message was created. updated_at (datetime) : The timestamp when the message was last updated. Relationships: belongs_to member_request : The MemberRequest conversation to which the message belongs. belongs_to messageable (polymorphic) : The user or staff member who sent the message. Custom methods: mark_as_read : Changes the status attribute to read. mark_as_unread : Changes the status attribute to pending. mark_as_sent : Changes the status attribute to sent. read? : Returns a boolean indicating whether the status attribute is read. Examples of usage: Create a new message: mr = MemberRequest.first message = MemberRequestMessage.new(body: 'Hello, how are you doing?', member_request: mr, messageable: staff_member) message.save Mark a message as read: message = MemberRequestMessage.first message.mark_as_read! Check if a message has been read: message = MemberRequestMessage.first message.read? Get all unread messages sent by staff members: MemberRequestMessage.from_staff_member.unread","title":"MemberRequestMessage"},{"location":"models/#memberrequesttypeassignment","text":"The MemberRequestTypeAssignment model represents a many-to-many relationship between Role and MemberRequestType models. It allows the assignment of one or more roles to a member request type, indicating which staff members are responsible for handling member requests of that type. Attributes: id (integer) : the primary key for the model. role_id (integer) : the foreign key for the Role model, indicating the role being assigned to the member request type. member_request_type_id (integer) : the foreign key for the MemberRequestType model, indicating the member request type being assigned to the role. created_at (datetime) : the timestamp for when the record was created. updated_at (datetime) : the timestamp for when the record was last updated. Relationships: belongs_to : the MemberRequestTypeAssignment model belongs to both the Role and MemberRequestType models. Custom methods: None. Examples of usage: Assign the 'customer_service' role to the 'booking' member request type member_request_type = MemberRequestType.find_by(name: 'booking') role = Role.find_by(name: 'customer_service') assignment = MemberRequestTypeAssignment.create(member_request_type: member_request_type, role: role) Get the member request types assigned to the 'customer_service' role role = Role.find_by(name: 'customer_service') member_request_types = role.member_request_types","title":"MemberRequestTypeAssignment"},{"location":"models/#memberrequesttype","text":"The MemberRequestType model represents a type of request that can be made by a member (user) to staff members in an organisation. Attributes: id : a unique identifier for the request type (integer, primary key) name : the name of the request type (string) business_unit_id : the unique identifier of the business unit to which the request type belongs (integer) created_at : the date and time at which the request type was created (datetime) updated_at : the date and time at which the request type was last updated (datetime) archived_at : the date and time at which the request type was archived (datetime) Relationships: business_unit : a belongs-to relationship with the BusinessUnit model. A request type belongs to a single business unit. organisation : a has-one-through relationship with the Organisation model. A request type has a single organisation through its business unit. member_request_type_assignments : a has-many relationship with the MemberRequestTypeAssignment model. A request type has many type assignments. roles : a has-many-through relationship with the Role model. A request type has many roles through its type assignments. staff_members : a has-many-through relationship with the StaffMember model. A request type has many staff members through its roles. Custom methods: acts_as_paranoid : this is a method provided by the ActsAsParanoid gem which allows the request type to be \"soft deleted\" by setting the archived_at attribute to the current date and time. This allows the request type to be restored if necessary. Examples of usage: Creating a new request type: request_type = MemberRequestType.new(name: 'Booking assistance') request_type.business_unit = BusinessUnit.first request_type.save","title":"MemberRequestType"},{"location":"models/#memberrequest","text":"Description: This model represents a request made by a member (user) to the staff of a branch. It has a type (e.g. booking, service request, etc.) and a status (open, pending, closed). The request can be composed of multiple messages exchanged between the member and the staff. Attributes: id : a unique identifier for the request (integer, primary key) user_id : the id of the member who made the request (integer, foreign key to the users table) branch_id : the id of the branch where the request was made (integer, foreign key to the branches table) member_request_type_id: the id of the type of request (integer, foreign key to the member_request_types table) status : the current status of the request (string, can be \"open\", \"pending\", or \"closed\") created_at : the timestamp for when the request was created (datetime) updated_at : the timestamp for when the request was last updated (datetime) last_message_sent_at : the timestamp for when the last message was sent for this request (datetime) Relationships: belongs_to :user belongs_to :branch belongs_to :member_request_type has_many :member_request_messages, dependent: :destroy Custom methods: mark_as_unread : marks the last message from the member as unread. Examples of usage: Create a new member request: request = MemberRequest.new(user_id: 1, branch_id: 2, member_request_type_id: 3, status: \"open\") request.member_request_messages.build(body: \"Hi, I would like to book a table for two on Friday at 7pm.\", messageable_type: \"User\") request.save Find all open member requests for a specific branch: requests = MemberRequest.for_branch(2).in_status(\"open\") Find all member requests for a specific member: requests = MemberRequest.for_member(1) Find all member requests with a specific message: requests = MemberRequest.with_message(5)","title":"MemberRequest"},{"location":"models/#notification","text":"The Notification model represents a notification that can be sent to a user. It can be associated with a specific object, such as a Branch or MemberRequestMessage, through a polymorphic association. Attributes: user_id : The ID of the user who will receive the notification. type : The type of notification, represented as a string. response : A JSONb field that can store a response from the user to the notification. object_type : The type of object that the notification is associated with, stored as a string. object_id : The ID of the object that the notification is associated with. created_at : The timestamp when the notification was created. updated_at : The timestamp when the notification was last updated. read_at : The timestamp when the notification was marked as read by the user. responded_at : The timestamp when the user responded to the notification. Relationships: belongs_to :user : The user who will receive the notification. belongs_to :object, polymorphic: true: The object that the notification is associated with. Custom methods: human_type : Returns the type of the notification in a human-readable format (e.g. \"new_message\" for Notification::NewMessage). mark_as_read : Marks the notification as read by updating the read_at attribute. self.mark_all_read: Marks all notifications as read for the current user by updating the read_at attribute. name : Returns the name of the object that the notification is associated with, or the name of the branch if the object is a MemberRequestMessage. Examples of usage: Create a new notification notification = Notification::NewMessage.create!(user: user, object: member_request_message) Mark a notification as read notification.mark_as_read Mark all notifications as read for a user Notification.where(user: user).mark_all_read Find unread notifications for a user unread_notifications = Notification.where(user: user).unread","title":"Notification"},{"location":"models/#organisation","text":"The Organisation model represents a company or organization in the system. It has the following attributes: id : a unique identifier for the organisation, stored as a big integer and generated automatically by the database. name : a string containing the name of the organization. This attribute is required. about : a text field containing information about the organization. archived_at : a datetime field containing the date and time at which the organization was archived. If the organization has not been archived, this field is nil. The Organisation model has the following relationships: address : a one-to-one relationship with the Address model, representing the address of the organization. photo : a one-to-one relationship with the Photo model, representing a photo of the organization. staff_members : a one-to-many relationship with the StaffMember model, representing the staff members of the organization. branch_managers : a one-to-many relationship with the BranchManager model, representing the branch managers of the organization. admins : a one-to-many relationship with the Admin model, representing the administrators of the organization. business_units : a one-to-many relationship with the BusinessUnit model, representing the business units within the organization. branches : a many-to-many relationship with the Branch model, through the BusinessUnit model, representing the branches that belong to the organization. roles : a many-to-many relationship with the Role model, through the BusinessUnit model, representing the roles that exist within the organization. videos : a one-to-many relationship with the Video model, representing the videos associated with the organization. The Organisation model has the following custom methods: reject_photo?(attributes) : a private method used to determine whether a photo should be rejected when creating or updating an organization. It returns true if the image attribute of the attributes parameter is blank, and false otherwise. An example of usage for the Organisation model could be: Create a new organization org = Organisation.new(name: \"My Organization\")","title":"Organisation"},{"location":"models/#partnercategory","text":"The PartnerCategory model represents categories for partners in the system. A partner can belong to multiple categories and each category can have multiple partners. Attributes: id : a unique identifier for the partner category (integer, primary key) title : the name of the partner category (string) position : the position of the partner category in a list (integer) created_at : the timestamp when the partner category was created (datetime) updated_at : the timestamp when the partner category was last updated (datetime) Relationships: branch_categorisations : a has-many relationship with the BranchCategorisation model, representing the categories a branch belongs to (a branch can belong to multiple categories and a category can have multiple branches) branches : a has-many-through relationship with the Branch model, representing the branches that belong to the partner category Custom methods: to_s : returns the title of the partner category as a string Examples of usage: Creating a new partner category: category = PartnerCategory.new(title: 'Technology') category.save Adding a branch to a partner category: category = PartnerCategory.find(1) branch = Branch.find(2) category.branches << branch Displaying the title of a partner category: category = PartnerCategory.find(1) puts category.to_s # outputs the title of the partner category","title":"PartnerCategory"},{"location":"models/#personality","text":"The Personality model represents the personality of a user. It is composed of three sub-models: Lifestyle, Food, and Wine. Attributes: None. Relationships: The Personality model has three sub-models: Lifestyle, Food, and Wine. Each of these sub-models has a one-to-one relationship with the Personality model. Custom Methods: initialize(user): Initializes a new instance of the Personality model with a given user. result: Returns a hash containing the results of the Lifestyle, Food, and Wine sub-models. Examples of usage: user = User.find(1) personality = Personality.new(user) results = personality.result","title":"Personality"},{"location":"models/#photo","text":"The Photo model represents a photo that belongs to an owner object through polymorphic association. It has the following attributes: id : a unique integer identifier for the photo, generated by the database owner_id : an integer representing the ID of the owner object that this photo belongs to owner_type : a string representing the type of the owner object that this photo belongs to (e.g. \"Branch\", \"User\") image : a string representing the location of the photo file on the filesystem or in a file storage service (e.g. Amazon S3) created_at : a datetime representing the time when the photo was created updated_at : a datetime representing the time when the photo was last updated photo_type : a string representing the type of the photo (e.g. \"logo\", \"cover photo\") The Photo model also has the following relationships: belongs_to :owner, polymorphic: true, touch: true : this indicates that a photo belongs to an owner object, and the owner object can be any type of object (specified by the owner_type attribute). The touch: true option tells Rails to update the updated_at timestamp of the owner object when the photo is updated. The Photo model has the following custom methods: safe_recreate_versions! : this method is used to recreate the different versions (resized versions) of the photo file. It first retrieves the original file from the cache, then recreates the versions and saves the changes to the model. preview_data : this method returns a base64-encoded version of the photo file's preview version, suitable for use in a data URI. It uses the Rails.cache to store the result and avoid recalculating it every time it is called. An example of usage for the Photo model might be: # Create a new photo for a branch object branch = Branch.first photo = Photo.new(owner: branch, image: params[:image]) if photo.save","title":"Photo"},{"location":"models/#preferencegroup","text":"The PreferenceGroup model represents a group of questions that are related to each other. It has the following attributes: id: a unique identifier for the preference group (integer, primary key). title: a string representing the title of the preference group. question_ids: an array of integers representing the ids of the questions that belong to the preference group. created_at: a datetime representing when the preference group was created. updated_at: a datetime representing the last time the preference group was updated. It has the following relationships: has_many :role_preference_group_assignments: this indicates that a preference group can have many assignments to roles. It has the following custom methods: question_ids=: this method is used to set the question_ids attribute, and it removes any blank values from the array of new ids before saving them. questions: this method returns a collection of Question objects that belong to the preference group, based on the question_ids attribute. An example of usage could be: # Find the preference group with id 1 pg = PreferenceGroup.find(1) # Display the title of the preference group puts pg.title # => \"Food Preferences\" # Display the questions that belong to the preference group pg.questions.each do |question| puts question.text end # => \"What is your favourite type of cuisine?\" # => \"Do you have any dietary restrictions?\" # => \"Do you have any food allergies?\"","title":"PreferenceGroup"},{"location":"models/#profilerequest","text":"The ProfileRequest model represents a request made by a user for access to a branch's profile page. It has the following attributes: id : a unique identifier for the request branch_id : the ID of the branch that the user is requesting access to user_id : the ID of the user making the request created_at : a timestamp for when the request was created updated_at : a timestamp for when the request was last updated It has the following relationships: belongs_to :branch: indicates that each ProfileRequest belongs to a single Branch belongs_to :user: indicates that each ProfileRequest belongs to a single User It does not have any custom methods or examples of usage.","title":"ProfileRequest"},{"location":"models/#question","text":"The Question model represents a question that can be asked to a user. It has various attributes such as title, kind, and locking_conditions that define the question and its behavior. The Question model also has relationships with other models such as Category, Photo, Answer, and UserAnswer. Attributes id (bigint, primary key) : a unique identifier for the question. category_id (integer) : the id of the category that the question belongs to. title (citext) : the title of the question. kind (string) : the type of question, which can be one of the following values: 'option', 'unordered_list', 'ordered_list', 'boolean', 'number', 'number_range', 'temperature', 'temperature_range', 'text', 'time', 'time_range'. created_at (datetime) : the timestamp when the question was created. updated_at (datetime) : the timestamp when the question was last updated. locking_conditions (jsonb) : a JSON object that defines the conditions under which the question should be locked. intro (boolean) : a flag indicating whether the question is an introduction question. allows_note (boolean) : a flag indicating whether the question allows the user to add a note. note_title (string) : the title of the note that the user can add to the question. processed_at (datetime) : the timestamp when the question was processed. text_style (string) : the style of the text for the question. Can be one of the following values: 'dark', 'light', 'dark-gold', 'light-gold'. blur_background (boolean) : a flag indicating whether the background should be blurred for the question. background_overlay (boolean): a flag indicating whether there should be an overlay on the background for the question. Relationships category (belongs_to) : the category that the question belongs to. photo (has_one) : the photo that is associated with the question. answers (has_many) : the answers that are available for the question. user_answers (has_many) : the answers that have been given by users for the question. Custom Methods enumerable_kind? : returns a boolean indicating whether the question is one of the following types: 'option', 'unordered_list', 'ordered_list', 'boolean', 'number', 'number_range', 'temperature', 'temperature_range'. diverse_kind? : returns a boolean indicating whether the question is one of the following types: 'text', 'time', 'time_range'. Examples of Usage Here are some examples of how the Question model can be used: To create a new question: question = Question.new(title: 'What is your favorite color?', kind: 'option') question.save To retrieve all the questions in a particular category: category = Category.find_by(name: 'Personal') questions = Question.in_category(category)","title":"Question"},{"location":"models/#rating","text":"The Rating model represents a rating given by a user for a particular branch. It has various attributes such as value that define the rating, and relationships with other models such as Branch and User. Attributes id (bigint, primary key) : a unique identifier for the rating. branch_id (bigint) : the id of the branch that the rating is for. user_id (bigint) : the id of the user who gave the rating. value (integer) : the value of the rating, which must be an integer between 1 and 5. created_at (datetime) : the timestamp when the rating was created. updated_at (datetime) : the timestamp when the rating was last updated. Relationships branch (belongs_to) : the branch that the rating is for. user (belongs_to) : the user who gave the rating. Custom Methods There are no custom methods defined in the Rating model. Examples of Usage Here are some examples of how the Rating model can be used: To create a new rating: branch = Branch.find_by(name: 'My Branch') user = User.find_by(email: 'user@example.com') rating = Rating.new(branch: branch, user: user, value: 4) rating.save To retrieve all the ratings for a particular branch: branch = Branch.find_by(name: 'My Branch') ratings = Rating.where(branch: branch) To retrieve the average rating value for a particular branch: branch = Branch.find_by(name: 'My Branch') average_rating = Rating.where(branch: branch).average(:value)","title":"Rating"},{"location":"models/#release","text":"The Release model represents a release of data. It has various attributes such as file and status that define the release, and a relationship with the ReleaseFileUploader uploader. Attributes id (bigint, primary key) : a unique identifier for the release. file (string) : the file that contains the data for the release. status (string) : the status of the release, which can be one of the following values: 'queued', 'processing', 'complete'. created_at (datetime) : the timestamp when the release was created. updated_at (datetime) : the timestamp when the release was last updated. Relationships file (mount_uploader) : the ReleaseFileUploader uploader that is used to handle the file for the release. Custom Methods latest : returns the latest complete release. latest_timestamp : returns the timestamp of the latest complete release. latest_id : returns the id of the latest complete release. latest? : returns a boolean indicating whether the release is the latest complete release. queued? : returns a boolean indicating whether the release is in the 'queued' status. processing? : returns a boolean indicating whether the release is in the 'processing' status. complete? : returns a boolean indicating whether the release is in the 'complete' status. process! : sets the status of the release to 'processing' and broadcasts the status change. complete! : sets the status of the release to 'complete' and broadcasts the status change. Examples of Usage Here are some examples of how the Release model can be used: To create a new release: release = Release.new(file: '/path/to/file.csv') release.save To retrieve the latest complete release: latest_release = Release.latest To retrieve the timestamp of the latest complete release: latest_timestamp = Release.latest_timestamp To check if a particular release is the latest complete release: release = Release.find(1) release.latest? To set the status of a release to 'processing': release = Release.find(1) release.process! To set the status of a release to 'complete': release = Release.find(1) release.complete!","title":"Release"},{"location":"models/#roleassignment","text":"The RoleAssignment model represents a role that has been assigned to a staff member. It has various attributes such as role_id and staff_member_id that define the assignment, and relationships with other models such as Role and StaffMember. Attributes id (bigint, primary key) : a unique identifier for the role assignment. role_id (bigint) : the id of the role that has been assigned. staff_member_id (bigint) : the id of the staff member who has been assigned the role. archived_at (datetime) : the timestamp when the role assignment was archived. created_at (datetime) : the timestamp when the role assignment was created. updated_at (datetime) : the timestamp when the role assignment was last updated. Relationships role (belongs_to) : the role that has been assigned. staff_member (belongs_to) : the staff member who has been assigned the role. Custom Methods There are no custom methods defined in the RoleAssignment model. Examples of Usage Here are some examples of how the RoleAssignment model can be used: To create a new role assignment: role = Role.find_by(name: 'Manager') staff_member = StaffMember.find_by(email: 'staff@example.com') role_assignment = RoleAssignment.new(role: role, staff_member: staff_member) role_assignment.save To retrieve all the role assignments for a particular role: role = Role.find_by(name: 'Manager') role_assignments = RoleAssignment.where(role: role) To retrieve all the role assignments for a particular staff member: staff_member = StaffMember.find_by(email: 'staff@example.com') role_assignments = RoleAssignment.where(staff_member: staff_member)","title":"RoleAssignment"},{"location":"models/#rolepreferencegroupassignment","text":"The RolePreferenceGroupAssignment model represents the assignment of a preference group to a role. It has various attributes such as role_id, preference_group_id, and position that define the assignment, and relationships with other models such as Role and PreferenceGroup. Attributes id (bigint, primary key) : a unique identifier for the role preference group assignment. role_id (bigint) : the id of the role to which the preference group has been assigned. preference_group_id (bigint) : the id of the preference group that has been assigned to the role. position (integer) : the position of the preference group within the role. column (string) : the column in which the preference group should be displayed (either 'left' or 'right'). created_at (datetime) : the timestamp when the role preference group assignment was created. updated_at (datetime) : the timestamp when the role preference group assignment was last updated. Relationships role (belongs_to) : the role to which the preference group has been assigned. preference_group (belongs_to) : the preference group that has been assigned to the role. **Custom Methods left : a scope that returns all the role preference group assignments with the column attribute set to 'left'. right : a scope that returns all the role preference group assignments with the column attribute set to 'right'. Examples of Usage Here are some examples of how the RolePreferenceGroupAssignment model can be used: To create a new role preference group assignment: role = Role.find_by(name: 'Manager') preference_group = PreferenceGroup.find_by(name: 'General') role_preference_group_assignment = RolePreferenceGroupAssignment.new( role: role, preference_group: preference_group, position: 1, column: 'left' ) role_preference_group","title":"RolePreferenceGroupAssignment"},{"location":"models/#role","text":"The Role model represents a role within an organization. It has various attributes such as name, business_unit_id, and interactions that define the role, and relationships with other models such as BusinessUnit, StaffMember, and MemberRequestType. Attributes id (bigint, primary key) :a unique identifier for the role. name (string) :the name of the role. created_at (datetime) :the timestamp when the role was created. updated_at (datetime) :the timestamp when the role was last updated. archived_at (datetime) :the timestamp when the role was archived (if applicable). business_unit_id (bigint) :the id of the business unit to which the role belongs. top_questions_data (jsonb) :a JSON object containing data about the top questions for the role. interactions (string, array) :an array of strings representing the interactions that are allowed for the role. Relationships business_unit (belongs_to) :the business unit to which the role belongs. organisation (has_one, through: business_unit) :the organization to which the role belongs. role_assignments (has_many) :the assignments of staff members to the role. staff_members (has_many, through: role_assignments) :the staff members who have been assigned to the role. member_request_type_assignments (has_many) :the assignments of member request types to the role. member_request_types (has_many, through: member_request_type_assignments) :the member request types that have been assigned to the role. Custom Methods **top_questions_data=: a setter method that sets the top_questions_data attribute and converts the values to integers. top_question(position) :a method that returns the id of the top question at the specified position. top_question_ids : a method that returns an array of ids of the top questions for the role. top_questions : a method that returns the top questions for the role as a collection of Question objects.","title":"Role"},{"location":"models/#share","text":"The Share model represents a user's request to share a Branch with another user. It has several attributes: branch_id : an integer that represents the Branch being shared user_id : an integer that represents the User making the request status : a string that represents the current state of the share request (e.g. requested, authorised, revoked, denied) via : a string that represents how the request was made (e.g. web, email, sms) requested_at, authorised_at, denied_at, revoked_at : timestamps for when the respective actions were taken It has several relationships: belongs_to :branch : a Share belongs to a Branch belongs_to :user : a Share belongs to a User It has several custom methods: request, authorise, deny, revoke : methods that update the status attribute and perform other actions depending on the transition (e.g. sending notifications, scheduling a reminder job). These methods are implemented using the aasm gem for state management. revoke_all : a class method that updates the status attribute of all authorised shares to revoked create_request_notification, authorise_notifications, deny_notifications, update_notifications, schedule_reminder, notify_graphql_share_change : private methods that perform actions such as creating notifications, scheduling jobs, and triggering GraphQL subscriptions. An example of usage: share = Share.new(branch_id: 1, user_id: 2) share.request This will create a new Share object with a status of requested, and trigger the create_request_notification method to send a notification to the user.","title":"Share"},{"location":"models/#staffassignment","text":"The StaffAssignment model represents an association between a staff member and a target object. The target object can be any object that has an id column in the database and is polymorphic (can be associated with multiple types of objects). Attributes id : A big integer primary key. staff_member_id : An integer that represents the id of the associated staff member. target_type : A string that represents the class name of the associated target object. target_id : An integer that represents the id of the associated target object. created_at : A datetime that represents the time at which the staff assignment was created. updated_at : A datetime that represents the time at which the staff assignment was last updated. archived_at : A datetime that represents the time at which the staff assignment was archived. Relationships belongs_to :staff_member: The staff assignment belongs to a staff member. belongs_to :target, polymorphic: true: The staff assignment belongs to a target object that is polymorphic. Custom Methods None. Examples of Usage Suppose we have a Project model and a StaffMember model and we want to create a staff assignment that associates a staff member with a project. We could do so as follows: project = Project.find(1) staff_member = StaffMember.find(2) staff_assignment = StaffAssignment.new( staff_member: staff_member, target: project ) if staff_assignment.save puts \"Staff assignment created successfully!\" else puts \"Error creating staff assignment: #{staff_assignment.errors.full_messages.join(', ')}\" end","title":"StaffAssignment"},{"location":"models/#topquestion","text":"The TopQuestion model is a subclass of the Question model, which represents a question that can be asked to users. It has the following attributes: id : a primary key, an integer, that uniquely identifies the question. category_id : an integer that represents the category to which the question belongs. title : a string that represents the title of the question. kind : a string that represents the type of question, such as multiple choice or true/false. created_at : a datetime that represents the time when the question was created. updated_at : a datetime that represents the time when the question was last updated. locking_conditions : a jsonb field that represents the conditions under which the question is locked. intro : a boolean field that represents whether the question is an introduction question or not. allows_note : a boolean field that represents whether the question allows users to add a note or not. note_title : a string that represents the title of the note that users can add. processed_at : a datetime that represents the time when the question was processed. text_style : a string that represents the style of the text used in the question. blur_background : a boolean field that represents whether the background of the question should be blurred or not. background_overlay : a boolean field that represents whether an overlay should be applied to the background of the question or not. The TopQuestion model has the following custom method: answers: returns a relation that represents the answers given by the user specified by the user_id class attribute to the question. An example of usage of the TopQuestion model is as follows: # Set the user ID for the current thread TopQuestion.user_id = current_user.id # Find the top question for the user top_question = TopQuestion.find(params[:id]) # Get the answers given by the user to the top question answers = top_question.answers","title":"TopQuestion"},{"location":"models/#useranswer","text":"The UserAnswer model represents an answer to a question by a user. It has the following attributes: id : a unique identifier for the answer, stored as a bigint user_id : the identifier of the user who provided the answer, stored as an integer question_id : the identifier of the question being answered, stored as an integer created_at : a timestamp for when the answer was created, stored as a datetime updated_at : a timestamp for when the answer was last updated, stored as a datetime note : a text field for storing a note or explanation related to the answer values : a text field for storing the actual answer, which can be serialized into different data types depending on the type of the question It has the following relationships: belongs_to :question : each answer belongs to a single question belongs_to :user : each answer is provided by a single user It has the following custom methods: Question::KINDS.each do |kind_name| define_method(\"#{kind_name}?\") { kind == kind_name } end : this generates methods for each type of question, such as ordered_list?, unordered_list?, text?, etc., which return a boolean indicating whether the answer's question has the corresponding type. values_format : a private method that validates the format of the values attribute based on the type of the question. If the format is invalid, it adds an error to the values attribute. Here are some examples of how the UserAnswer model could be used: # Create a new user answer answer = UserAnswer.new(user_id: 1, question_id: 2, values: 'This is my answer') answer.save # Find a user answer by its id answer = UserAnswer.find(5) # Update an existing user answer answer.values = 'This is my updated answer' answer.save # Check if a user answer's question is of a certain type answer.text? # returns true if the question is a text type, false otherwise # Access the user and question associated with a user answer user = answer.user question = answer.question","title":"UserAnswer"},{"location":"models/#videocontentcategory","text":"VideoContentCategory is a model in a Ruby on Rails application that represents the many-to-many relationship between videos and content categories. It has the following attributes: id : a bigint that serves as the primary key for the model and is automatically generated by the database. video_id : a bigint that represents the foreign key for the video model. content_category_id : a bigint that represents the foreign key for the content_category model. created_at : a datetime that represents when the record was created. updated_at : a datetime that represents when the record was last updated. It has the following relationships: belongs_to :video : This indicates that each instance of the VideoContentCategory model belongs to a single video model. belongs_to :content_category : This indicates that each instance of the VideoContentCategory model belongs to a single content_category model. It has the following custom methods: None. Here is an example of how the VideoContentCategory model might be used: # Create a new video content category record that associates a video with a content category video_content_category = VideoContentCategory.new(video_id: 1, content_category_id: 2) # Save the video content category record to the database video_content_category.save","title":"VideoContentCategory"},{"location":"models/#video","text":"Video is a model in a Ruby on Rails application that represents a video that can be published and viewed by users. It has the following attributes: id : a bigint that serves as the primary key for the model and is automatically generated by the database. name : a string that represents the name of the video. description : a text field that provides a description of the video. url : a string that represents the URL of the video. published_at : a datetime that represents when the video was published. organisation_id : a bigint that represents the foreign key for the organisation model. vista_admin_id : a bigint that represents the foreign key for the vista_admin model. notification_job_id : an integer that represents the ID of a notification job related to the video. created_at : a datetime that represents when the record was created. updated_at : a datetime that represents when the record was last updated. published : a boolean that indicates whether the video has been published or not. archived_at : a datetime that represents when the video was archived. platform_id : a string that represents the ID of the video on a platform like Vimeo. It has the following relationships: has_many :video_content_categories, dependent: :destroy : This indicates that a video can have many video content categories and that these should be destroyed when the video is destroyed. has_many :content_categories, through: :video_content_categories : This indicates that a video can have many content categories through its video content categories. belongs_to :vista_admin : This indicates that a video belongs to a single vista admin. belongs_to :organisation, optional : true: This indicates that a video can optionally belong to an organisation. It has the following custom methods: check_published_status : This method is called before the video is saved and checks if the published status has changed. If it has and the video is being published, it sets the published_at attribute to the current time. extract_platform_id : This method is called before the video is saved and extracts the ID of the video on a platform like Vimeo from the url attribute. It also has the following scope methods: in_organisation : This scope filters videos by the given organisation. newest_first : This scope orders videos by their created_at attribute in descending order. for_vista : This scope filters videos that do not belong to an organisation. search : This scope filters videos by a search term that is matched against the name and description attributes. published : This scope filters published videos. Here is an example of how the Video model might be used: Copy code # Find all published videos in an organisation videos = Video.in_organisation(1).published # Find the most recently created video newest_video = Video.newest_first.first # Search for videos with the term 'cat' in their name or description cat_videos = Video.search('cat')","title":"Video"},{"location":"models/#vistaadmin","text":"VistaAdmin is a model in a Ruby on Rails application that represents an administrator for the Vista platform. It has the following attributes: id : a bigint that serves as the primary key for the model and is automatically generated by the database. first_name : a string that represents the first name of the administrator. last_name : a string that represents the last name of the administrator. email : a string that represents the email address of the administrator. encrypted_password : a string that represents the encrypted password of the administrator. reset_password_token : a string that represents a token used for resetting the password. reset_password_sent_at : a datetime that represents when the reset password token was sent. remember_created_at : a datetime that represents when the administrator chose to be remembered. sign_in_count : an integer that represents the number of times the administrator has signed in. current_sign_in_at : a datetime that represents the current sign in time of the administrator. last_sign_in_at : a datetime that represents the last sign in time of the administrator. current_sign_in_ip : an inet field that represents the current sign in IP address of the administrator. last_sign_in_ip : an inet field that represents the last sign in IP address of the administrator. confirmation_token : a string that represents a confirmation token for the administrator. confirmed_at : a datetime that represents when the administrator was confirmed. confirmation_sent_at : a datetime that represents when the confirmation token was sent. unconfirmed_email : a string that represents the unconfirmed email address of the administrator. failed_attempts : an integer that represents the number of failed attempts by the administrator. unlock_token : a string that represents a token used to unlock the administrator's account. locked_at : a datetime that represents when the administrator's account was locked. created_at : a datetime that represents when the record was created. updated_at : a datetime that represents when the record was last updated. It has the following relationships: has_many :videos : This indicates that a VistaAdmin can have many videos. It has the following custom methods: attempt_set_password : This method allows the administrator to set a new password without knowing the current password. no_password? : This method returns a boolean indicating whether the administrator has a password set. only_if_unconfirmed : This method yields to a block if the administrator has not been confirmed. password_match? : This method returns a boolean indicating whether the entered password and password confirmation match. It also includes the Devise module for authentication and confirmation. Here is an example of how the VistaAdmin model might be used: # Find a VistaAdmin by email vista_admin = VistaAdmin.find_by(email: 'admin@example.com') # Check if the VistaAdmin's password is blank if vista_admin.no_password?","title":"VistaAdmin"},{"location":"models/concern/","text":"CacheWarmer The CacheWarmer module is a concern that can be included in a model. It defines a class method cache_warm_attributes, which can be used to specify a list of attributes of the model that should be cached. The concern also defines a private method warm_cache, which is an after_commit hook that runs the CacheWarmerJob with the current model instance as an argument. This job is responsible for warming the cache for the specified attributes of the model instance. Example usage: class User < ApplicationRecord include CacheWarmer cache_warm_attributes :first_name, :last_name, :email end In this example, the User model will have a cache warmed for its first_name, last_name, and email attributes after it is created or updated. CleanAttributes CleanAttributes is a Rails concern that defines a clean_attributes method and a before_validation callback that calls this method. The clean_attributes method expects a list of attribute names as arguments. The method is intended to be used to \"clean\" the values of these attributes by calling the squish method on them. The squish method removes excess white space from the beginning and end of a string and replaces any internal sequences of white space with a single space character. Attributes None. Relationships None. Custom methods clean_attributes(*attributes): This method defines a clean_attributes instance method that expects a list of attribute names as arguments. It also defines a before_validation callback that calls this method. The clean_attributes method iterates over the provided attribute names and calls the squish method on the value of each attribute. It then assigns the result back to the attribute. This method is intended to be used to \"clean\" the values of the provided attributes by removing excess white space and replacing internal sequences of white space with a single space character. Examples of usage In a model: class User < ApplicationRecord include CleanAttributes clean_attributes :first_name, :last_name, :email # ... end This will define a before_validation callback in the User model that calls the clean_attributes method before validation. The clean_attributes method will \"clean\" the values of the first_name, last_name, and email attributes by calling the squish method on them. EnforceNil The EnforceNil module is designed to be included in a Rails model and provides a enforce_nil class method which can be used to set specified attributes to nil before the model is saved to the database. Attributes that should be set to nil are passed as arguments to the enforce_nil method, and a before_save callback is defined to invoke the enforce_nil method before the model is saved. The enforce_nil method sets the specified attributes to nil if their current value is \"blank\", meaning it is nil, an empty string, or an empty array. Here's an example of how the EnforceNil module could be used in a model: class User < ApplicationRecord include EnforceNil enforce_nil :phone_number, :email end This would add a before_save callback to the User model which invokes the enforce_nil method. The phone_number and email attributes of the User model would be set to nil if they are blank when the model is saved to the database. HasContentCategories The HasContentCategories module is a concern that adds scopes and methods to a model that allows it to be associated with ContentCategory models. Attributes: The HasContentCategories module does not define any new attributes for the model it is included in. Relationships: The HasContentCategories module adds a has_and_belongs_to_many relationship with the ContentCategory model. This relationship is created through the ContentCategoriesModel join model. Custom methods: The HasContentCategories module defines the following custom methods: in_category(categories) : This scope returns all records that are associated with the ContentCategory records specified in the categories parameter. for_user(user) : This class method returns all records that are not associated with any ContentCategory records that are marked as hidden for the User specified in the user parameter. Examples of usage: Here is an example of how the HasContentCategories module could be used: class Article < ApplicationRecord include HasContentCategories # ... other code end # Find all articles that are associated with the 'News' and 'Entertainment' categories Article.in_category(['News', 'Entertainment']) # Find all articles that are not hidden for a specific user user = User.find(1) Article.for_user(user) HasPhoto The HasPhoto module defines a has_one relationship between a model and a Photo model, and allows the model to accept nested attributes for a Photo. Attributes The HasPhoto module does not define any new attributes for the model it is included in. Relationships The HasPhoto module defines a has_one relationship between a model and a Photo model. Custom methods The HasPhoto module defines a reject_photos? method that determines if a Photo should be rejected based on the presence of certain attributes. Examples of usage The HasPhoto module could be included in a StaffMember model to allow a StaffMember to have a Photo associated with it. It could be used like this: class StaffMember < ApplicationRecord include HasPhoto end HasPreferenceGroups The HasPreferenceGroups module is a module that can be included in a Ruby on Rails model to give the model the ability to have preference groups. Attributes: role_preference_group_assignments : a has-many association with the RolePreferenceGroupAssignment model. This attribute represents the preference group assignments that belong to the model instance. preference_groups : a has-many association with the PreferenceGroup model, through the role_preference_group_assignments attribute. This attribute represents the preference groups that belong to the model instance. Relationships: HasPreferenceGroups has a one-to-many relationship with the RolePreferenceGroupAssignment model through the role_preference_group_assignments attribute. HasPreferenceGroups has a one-to-many relationship with the PreferenceGroup model through the preference_groups attribute. Custom methods: preference_structure_left : returns an array of hashes representing the preference groups and their positions on the left side of the screen for the model instance. preference_structure_left= : accepts an array of hashes representing preference group data and assigns them to the model instance, setting their column to \"left\". preference_structure_right : returns an array of hashes representing the preference groups and their positions on the right side of the screen for the model instance. preference_structure_right= : accepts an array of hashes representing preference group data and assigns them to the model instance, setting their column to \"right\". preference_structure_json : returns a hash representing a preference group and its position. role_preference_group_assignments_attributes : accepts an array of hashes representing preference group data and returns a hash of attributes for use in mass assignment for the RolePreferenceGroupAssignment model. Examples of usage: class User < ApplicationRecord include HasPreferenceGroups end user = User PaperTrailUser The PaperTrailUser module is a concern that adds a custom method to a model. The paper_trail_actor method accepts a user_type argument and defines a actor method on the model. The actor method returns an instance of the user_type class with an id equal to the value of the whodunnit attribute of the model. If the whodunnit attribute is not present, the actor method returns nil. Attributes: whodunnit : an attribute of the model that holds the id of the user who performed an action that resulted in a change to the model Relationships: None Custom methods: paper_trail_actor : Accepts a user_type argument and defines the actor method on the model. actor : Returns an instance of the user_type class with an id equal to the value of the whodunnit attribute of the model. If the whodunnit attribute is not present, returns nil. Example of usage: class User < ApplicationRecord include PaperTrailUser paper_trail_actor :user end user = User.create(name: 'Bob') # => #<User id: 1, name: 'Bob', whodunnit: 1> VersionsTable The VersionsTable module is a Rails concern that allows you to specify the name of the table that should be used to store version records for a model. Attributes: None Relationships: None Custom methods: versions_table(versions_table_name): specifies the name of the table that should be used to store version records for the model Example of usage: class MyModel < ApplicationRecord include VersionsTable versions_table :my_model_versions end","title":"concerns"},{"location":"models/concern/#cachewarmer","text":"The CacheWarmer module is a concern that can be included in a model. It defines a class method cache_warm_attributes, which can be used to specify a list of attributes of the model that should be cached. The concern also defines a private method warm_cache, which is an after_commit hook that runs the CacheWarmerJob with the current model instance as an argument. This job is responsible for warming the cache for the specified attributes of the model instance. Example usage: class User < ApplicationRecord include CacheWarmer cache_warm_attributes :first_name, :last_name, :email end In this example, the User model will have a cache warmed for its first_name, last_name, and email attributes after it is created or updated.","title":"CacheWarmer"},{"location":"models/concern/#cleanattributes","text":"CleanAttributes is a Rails concern that defines a clean_attributes method and a before_validation callback that calls this method. The clean_attributes method expects a list of attribute names as arguments. The method is intended to be used to \"clean\" the values of these attributes by calling the squish method on them. The squish method removes excess white space from the beginning and end of a string and replaces any internal sequences of white space with a single space character. Attributes None. Relationships None. Custom methods clean_attributes(*attributes): This method defines a clean_attributes instance method that expects a list of attribute names as arguments. It also defines a before_validation callback that calls this method. The clean_attributes method iterates over the provided attribute names and calls the squish method on the value of each attribute. It then assigns the result back to the attribute. This method is intended to be used to \"clean\" the values of the provided attributes by removing excess white space and replacing internal sequences of white space with a single space character. Examples of usage In a model: class User < ApplicationRecord include CleanAttributes clean_attributes :first_name, :last_name, :email # ... end This will define a before_validation callback in the User model that calls the clean_attributes method before validation. The clean_attributes method will \"clean\" the values of the first_name, last_name, and email attributes by calling the squish method on them.","title":"CleanAttributes"},{"location":"models/concern/#enforcenil","text":"The EnforceNil module is designed to be included in a Rails model and provides a enforce_nil class method which can be used to set specified attributes to nil before the model is saved to the database. Attributes that should be set to nil are passed as arguments to the enforce_nil method, and a before_save callback is defined to invoke the enforce_nil method before the model is saved. The enforce_nil method sets the specified attributes to nil if their current value is \"blank\", meaning it is nil, an empty string, or an empty array. Here's an example of how the EnforceNil module could be used in a model: class User < ApplicationRecord include EnforceNil enforce_nil :phone_number, :email end This would add a before_save callback to the User model which invokes the enforce_nil method. The phone_number and email attributes of the User model would be set to nil if they are blank when the model is saved to the database.","title":"EnforceNil"},{"location":"models/concern/#hascontentcategories","text":"The HasContentCategories module is a concern that adds scopes and methods to a model that allows it to be associated with ContentCategory models. Attributes: The HasContentCategories module does not define any new attributes for the model it is included in. Relationships: The HasContentCategories module adds a has_and_belongs_to_many relationship with the ContentCategory model. This relationship is created through the ContentCategoriesModel join model. Custom methods: The HasContentCategories module defines the following custom methods: in_category(categories) : This scope returns all records that are associated with the ContentCategory records specified in the categories parameter. for_user(user) : This class method returns all records that are not associated with any ContentCategory records that are marked as hidden for the User specified in the user parameter. Examples of usage: Here is an example of how the HasContentCategories module could be used: class Article < ApplicationRecord include HasContentCategories # ... other code end # Find all articles that are associated with the 'News' and 'Entertainment' categories Article.in_category(['News', 'Entertainment']) # Find all articles that are not hidden for a specific user user = User.find(1) Article.for_user(user)","title":"HasContentCategories"},{"location":"models/concern/#hasphoto","text":"The HasPhoto module defines a has_one relationship between a model and a Photo model, and allows the model to accept nested attributes for a Photo. Attributes The HasPhoto module does not define any new attributes for the model it is included in. Relationships The HasPhoto module defines a has_one relationship between a model and a Photo model. Custom methods The HasPhoto module defines a reject_photos? method that determines if a Photo should be rejected based on the presence of certain attributes. Examples of usage The HasPhoto module could be included in a StaffMember model to allow a StaffMember to have a Photo associated with it. It could be used like this: class StaffMember < ApplicationRecord include HasPhoto end","title":"HasPhoto"},{"location":"models/concern/#haspreferencegroups","text":"The HasPreferenceGroups module is a module that can be included in a Ruby on Rails model to give the model the ability to have preference groups. Attributes: role_preference_group_assignments : a has-many association with the RolePreferenceGroupAssignment model. This attribute represents the preference group assignments that belong to the model instance. preference_groups : a has-many association with the PreferenceGroup model, through the role_preference_group_assignments attribute. This attribute represents the preference groups that belong to the model instance. Relationships: HasPreferenceGroups has a one-to-many relationship with the RolePreferenceGroupAssignment model through the role_preference_group_assignments attribute. HasPreferenceGroups has a one-to-many relationship with the PreferenceGroup model through the preference_groups attribute. Custom methods: preference_structure_left : returns an array of hashes representing the preference groups and their positions on the left side of the screen for the model instance. preference_structure_left= : accepts an array of hashes representing preference group data and assigns them to the model instance, setting their column to \"left\". preference_structure_right : returns an array of hashes representing the preference groups and their positions on the right side of the screen for the model instance. preference_structure_right= : accepts an array of hashes representing preference group data and assigns them to the model instance, setting their column to \"right\". preference_structure_json : returns a hash representing a preference group and its position. role_preference_group_assignments_attributes : accepts an array of hashes representing preference group data and returns a hash of attributes for use in mass assignment for the RolePreferenceGroupAssignment model. Examples of usage: class User < ApplicationRecord include HasPreferenceGroups end user = User","title":"HasPreferenceGroups"},{"location":"models/concern/#papertrailuser","text":"The PaperTrailUser module is a concern that adds a custom method to a model. The paper_trail_actor method accepts a user_type argument and defines a actor method on the model. The actor method returns an instance of the user_type class with an id equal to the value of the whodunnit attribute of the model. If the whodunnit attribute is not present, the actor method returns nil. Attributes: whodunnit : an attribute of the model that holds the id of the user who performed an action that resulted in a change to the model Relationships: None Custom methods: paper_trail_actor : Accepts a user_type argument and defines the actor method on the model. actor : Returns an instance of the user_type class with an id equal to the value of the whodunnit attribute of the model. If the whodunnit attribute is not present, returns nil. Example of usage: class User < ApplicationRecord include PaperTrailUser paper_trail_actor :user end user = User.create(name: 'Bob') # => #<User id: 1, name: 'Bob', whodunnit: 1>","title":"PaperTrailUser"},{"location":"models/concern/#versionstable","text":"The VersionsTable module is a Rails concern that allows you to specify the name of the table that should be used to store version records for a model. Attributes: None Relationships: None Custom methods: versions_table(versions_table_name): specifies the name of the table that should be used to store version records for the model Example of usage: class MyModel < ApplicationRecord include VersionsTable versions_table :my_model_versions end","title":"VersionsTable"},{"location":"models/personality/","text":"Food The Personality::Food class represents the food personality of a user. It is used to determine the frequency at which a user eats out per month. Attributes: @user : An instance of the User model representing the user whose food personality is being calculated. question: An instance of the Question model representing the question \"How many times per month do you eat out?\". answer : An instance of the Answer model representing the answer provided by the user to the question \"How many times per month do you eat out?\". Relationships: The Personality::Food class has a one-to-many relationship with the User model through the @user attribute. The Personality::Food class has a one-to-many relationship with the Question model through the question attribute. The Personality::Food class has a one-to-many relationship with the Answer model through the answer attribute. Custom methods: result : This method returns an integer value representing the user's food personality based on their answer to the question \"How many times per month do you eat out?\". Examples of usage: To determine the food personality of a user: user = User.find(1) food_personality = Personality::Food.new(user) food_personality_result = food_personality.result To determine the food personality of all users: users = User.all food_personalities = users.map do |user| Personality::Food.new(user) end food_personality_results = food_personalities.map(&:result) Lifestyle The Personality::Lifestyle class is a model that represents a user's lifestyle as determined by their answers to a questionnaire. It has a result method that returns an integer representing the user's lifestyle on a scale of 1 to 4, with 1 being the most economical and 4 being the most extravagant. The result method determines the user's lifestyle by looking up the answer to a specific question (whose title is stored in the constant TITLE) and returning a value based on the answer's values attribute. The question and answer methods are private and are used to retrieve the relevant question and answer objects from the database. The initialize method takes in a user object and sets it as an instance variable to be used in the question and answer methods. Wine The Personality::Wine class is a model that represents a user's preference for good wine. It contains a single method, result, which returns an integer based on the user's answer to a specific question about their wine preference. The result method checks the user's answer to the question and returns a corresponding integer value of 1 or 4. If the user's answer is \"No\", the method returns 1. If the user's answer is \"Yes\", the method returns 4. If the user has not provided an answer, the method returns 0. The Personality::Wine class also has a constant, TITLE, which stores the string \"Do you have a pallet for good wine?\". Attributes: @user : an instance variable that stores a reference to the user object. Relationships: The Personality::Wine class has a one-to-many relationship with the Answer model, through the @user attribute. Custom methods: result : a method that returns an integer based on the user's answer to a specific question about their wine preference. Examples of usage: user = User.find(1) personality_wine = Personality::Wine.new(user) result = personality_wine.result puts result # Outputs 1 or 4, depending on the user's answer to the question","title":"personality"},{"location":"models/personality/#food","text":"The Personality::Food class represents the food personality of a user. It is used to determine the frequency at which a user eats out per month. Attributes: @user : An instance of the User model representing the user whose food personality is being calculated. question: An instance of the Question model representing the question \"How many times per month do you eat out?\". answer : An instance of the Answer model representing the answer provided by the user to the question \"How many times per month do you eat out?\". Relationships: The Personality::Food class has a one-to-many relationship with the User model through the @user attribute. The Personality::Food class has a one-to-many relationship with the Question model through the question attribute. The Personality::Food class has a one-to-many relationship with the Answer model through the answer attribute. Custom methods: result : This method returns an integer value representing the user's food personality based on their answer to the question \"How many times per month do you eat out?\". Examples of usage: To determine the food personality of a user: user = User.find(1) food_personality = Personality::Food.new(user) food_personality_result = food_personality.result To determine the food personality of all users: users = User.all food_personalities = users.map do |user| Personality::Food.new(user) end food_personality_results = food_personalities.map(&:result)","title":"Food"},{"location":"models/personality/#lifestyle","text":"The Personality::Lifestyle class is a model that represents a user's lifestyle as determined by their answers to a questionnaire. It has a result method that returns an integer representing the user's lifestyle on a scale of 1 to 4, with 1 being the most economical and 4 being the most extravagant. The result method determines the user's lifestyle by looking up the answer to a specific question (whose title is stored in the constant TITLE) and returning a value based on the answer's values attribute. The question and answer methods are private and are used to retrieve the relevant question and answer objects from the database. The initialize method takes in a user object and sets it as an instance variable to be used in the question and answer methods.","title":"Lifestyle"},{"location":"models/personality/#wine","text":"The Personality::Wine class is a model that represents a user's preference for good wine. It contains a single method, result, which returns an integer based on the user's answer to a specific question about their wine preference. The result method checks the user's answer to the question and returns a corresponding integer value of 1 or 4. If the user's answer is \"No\", the method returns 1. If the user's answer is \"Yes\", the method returns 4. If the user has not provided an answer, the method returns 0. The Personality::Wine class also has a constant, TITLE, which stores the string \"Do you have a pallet for good wine?\". Attributes: @user : an instance variable that stores a reference to the user object. Relationships: The Personality::Wine class has a one-to-many relationship with the Answer model, through the @user attribute. Custom methods: result : a method that returns an integer based on the user's answer to a specific question about their wine preference. Examples of usage: user = User.find(1) personality_wine = Personality::Wine.new(user) result = personality_wine.result puts result # Outputs 1 or 4, depending on the user's answer to the question","title":"Wine"},{"location":"models/version/","text":"AnswerVersion The AnswerVersion model is a class that represents a version of an Answer object. It is responsible for storing changes made to an Answer object and recording metadata about these changes, such as the time they were made and the user who made them. Attributes: id : a unique integer identifier for the version item_type : a string indicating the type of object being versioned (in this case, Answer) item_id : an integer identifier for the Answer object being versioned event : a string indicating the type of change being made to the object (e.g. create, update, destroy) whodunnit : a string identifier for the user who made the change object : a JSON column containing the state of the Answer object at the time of the version object_changes : a JSON column containing the changes made to the object in this version ip_address : the IP address of the client making the change user_agent : the user agent of the client making the change created_at : a timestamp for when the version was created Relationships: AnswerVersion is related to Answer through the item_type and item_id columns. AnswerVersion has no custom methods. Base The Versions::Base class is a subclass of PaperTrail::Version, which is a model that stores the changes made to other models in your application. Versions::Base includes two concerns: PaperTrailUser and VersionsTable. PaperTrailUser provides a custom method called actor, which returns the user object associated with the version record. This is determined by the whodunnit field, which stores the ID of the user who made the change. actor fetches the user object with this ID and returns it. VersionsTable provides a class method called versions_table, which allows you to specify the name of the database table that should be used to store version records. This can be useful if you want to store version records in a table with a different name than the default, which is versions. Example usage: class User < ApplicationRecord has_paper_trail end user = User.create(name: 'John') user.update(name: 'Jane') version = Versions::Base.last version.actor # returns the user object who made the change QuestionVersion The QuestionVersion model is a class that extends the Base class in the Versions module. It represents the version of a Question object in the question_versions table in the database. The QuestionVersion model has the following attributes: id : a bigint representing the primary key of the record. item_type : a string representing the type of the object being versioned. In this case, it will always be \"Question\". item_id : a bigint representing the ID of the Question object being versioned. event : a string representing the type of event that caused the version to be created. This can be \"create\", \"update\", or \"destroy\". whodunnit : a string representing the ID of the user who caused the version to be created. object: a JSONB column representing the serialized version of the Question object at the time the version was created. object_changes : a JSONB column representing the changes made to the Question object between this version and the previous version. ip_address : an inet column representing the IP address of the user who caused the version to be created. user_agent : a string representing the user agent of the user who caused the version to be created. created_at : a datetime representing the time the version was created. The QuestionVersion model has the following custom methods: versions_table : a class method that sets the name of the table to be used for storing versions. paper_trail_actor : a class method that sets the type of user that caused the version to be created. UserAnswerVersion The model Versions::UserAnswerVersion is a subclass of Versions::Base. It stores information about versions of UserAnswer records. Versions::Base includes the PaperTrailUser and VersionsTable modules, which provide methods for accessing the actor responsible for creating a version and customizing the table name and sequence name of the model, respectively. Attributes: id : a unique identifier for the version item_type : the type of record that the version belongs to (in this case, \"UserAnswer\") item_id : the unique identifier of the record that the version belongs to event : the type of event that triggered the version creation (e.g. \"create\", \"update\", \"destroy\") whodunnit : a string representing the actor responsible for creating the version object : a JSON column storing the serialized version of the record object_changes : a JSON column storing the changes made to the record in this version ip_address : the IP address of the actor responsible for creating the version user_agent : the user agent of the actor responsible for creating the version created_at : the timestamp for when the version was created Relationships: None. Custom methods: paper_trail_actor(user_type) : a class method that defines a actor method on the model, which retrieves the actor responsible for creating the version. user_type is the type of actor that is expected (e.g. :vista_admin, :user). versions_table(versions_table_name) : a class method that sets the table_name and sequence_name class attributes to the specified versions_table_name. Example of usage: # Find the latest version of a user's answer with id 1 latest_version = Versions::UserAnswerVersion.where(item_id: 1).last # Print the event that triggered this version puts latest_version.event # Print the actor responsible for creating this version puts latest_version.actor.username # Print the changes made to the user's answer in this version puts latest_version.object_changes UserVersion The Versions::UserVersion class is a class representing a version of a user object. It is a subclass of the Versions::Base class which includes the PaperTrailUser and VersionsTable modules. Attributes: id : a bigint representing the primary key for the record. item_type : a string representing the type of item being tracked (in this case, \"User\"). item_id : a bigint representing the id of the user object being tracked. event : a string representing the type of change being tracked (e.g. \"create\", \"update\", \"destroy\"). whodunnit : a string representing the id of the user who made the change. object : a JSONB column representing the state of the user object at the time of the change. object_changes: a JSONB column representing the changes made to the user object at the time of the change. ip_address : an INET column representing the IP address of the user who made the change. user_agent : a string representing the user agent of the user who made the change. created_at : a datetime representing the time the change was made. Relationships: None. Custom methods: None, besides those inherited from the PaperTrailUser and VersionsTable modules. Examples of usage: When a user object is created, updated, or destroyed, a new Versions::UserVersion object is created and associated with the user object. The Versions::UserVersion class can be queried to retrieve a list of changes made to user objects over time.","title":"version"},{"location":"models/version/#answerversion","text":"The AnswerVersion model is a class that represents a version of an Answer object. It is responsible for storing changes made to an Answer object and recording metadata about these changes, such as the time they were made and the user who made them. Attributes: id : a unique integer identifier for the version item_type : a string indicating the type of object being versioned (in this case, Answer) item_id : an integer identifier for the Answer object being versioned event : a string indicating the type of change being made to the object (e.g. create, update, destroy) whodunnit : a string identifier for the user who made the change object : a JSON column containing the state of the Answer object at the time of the version object_changes : a JSON column containing the changes made to the object in this version ip_address : the IP address of the client making the change user_agent : the user agent of the client making the change created_at : a timestamp for when the version was created Relationships: AnswerVersion is related to Answer through the item_type and item_id columns. AnswerVersion has no custom methods.","title":"AnswerVersion"},{"location":"models/version/#base","text":"The Versions::Base class is a subclass of PaperTrail::Version, which is a model that stores the changes made to other models in your application. Versions::Base includes two concerns: PaperTrailUser and VersionsTable. PaperTrailUser provides a custom method called actor, which returns the user object associated with the version record. This is determined by the whodunnit field, which stores the ID of the user who made the change. actor fetches the user object with this ID and returns it. VersionsTable provides a class method called versions_table, which allows you to specify the name of the database table that should be used to store version records. This can be useful if you want to store version records in a table with a different name than the default, which is versions. Example usage: class User < ApplicationRecord has_paper_trail end user = User.create(name: 'John') user.update(name: 'Jane') version = Versions::Base.last version.actor # returns the user object who made the change","title":"Base"},{"location":"models/version/#questionversion","text":"The QuestionVersion model is a class that extends the Base class in the Versions module. It represents the version of a Question object in the question_versions table in the database. The QuestionVersion model has the following attributes: id : a bigint representing the primary key of the record. item_type : a string representing the type of the object being versioned. In this case, it will always be \"Question\". item_id : a bigint representing the ID of the Question object being versioned. event : a string representing the type of event that caused the version to be created. This can be \"create\", \"update\", or \"destroy\". whodunnit : a string representing the ID of the user who caused the version to be created. object: a JSONB column representing the serialized version of the Question object at the time the version was created. object_changes : a JSONB column representing the changes made to the Question object between this version and the previous version. ip_address : an inet column representing the IP address of the user who caused the version to be created. user_agent : a string representing the user agent of the user who caused the version to be created. created_at : a datetime representing the time the version was created. The QuestionVersion model has the following custom methods: versions_table : a class method that sets the name of the table to be used for storing versions. paper_trail_actor : a class method that sets the type of user that caused the version to be created.","title":"QuestionVersion"},{"location":"models/version/#useranswerversion","text":"The model Versions::UserAnswerVersion is a subclass of Versions::Base. It stores information about versions of UserAnswer records. Versions::Base includes the PaperTrailUser and VersionsTable modules, which provide methods for accessing the actor responsible for creating a version and customizing the table name and sequence name of the model, respectively. Attributes: id : a unique identifier for the version item_type : the type of record that the version belongs to (in this case, \"UserAnswer\") item_id : the unique identifier of the record that the version belongs to event : the type of event that triggered the version creation (e.g. \"create\", \"update\", \"destroy\") whodunnit : a string representing the actor responsible for creating the version object : a JSON column storing the serialized version of the record object_changes : a JSON column storing the changes made to the record in this version ip_address : the IP address of the actor responsible for creating the version user_agent : the user agent of the actor responsible for creating the version created_at : the timestamp for when the version was created Relationships: None. Custom methods: paper_trail_actor(user_type) : a class method that defines a actor method on the model, which retrieves the actor responsible for creating the version. user_type is the type of actor that is expected (e.g. :vista_admin, :user). versions_table(versions_table_name) : a class method that sets the table_name and sequence_name class attributes to the specified versions_table_name. Example of usage: # Find the latest version of a user's answer with id 1 latest_version = Versions::UserAnswerVersion.where(item_id: 1).last # Print the event that triggered this version puts latest_version.event # Print the actor responsible for creating this version puts latest_version.actor.username # Print the changes made to the user's answer in this version puts latest_version.object_changes","title":"UserAnswerVersion"},{"location":"models/version/#userversion","text":"The Versions::UserVersion class is a class representing a version of a user object. It is a subclass of the Versions::Base class which includes the PaperTrailUser and VersionsTable modules. Attributes: id : a bigint representing the primary key for the record. item_type : a string representing the type of item being tracked (in this case, \"User\"). item_id : a bigint representing the id of the user object being tracked. event : a string representing the type of change being tracked (e.g. \"create\", \"update\", \"destroy\"). whodunnit : a string representing the id of the user who made the change. object : a JSONB column representing the state of the user object at the time of the change. object_changes: a JSONB column representing the changes made to the user object at the time of the change. ip_address : an INET column representing the IP address of the user who made the change. user_agent : a string representing the user agent of the user who made the change. created_at : a datetime representing the time the change was made. Relationships: None. Custom methods: None, besides those inherited from the PaperTrailUser and VersionsTable modules. Examples of usage: When a user object is created, updated, or destroyed, a new Versions::UserVersion object is created and associated with the user object. The Versions::UserVersion class can be queried to retrieve a list of changes made to user objects over time.","title":"UserVersion"},{"location":"route/","text":"API POST /v1/login Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Body { \"email\": \"chris@kanso.io\", \"password\": \"password\" } Response 200 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"5f2469bc79d1ccf2cb0554ccf3314e3c\" X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 4014520d-7732-4bf3-8d42-8f31a1b2e3ec X-Runtime: 0.175549 Cache-Control: max-age=0, private, must-revalidate Transfer-Encoding: chunked Body {\"token\":\"<auth token>\",\"needsOnboarding\":false} POST /v1/register Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Body { \"email\": \"kathy.villeda@example.com\", \"password\": \"password\" } Response 200 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"d37626fa2db73f508eb6fb5c7ce71ca3\" X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: e7e24330-beac-48e4-abdb-3378d76fb214 X-Runtime: 0.362156 Cache-Control: max-age=0, private, must-revalidate Transfer-Encoding: chunked Body {\"token\":\"z89byAP37vpiouiZsPiAVmux\",\"needsOnboarding\":true} POST /v1/register Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Body { \"email\": \"test@test.com\", \"password\": \"password\" } Response 401 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 069b4a52-b0a1-4b57-831e-b1ff14ceef44 X-Runtime: 0.623524 Cache-Control: no-cache Transfer-Encoding: chunked Body {\"errors\":[{\"source\":{\"pointer\":\"/data/attributes/email\"},\"detail\":\"Email is already taken\"}]} GET /v1/me Request (application/json) Headers Accept: application/json Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers X-Runtime: 0.082517 X-Xss-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: fddcffef-bf97-43be-b16e-e143a19c2898 X-Content-Type-Options: nosniff Etag: W/\"e4675e989b64cd71d9e119f2d28a33cd\" X-Frame-Options: SAMEORIGIN Last-Modified: Tue, 10 Oct 2017 13:45:05 GMT Body {\"id\":2,\"email\":\"chris@kanso.io\",\"firstName\":\"Chris\",\"lastName\":\"Edwards\",\"name\":\"Chris Edwards\",\"jobTitle\":\"null\",\"company\":\"null\",\"address\":\"null\",\"memberId\":\"DnMZrZ\",\"updatedAt\":\"2017-10-10T13:45:05.089Z\",\"avatar\":{\"id\":54,\"largeUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/large_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=0d33cb46c3b0a49e1a1ab80097a8a84bff20149afdd39aa40256453b7035c502\",\"mediumUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/medium_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=ab95bbbb0e5b94ea3d8ca803f33bb1ba9e4e2e4ea778f80d41921131c3053051\",\"squareUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/square_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=17479710095e896416fc016cff48cf1adb0b3b5123ffc629813b5de922d872c1\",\"thumbUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/thumb_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=797ae5b7d962b92571213aeced23aca81d219d9dc55a4e47c4248b349ae1a82f\"}} PUT /v1/me Request (application/x-www-form-urlencoded; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Body user%5Bname%5D=Chris+Edwards GET /v1/partners Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers X-Runtime: 0.240713 X-Xss-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: 1519535a-24fc-4c8e-ab36-f7fba864b551 X-Content-Type-Options: nosniff Etag: W/\"9b185923d3c6d3ae7d173461a960d9f0\" X-Frame-Options: SAMEORIGIN Body [{\"id\":1,\"name\":\"Park Hyatt New York\",\"about\":\"Across the street from Carnegie Hall, this sleek hotel in Midtown is a minute's walk from 57th Street subway station and a mile from the Lincoln Centre\",\"email\":\"\",\"latitude\":40.765605,\"longitude\":-73.97904,\"categories\":[\"Hotels\"],\"sharingProfile\":false,\"address\":{\"id\":43,\"label\":null,\"line1\":\"153 W 57th St\",\"line2\":\"\",\"town\":\"New York\",\"county\":\"NY\",\"postcode\":\"10019\",\"country\":\"US\",\"phone\":\"\",\"latitude\":\"40.765605\",\"longitude\":\"-73.97904\"},\"photo\":{\"id\":57,\"largeUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/large_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=e995f55a282fd2a6ce4271035a91ab20deceea76128b3ee60e4c1fcb43b141e1\",\"mediumUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/medium_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=95680861779a39adcedd0b7c50e52dc0c8cedd2c538bd4a1d66808ae47a37e3a\",\"squareUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/square_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=179a4651788d7cf9bbc0d75b73cefff44d14014762d07608c407ad6deffebc8e\",\"thumbUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/thumb_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=fac106dd72c2cbf8cc49f28d14ece447cc6be00c10e2c0099dd64235537307ce\"}}] POST /v1/partners/1/share Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 12481b72-4f85-4c34-b15a-78afabedd4b5 X-Runtime: 0.327847 Cache-Control: no-cache DELETE /v1/partners/1/revoke Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> DELETE /v1/partners/revoke Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 62078460-f384-4cfb-8eb0-5990c8eea40f X-Runtime: 0.044358 Cache-Control: no-cache GET /v1/categories Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers Last-Modified: Tue, 24 Oct 2017 13:46:07 GMT X-Runtime: 0.064698 Set-Cookie: _vista_platform_session=Y0VJa1NlVTNPQWIzZXdDSFNLc1RFOGlIemllMUZnaHM2dzUwSEJVNTBSNk5ob1NPU3NGVDExUkRLc2ZUcVhLS1d6NEJIbVRzL2VrcEltVGVRb3dsdXpZY0FNUjlYVDJPTU1BRlZud0Q1SGlUVFMrTVVxVWo0WVpxQ1o4Q2dML2IyUXVCaHVnVUhJOTc0Snl5K1E4YVN3PT0tLUl1OG1aWXUyVEw5RnJaRGJHaURjSWc9PQ%3D%3D--8ba94682a0d98648f7d6cb4d6d6ac3785fdc15a9; path=/; HttpOnly X-XSS-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: a60e1d64-8c16-4c49-b4f3-3dcee22c7fea X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"39062c091082b7fb83083db8c4ea041b\" X-Frame-Options: SAMEORIGIN Body [ { \"id\": 4222, \"title\": \"General\", \"description\": \"Maecenas faucibus mollis interdum. Nulla vitae elit libero, a pharetra augue. Nulla vitae elit libero, a pharetra augue. Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam. Cras mattis consectetur purus sit amet fermentum.\", \"parentId\": 4211, \"hasChildren\": false, \"ancestry\": \"4211\", \"subtreeQuestionsCount\": 6, \"ignored\": false, \"position\": 1, \"initial\": false, \"visibilityConditions\": null, \"photo\": { \"id\": 4107, \"largeUrl\": \"http://assets.vista.test/uploads/photo/image/4107/large_440.jpeg\", \"mediumUrl\": \"http://assets.vista.test/uploads/photo/image/4107/medium_440.jpeg\", \"squareUrl\": \"http://assets.vista.test/uploads/photo/image/4107/square_440.jpeg\", \"thumbUrl\": \"http://assets.vista.test/uploads/photo/image/4107/thumb_440.jpeg\" } }, { \"id\": 4213, \"title\": \"Parking\", \"description\": \"Maecenas faucibus mollis interdum. Nulla vitae elit libero, a pharetra augue. Nulla vitae elit libero, a pharetra augue. Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam. Cras mattis consectetur purus sit amet fermentum.\", \"parentId\": 4211, \"hasChildren\": false, \"ancestry\": \"4211\", \"subtreeQuestionsCount\": 2, \"ignored\": false, \"position\": 2, \"initial\": false, \"visibilityConditions\": null, \"photo\": { \"id\": 4104, \"largeUrl\": \"http://assets.vista.test/uploads/photo/image/4104/large_440.jpeg\", \"mediumUrl\": \"http://assets.vista.test/uploads/photo/image/4104/medium_440.jpeg\", \"squareUrl\": \"http://assets.vista.test/uploads/photo/image/4104/square_440.jpeg\", \"thumbUrl\": \"http://assets.vista.test/uploads/photo/image/4104/thumb_440.jpeg\" } } ] GET /v1/questions Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers Last-Modified: Fri, 20 Oct 2017 15:10:59 GMT X-Runtime: 16.743717 Set-Cookie: _vista_platform_session=SExnWlI2czdiNmRUOHF2WkJMcThteXkyMEw2Kzliekh2RFQ1eFY5MmpINXB0ZnJMcVhYb3FqTFA4UlZwZFJTdVRWK2ptVUgvdFkrQ1kvTHBjRFVELyt4SU1VZW5DRG5pQStTdVlpZ1JnaU40M0JBZDBTUXVpUGxvci81RDRUOVlBSkl2dkNvUWQreDV1M3V0a1g0My9BPT0tLURLR0xJeHNYajJ6cWd4MU85TlF2aHc9PQ%3D%3D--a3ffad65f936408151f08d22e03ac77aff229d92; path=/; HttpOnly X-XSS-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: 72c8a29e-6574-4728-8603-896b313b621d X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"521fefadcabf9349305b98d53243afd6\" X-Frame-Options: SAMEORIGIN Body [ { \"id\": 283, \"title\": \"Eos porro sequi velit.?\", \"categoryId\": 4222, \"kind\": \"time\", \"lockingConditions\": null, \"intro\": false, \"allowsNote\": true, \"noteTitle\": null, \"visibilityConditions\": [], \"photo\": null, \"answers\": [] }, { \"id\": 284, \"title\": \"Error blanditiis et in et iure non laboriosam.?\", \"categoryId\": 4222, \"kind\": \"option\", \"lockingConditions\": null, \"intro\": false, \"allowsNote\": true, \"noteTitle\": null, \"visibilityConditions\": [], \"photo\": null, \"answers\": [ { \"id\": 551, \"title\": \"Quia et repellat sit.\", \"description\": \"Dolores vel qui laudantium beatae eum et nemo. Explicabo inventore deserunt consequatur aut ipsam doloremque. Quo repellat fuga nobis atque. Officia vel libero. Velit non ratione sint odio enim fuga.\", \"photo\": null }, { \"id\": 550, \"title\": \"Eaque inventore aut voluptas et placeat sit.\", \"description\": \"Aspernatur hic ea voluptas quidem quos. Commodi laboriosam dolores architecto facere eum deserunt ut. Voluptates et minima exercitationem dolores enim. Tempora sed fugit omnis et.\", \"photo\": null }, { \"id\": 549, \"title\": \"Nihil aut blanditiis rerum harum animi incidunt voluptatem adipisci.\", \"description\": \"Repellendus aut autem voluptatem veniam. Suscipit enim labore dignissimos et. Occaecati dolor labore voluptas et sed.\", \"photo\": null } ] } ] GET /v1/news Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers X-Runtime: 0.099705 Set-Cookie: _vista_platform_session=<vista token>; path=/; HttpOnly X-XSS-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: a4f77782-aa40-446d-9554-52e336b9f46c X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN Etag: W/\"657c4fa5eae94aa1fcfc41f72713078b\" Body [{\"id\":3,\"title\":\"Reprehenderit quae rerum voluptatibus consequatur molestiae.\",\"content\":\"Ut natus alias sit quas a. Nulla pariatur voluptatem esse labore explicabo ut soluta. Quaerat corrupti consequatur asperiores quam veniam animi reprehenderit. Neque et excepturi non consequatur iure dolore.\",\"publishAt\":\"2017-10-25T14:44:11.965Z\",\"headerImage\":null},{\"id\":2,\"title\":\"Consequatur architecto est quos.\",\"content\":\"Quidem voluptates numquam. Eum dolor commodi ullam ducimus voluptatem. Sint cumque aut id ut quo. Error aut dolore ut non maxime. Tempora necessitatibus debitis alias omnis ad unde.\",\"publishAt\":\"2017-10-25T14:44:01.694Z\",\"headerImage\":null},{\"id\":1,\"title\":\"In et et rerum.\",\"content\":\"Quas et voluptates qui reprehenderit. Fugit id molestiae exercitationem libero. At nihil consequatur soluta.\",\"publishAt\":\"2017-10-25T14:42:52.127Z\",\"headerImage\":null}] POST /v1/categories/ /ignore Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: e30ae883-45c7-4e0b-a186-adc8347802b5 X-Runtime: 0.016333 Cache-Control: no-cache DELETE /v1/categories/ /ignore Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: db00018d-bd1a-4621-801d-300f2bb569f6 X-Runtime: 0.014774 Cache-Control: no-cache POST /v1/password/reset Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Body { \"email\": \"foo\" } Response 400 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: ad3bcf39-eea9-4526-9ada-85e95c1afbbc X-Runtime: 0.007599 Cache-Control: no-cache Transfer-Encoding: chunked Body {\"errors\":[{\"detail\":\"No user found for request\"}]} PUT /v1/password/reset Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Body { \"token\": \"bad\", \"password\": \"password\", \"password_confirmation\": \"password\" } Response 400 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 4fb7572f-38c4-4a99-a033-e01466874fc6 X-Runtime: 0.013222 Cache-Control: no-cache Transfer-Encoding: chunked Body {\"errors\":{\"token\":\"Password reset token invalid\"}}","title":"Index"},{"location":"route/#api","text":"","title":"API"},{"location":"route/#post-v1login","text":"Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Body { \"email\": \"chris@kanso.io\", \"password\": \"password\" } Response 200 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"5f2469bc79d1ccf2cb0554ccf3314e3c\" X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 4014520d-7732-4bf3-8d42-8f31a1b2e3ec X-Runtime: 0.175549 Cache-Control: max-age=0, private, must-revalidate Transfer-Encoding: chunked Body {\"token\":\"<auth token>\",\"needsOnboarding\":false}","title":"POST /v1/login"},{"location":"route/#post-v1register","text":"Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Body { \"email\": \"kathy.villeda@example.com\", \"password\": \"password\" } Response 200 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"d37626fa2db73f508eb6fb5c7ce71ca3\" X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: e7e24330-beac-48e4-abdb-3378d76fb214 X-Runtime: 0.362156 Cache-Control: max-age=0, private, must-revalidate Transfer-Encoding: chunked Body {\"token\":\"z89byAP37vpiouiZsPiAVmux\",\"needsOnboarding\":true}","title":"POST /v1/register"},{"location":"route/#post-v1register_1","text":"Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Body { \"email\": \"test@test.com\", \"password\": \"password\" } Response 401 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 069b4a52-b0a1-4b57-831e-b1ff14ceef44 X-Runtime: 0.623524 Cache-Control: no-cache Transfer-Encoding: chunked Body {\"errors\":[{\"source\":{\"pointer\":\"/data/attributes/email\"},\"detail\":\"Email is already taken\"}]}","title":"POST /v1/register"},{"location":"route/#get-v1me","text":"Request (application/json) Headers Accept: application/json Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers X-Runtime: 0.082517 X-Xss-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: fddcffef-bf97-43be-b16e-e143a19c2898 X-Content-Type-Options: nosniff Etag: W/\"e4675e989b64cd71d9e119f2d28a33cd\" X-Frame-Options: SAMEORIGIN Last-Modified: Tue, 10 Oct 2017 13:45:05 GMT Body {\"id\":2,\"email\":\"chris@kanso.io\",\"firstName\":\"Chris\",\"lastName\":\"Edwards\",\"name\":\"Chris Edwards\",\"jobTitle\":\"null\",\"company\":\"null\",\"address\":\"null\",\"memberId\":\"DnMZrZ\",\"updatedAt\":\"2017-10-10T13:45:05.089Z\",\"avatar\":{\"id\":54,\"largeUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/large_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=0d33cb46c3b0a49e1a1ab80097a8a84bff20149afdd39aa40256453b7035c502\",\"mediumUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/medium_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=ab95bbbb0e5b94ea3d8ca803f33bb1ba9e4e2e4ea778f80d41921131c3053051\",\"squareUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/square_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=17479710095e896416fc016cff48cf1adb0b3b5123ffc629813b5de922d872c1\",\"thumbUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/54/thumb_photo.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171011T094219Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171011/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=797ae5b7d962b92571213aeced23aca81d219d9dc55a4e47c4248b349ae1a82f\"}}","title":"GET /v1/me"},{"location":"route/#put-v1me","text":"Request (application/x-www-form-urlencoded; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Body user%5Bname%5D=Chris+Edwards","title":"PUT /v1/me"},{"location":"route/#get-v1partners","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers X-Runtime: 0.240713 X-Xss-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: 1519535a-24fc-4c8e-ab36-f7fba864b551 X-Content-Type-Options: nosniff Etag: W/\"9b185923d3c6d3ae7d173461a960d9f0\" X-Frame-Options: SAMEORIGIN Body [{\"id\":1,\"name\":\"Park Hyatt New York\",\"about\":\"Across the street from Carnegie Hall, this sleek hotel in Midtown is a minute's walk from 57th Street subway station and a mile from the Lincoln Centre\",\"email\":\"\",\"latitude\":40.765605,\"longitude\":-73.97904,\"categories\":[\"Hotels\"],\"sharingProfile\":false,\"address\":{\"id\":43,\"label\":null,\"line1\":\"153 W 57th St\",\"line2\":\"\",\"town\":\"New York\",\"county\":\"NY\",\"postcode\":\"10019\",\"country\":\"US\",\"phone\":\"\",\"latitude\":\"40.765605\",\"longitude\":\"-73.97904\"},\"photo\":{\"id\":57,\"largeUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/large_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=e995f55a282fd2a6ce4271035a91ab20deceea76128b3ee60e4c1fcb43b141e1\",\"mediumUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/medium_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=95680861779a39adcedd0b7c50e52dc0c8cedd2c538bd4a1d66808ae47a37e3a\",\"squareUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/square_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=179a4651788d7cf9bbc0d75b73cefff44d14014762d07608c407ad6deffebc8e\",\"thumbUrl\":\"https://bucketeer-5fb9bfbe-c595-490e-8a9e-f78c342d65bf.s3-eu-west-1.amazonaws.com/uploads/photo/image/57/thumb_Park_Hyatt_New_York_usn_2.jpg?X-Amz-Expires=600\\u0026X-Amz-Date=20171018T110152Z\\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\\u0026X-Amz-Credential=AKIAID6MULWOTL2HSBXQ/20171018/eu-west-1/s3/aws4_request\\u0026X-Amz-SignedHeaders=host\\u0026X-Amz-Signature=fac106dd72c2cbf8cc49f28d14ece447cc6be00c10e2c0099dd64235537307ce\"}}]","title":"GET /v1/partners"},{"location":"route/#post-v1partners1share","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 12481b72-4f85-4c34-b15a-78afabedd4b5 X-Runtime: 0.327847 Cache-Control: no-cache","title":"POST /v1/partners/1/share"},{"location":"route/#delete-v1partners1revoke","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token>","title":"DELETE /v1/partners/1/revoke"},{"location":"route/#delete-v1partnersrevoke","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 62078460-f384-4cfb-8eb0-5990c8eea40f X-Runtime: 0.044358 Cache-Control: no-cache","title":"DELETE /v1/partners/revoke"},{"location":"route/#get-v1categories","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers Last-Modified: Tue, 24 Oct 2017 13:46:07 GMT X-Runtime: 0.064698 Set-Cookie: _vista_platform_session=Y0VJa1NlVTNPQWIzZXdDSFNLc1RFOGlIemllMUZnaHM2dzUwSEJVNTBSNk5ob1NPU3NGVDExUkRLc2ZUcVhLS1d6NEJIbVRzL2VrcEltVGVRb3dsdXpZY0FNUjlYVDJPTU1BRlZud0Q1SGlUVFMrTVVxVWo0WVpxQ1o4Q2dML2IyUXVCaHVnVUhJOTc0Snl5K1E4YVN3PT0tLUl1OG1aWXUyVEw5RnJaRGJHaURjSWc9PQ%3D%3D--8ba94682a0d98648f7d6cb4d6d6ac3785fdc15a9; path=/; HttpOnly X-XSS-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: a60e1d64-8c16-4c49-b4f3-3dcee22c7fea X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"39062c091082b7fb83083db8c4ea041b\" X-Frame-Options: SAMEORIGIN Body [ { \"id\": 4222, \"title\": \"General\", \"description\": \"Maecenas faucibus mollis interdum. Nulla vitae elit libero, a pharetra augue. Nulla vitae elit libero, a pharetra augue. Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam. Cras mattis consectetur purus sit amet fermentum.\", \"parentId\": 4211, \"hasChildren\": false, \"ancestry\": \"4211\", \"subtreeQuestionsCount\": 6, \"ignored\": false, \"position\": 1, \"initial\": false, \"visibilityConditions\": null, \"photo\": { \"id\": 4107, \"largeUrl\": \"http://assets.vista.test/uploads/photo/image/4107/large_440.jpeg\", \"mediumUrl\": \"http://assets.vista.test/uploads/photo/image/4107/medium_440.jpeg\", \"squareUrl\": \"http://assets.vista.test/uploads/photo/image/4107/square_440.jpeg\", \"thumbUrl\": \"http://assets.vista.test/uploads/photo/image/4107/thumb_440.jpeg\" } }, { \"id\": 4213, \"title\": \"Parking\", \"description\": \"Maecenas faucibus mollis interdum. Nulla vitae elit libero, a pharetra augue. Nulla vitae elit libero, a pharetra augue. Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam. Cras mattis consectetur purus sit amet fermentum.\", \"parentId\": 4211, \"hasChildren\": false, \"ancestry\": \"4211\", \"subtreeQuestionsCount\": 2, \"ignored\": false, \"position\": 2, \"initial\": false, \"visibilityConditions\": null, \"photo\": { \"id\": 4104, \"largeUrl\": \"http://assets.vista.test/uploads/photo/image/4104/large_440.jpeg\", \"mediumUrl\": \"http://assets.vista.test/uploads/photo/image/4104/medium_440.jpeg\", \"squareUrl\": \"http://assets.vista.test/uploads/photo/image/4104/square_440.jpeg\", \"thumbUrl\": \"http://assets.vista.test/uploads/photo/image/4104/thumb_440.jpeg\" } } ]","title":"GET /v1/categories"},{"location":"route/#get-v1questions","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers Last-Modified: Fri, 20 Oct 2017 15:10:59 GMT X-Runtime: 16.743717 Set-Cookie: _vista_platform_session=SExnWlI2czdiNmRUOHF2WkJMcThteXkyMEw2Kzliekh2RFQ1eFY5MmpINXB0ZnJMcVhYb3FqTFA4UlZwZFJTdVRWK2ptVUgvdFkrQ1kvTHBjRFVELyt4SU1VZW5DRG5pQStTdVlpZ1JnaU40M0JBZDBTUXVpUGxvci81RDRUOVlBSkl2dkNvUWQreDV1M3V0a1g0My9BPT0tLURLR0xJeHNYajJ6cWd4MU85TlF2aHc9PQ%3D%3D--a3ffad65f936408151f08d22e03ac77aff229d92; path=/; HttpOnly X-XSS-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: 72c8a29e-6574-4728-8603-896b313b621d X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin Etag: W/\"521fefadcabf9349305b98d53243afd6\" X-Frame-Options: SAMEORIGIN Body [ { \"id\": 283, \"title\": \"Eos porro sequi velit.?\", \"categoryId\": 4222, \"kind\": \"time\", \"lockingConditions\": null, \"intro\": false, \"allowsNote\": true, \"noteTitle\": null, \"visibilityConditions\": [], \"photo\": null, \"answers\": [] }, { \"id\": 284, \"title\": \"Error blanditiis et in et iure non laboriosam.?\", \"categoryId\": 4222, \"kind\": \"option\", \"lockingConditions\": null, \"intro\": false, \"allowsNote\": true, \"noteTitle\": null, \"visibilityConditions\": [], \"photo\": null, \"answers\": [ { \"id\": 551, \"title\": \"Quia et repellat sit.\", \"description\": \"Dolores vel qui laudantium beatae eum et nemo. Explicabo inventore deserunt consequatur aut ipsam doloremque. Quo repellat fuga nobis atque. Officia vel libero. Velit non ratione sint odio enim fuga.\", \"photo\": null }, { \"id\": 550, \"title\": \"Eaque inventore aut voluptas et placeat sit.\", \"description\": \"Aspernatur hic ea voluptas quidem quos. Commodi laboriosam dolores architecto facere eum deserunt ut. Voluptates et minima exercitationem dolores enim. Tempora sed fugit omnis et.\", \"photo\": null }, { \"id\": 549, \"title\": \"Nihil aut blanditiis rerum harum animi incidunt voluptatem adipisci.\", \"description\": \"Repellendus aut autem voluptatem veniam. Suscipit enim labore dignissimos et. Occaecati dolor labore voluptas et sed.\", \"photo\": null } ] } ]","title":"GET /v1/questions"},{"location":"route/#get-v1news","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 200 (application/json; charset=utf-8) Headers X-Runtime: 0.099705 Set-Cookie: _vista_platform_session=<vista token>; path=/; HttpOnly X-XSS-Protection: 1; mode=block Transfer-Encoding: chunked Cache-Control: max-age=0, private, must-revalidate X-Request-Id: a4f77782-aa40-446d-9554-52e336b9f46c X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN Etag: W/\"657c4fa5eae94aa1fcfc41f72713078b\" Body [{\"id\":3,\"title\":\"Reprehenderit quae rerum voluptatibus consequatur molestiae.\",\"content\":\"Ut natus alias sit quas a. Nulla pariatur voluptatem esse labore explicabo ut soluta. Quaerat corrupti consequatur asperiores quam veniam animi reprehenderit. Neque et excepturi non consequatur iure dolore.\",\"publishAt\":\"2017-10-25T14:44:11.965Z\",\"headerImage\":null},{\"id\":2,\"title\":\"Consequatur architecto est quos.\",\"content\":\"Quidem voluptates numquam. Eum dolor commodi ullam ducimus voluptatem. Sint cumque aut id ut quo. Error aut dolore ut non maxime. Tempora necessitatibus debitis alias omnis ad unde.\",\"publishAt\":\"2017-10-25T14:44:01.694Z\",\"headerImage\":null},{\"id\":1,\"title\":\"In et et rerum.\",\"content\":\"Quas et voluptates qui reprehenderit. Fugit id molestiae exercitationem libero. At nihil consequatur soluta.\",\"publishAt\":\"2017-10-25T14:42:52.127Z\",\"headerImage\":null}]","title":"GET /v1/news"},{"location":"route/#post-v1categoriesignore","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: e30ae883-45c7-4e0b-a186-adc8347802b5 X-Runtime: 0.016333 Cache-Control: no-cache","title":"POST /v1/categories//ignore"},{"location":"route/#delete-v1categoriesignore","text":"Request Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Response 204 Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: db00018d-bd1a-4621-801d-300f2bb569f6 X-Runtime: 0.014774 Cache-Control: no-cache","title":"DELETE /v1/categories//ignore"},{"location":"route/#post-v1passwordreset","text":"Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Body { \"email\": \"foo\" } Response 400 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: ad3bcf39-eea9-4526-9ada-85e95c1afbbc X-Runtime: 0.007599 Cache-Control: no-cache Transfer-Encoding: chunked Body {\"errors\":[{\"detail\":\"No user found for request\"}]}","title":"POST /v1/password/reset"},{"location":"route/#put-v1passwordreset","text":"Request (application/json; charset=utf-8) Headers Cookie: _vista_platform_session=<vista token> Authorization: Token token=<auth token> Body { \"token\": \"bad\", \"password\": \"password\", \"password_confirmation\": \"password\" } Response 400 (application/json; charset=utf-8) Headers X-Content-Type-Options: nosniff X-Rack-CORS: miss; no-origin X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Request-Id: 4fb7572f-38c4-4a99-a033-e01466874fc6 X-Runtime: 0.013222 Cache-Control: no-cache Transfer-Encoding: chunked Body {\"errors\":{\"token\":\"Password reset token invalid\"}}","title":"PUT /v1/password/reset"}]}